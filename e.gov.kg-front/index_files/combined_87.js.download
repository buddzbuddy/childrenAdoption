var Kontur = Kontur || {};
Kontur.GoogleTagManagerStrictMode = true;
if (window.console) {
    console.info('GTM strict mode: ' + (Kontur.GoogleTagManagerStrictMode ? 'on' : 'off'));
};
if (!(window.Kontur && window.Kontur.GoogleTagManagerStrictMode)) {
    var _gaq = window._gaq || [];

    window.onerror = function (msg, url, line) {
        var preventErrorAlert = false,
            eventCategory = 'JS Error',
            label = 'Url: ' + document.location + '|Document: ' + (url || document.location) + '|Line: ' + line + '|UserAgent: ' + navigator.userAgent + '|Date: ' + new Date().toUTCString();

        _gaq.push(['_trackEvent', eventCategory, msg, label, 0, true]);

        if (typeof window['ga'] == 'function') {
            window.ga('send', 'event', eventCategory, msg, label);
    }

        return preventErrorAlert;
    };
};
/*! jQuery v1.8.3 jquery.com | jquery.org/license */
(function(e,t){function _(e){var t=M[e]={};return v.each(e.split(y),function(e,n){t[n]=!0}),t}function H(e,n,r){if(r===t&&e.nodeType===1){var i="data-"+n.replace(P,"-$1").toLowerCase();r=e.getAttribute(i);if(typeof r=="string"){try{r=r==="true"?!0:r==="false"?!1:r==="null"?null:+r+""===r?+r:D.test(r)?v.parseJSON(r):r}catch(s){}v.data(e,n,r)}else r=t}return r}function B(e){var t;for(t in e){if(t==="data"&&v.isEmptyObject(e[t]))continue;if(t!=="toJSON")return!1}return!0}function et(){return!1}function tt(){return!0}function ut(e){return!e||!e.parentNode||e.parentNode.nodeType===11}function at(e,t){do e=e[t];while(e&&e.nodeType!==1);return e}function ft(e,t,n){t=t||0;if(v.isFunction(t))return v.grep(e,function(e,r){var i=!!t.call(e,r,e);return i===n});if(t.nodeType)return v.grep(e,function(e,r){return e===t===n});if(typeof t=="string"){var r=v.grep(e,function(e){return e.nodeType===1});if(it.test(t))return v.filter(t,r,!n);t=v.filter(t,r)}return v.grep(e,function(e,r){return v.inArray(e,t)>=0===n})}function lt(e){var t=ct.split("|"),n=e.createDocumentFragment();if(n.createElement)while(t.length)n.createElement(t.pop());return n}function Lt(e,t){return e.getElementsByTagName(t)[0]||e.appendChild(e.ownerDocument.createElement(t))}function At(e,t){if(t.nodeType!==1||!v.hasData(e))return;var n,r,i,s=v._data(e),o=v._data(t,s),u=s.events;if(u){delete o.handle,o.events={};for(n in u)for(r=0,i=u[n].length;r<i;r++)v.event.add(t,n,u[n][r])}o.data&&(o.data=v.extend({},o.data))}function Ot(e,t){var n;if(t.nodeType!==1)return;t.clearAttributes&&t.clearAttributes(),t.mergeAttributes&&t.mergeAttributes(e),n=t.nodeName.toLowerCase(),n==="object"?(t.parentNode&&(t.outerHTML=e.outerHTML),v.support.html5Clone&&e.innerHTML&&!v.trim(t.innerHTML)&&(t.innerHTML=e.innerHTML)):n==="input"&&Et.test(e.type)?(t.defaultChecked=t.checked=e.checked,t.value!==e.value&&(t.value=e.value)):n==="option"?t.selected=e.defaultSelected:n==="input"||n==="textarea"?t.defaultValue=e.defaultValue:n==="script"&&t.text!==e.text&&(t.text=e.text),t.removeAttribute(v.expando)}function Mt(e){return typeof e.getElementsByTagName!="undefined"?e.getElementsByTagName("*"):typeof e.querySelectorAll!="undefined"?e.querySelectorAll("*"):[]}function _t(e){Et.test(e.type)&&(e.defaultChecked=e.checked)}function Qt(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=Jt.length;while(i--){t=Jt[i]+n;if(t in e)return t}return r}function Gt(e,t){return e=t||e,v.css(e,"display")==="none"||!v.contains(e.ownerDocument,e)}function Yt(e,t){var n,r,i=[],s=0,o=e.length;for(;s<o;s++){n=e[s];if(!n.style)continue;i[s]=v._data(n,"olddisplay"),t?(!i[s]&&n.style.display==="none"&&(n.style.display=""),n.style.display===""&&Gt(n)&&(i[s]=v._data(n,"olddisplay",nn(n.nodeName)))):(r=Dt(n,"display"),!i[s]&&r!=="none"&&v._data(n,"olddisplay",r))}for(s=0;s<o;s++){n=e[s];if(!n.style)continue;if(!t||n.style.display==="none"||n.style.display==="")n.style.display=t?i[s]||"":"none"}return e}function Zt(e,t,n){var r=Rt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function en(e,t,n,r){var i=n===(r?"border":"content")?4:t==="width"?1:0,s=0;for(;i<4;i+=2)n==="margin"&&(s+=v.css(e,n+$t[i],!0)),r?(n==="content"&&(s-=parseFloat(Dt(e,"padding"+$t[i]))||0),n!=="margin"&&(s-=parseFloat(Dt(e,"border"+$t[i]+"Width"))||0)):(s+=parseFloat(Dt(e,"padding"+$t[i]))||0,n!=="padding"&&(s+=parseFloat(Dt(e,"border"+$t[i]+"Width"))||0));return s}function tn(e,t,n){var r=t==="width"?e.offsetWidth:e.offsetHeight,i=!0,s=v.support.boxSizing&&v.css(e,"boxSizing")==="border-box";if(r<=0||r==null){r=Dt(e,t);if(r<0||r==null)r=e.style[t];if(Ut.test(r))return r;i=s&&(v.support.boxSizingReliable||r===e.style[t]),r=parseFloat(r)||0}return r+en(e,t,n||(s?"border":"content"),i)+"px"}function nn(e){if(Wt[e])return Wt[e];var t=v("<"+e+">").appendTo(i.body),n=t.css("display");t.remove();if(n==="none"||n===""){Pt=i.body.appendChild(Pt||v.extend(i.createElement("iframe"),{frameBorder:0,width:0,height:0}));if(!Ht||!Pt.createElement)Ht=(Pt.contentWindow||Pt.contentDocument).document,Ht.write("<!doctype html><html><body>"),Ht.close();t=Ht.body.appendChild(Ht.createElement(e)),n=Dt(t,"display"),i.body.removeChild(Pt)}return Wt[e]=n,n}function fn(e,t,n,r){var i;if(v.isArray(t))v.each(t,function(t,i){n||sn.test(e)?r(e,i):fn(e+"["+(typeof i=="object"?t:"")+"]",i,n,r)});else if(!n&&v.type(t)==="object")for(i in t)fn(e+"["+i+"]",t[i],n,r);else r(e,t)}function Cn(e){return function(t,n){typeof t!="string"&&(n=t,t="*");var r,i,s,o=t.toLowerCase().split(y),u=0,a=o.length;if(v.isFunction(n))for(;u<a;u++)r=o[u],s=/^\+/.test(r),s&&(r=r.substr(1)||"*"),i=e[r]=e[r]||[],i[s?"unshift":"push"](n)}}function kn(e,n,r,i,s,o){s=s||n.dataTypes[0],o=o||{},o[s]=!0;var u,a=e[s],f=0,l=a?a.length:0,c=e===Sn;for(;f<l&&(c||!u);f++)u=a[f](n,r,i),typeof u=="string"&&(!c||o[u]?u=t:(n.dataTypes.unshift(u),u=kn(e,n,r,i,u,o)));return(c||!u)&&!o["*"]&&(u=kn(e,n,r,i,"*",o)),u}function Ln(e,n){var r,i,s=v.ajaxSettings.flatOptions||{};for(r in n)n[r]!==t&&((s[r]?e:i||(i={}))[r]=n[r]);i&&v.extend(!0,e,i)}function An(e,n,r){var i,s,o,u,a=e.contents,f=e.dataTypes,l=e.responseFields;for(s in l)s in r&&(n[l[s]]=r[s]);while(f[0]==="*")f.shift(),i===t&&(i=e.mimeType||n.getResponseHeader("content-type"));if(i)for(s in a)if(a[s]&&a[s].test(i)){f.unshift(s);break}if(f[0]in r)o=f[0];else{for(s in r){if(!f[0]||e.converters[s+" "+f[0]]){o=s;break}u||(u=s)}o=o||u}if(o)return o!==f[0]&&f.unshift(o),r[o]}function On(e,t){var n,r,i,s,o=e.dataTypes.slice(),u=o[0],a={},f=0;e.dataFilter&&(t=e.dataFilter(t,e.dataType));if(o[1])for(n in e.converters)a[n.toLowerCase()]=e.converters[n];for(;i=o[++f];)if(i!=="*"){if(u!=="*"&&u!==i){n=a[u+" "+i]||a["* "+i];if(!n)for(r in a){s=r.split(" ");if(s[1]===i){n=a[u+" "+s[0]]||a["* "+s[0]];if(n){n===!0?n=a[r]:a[r]!==!0&&(i=s[0],o.splice(f--,0,i));break}}}if(n!==!0)if(n&&e["throws"])t=n(t);else try{t=n(t)}catch(l){return{state:"parsererror",error:n?l:"No conversion from "+u+" to "+i}}}u=i}return{state:"success",data:t}}function Fn(){try{return new e.XMLHttpRequest}catch(t){}}function In(){try{return new e.ActiveXObject("Microsoft.XMLHTTP")}catch(t){}}function $n(){return setTimeout(function(){qn=t},0),qn=v.now()}function Jn(e,t){v.each(t,function(t,n){var r=(Vn[t]||[]).concat(Vn["*"]),i=0,s=r.length;for(;i<s;i++)if(r[i].call(e,t,n))return})}function Kn(e,t,n){var r,i=0,s=0,o=Xn.length,u=v.Deferred().always(function(){delete a.elem}),a=function(){var t=qn||$n(),n=Math.max(0,f.startTime+f.duration-t),r=n/f.duration||0,i=1-r,s=0,o=f.tweens.length;for(;s<o;s++)f.tweens[s].run(i);return u.notifyWith(e,[f,i,n]),i<1&&o?n:(u.resolveWith(e,[f]),!1)},f=u.promise({elem:e,props:v.extend({},t),opts:v.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:qn||$n(),duration:n.duration,tweens:[],createTween:function(t,n,r){var i=v.Tween(e,f.opts,t,n,f.opts.specialEasing[t]||f.opts.easing);return f.tweens.push(i),i},stop:function(t){var n=0,r=t?f.tweens.length:0;for(;n<r;n++)f.tweens[n].run(1);return t?u.resolveWith(e,[f,t]):u.rejectWith(e,[f,t]),this}}),l=f.props;Qn(l,f.opts.specialEasing);for(;i<o;i++){r=Xn[i].call(f,e,l,f.opts);if(r)return r}return Jn(f,l),v.isFunction(f.opts.start)&&f.opts.start.call(e,f),v.fx.timer(v.extend(a,{anim:f,queue:f.opts.queue,elem:e})),f.progress(f.opts.progress).done(f.opts.done,f.opts.complete).fail(f.opts.fail).always(f.opts.always)}function Qn(e,t){var n,r,i,s,o;for(n in e){r=v.camelCase(n),i=t[r],s=e[n],v.isArray(s)&&(i=s[1],s=e[n]=s[0]),n!==r&&(e[r]=s,delete e[n]),o=v.cssHooks[r];if(o&&"expand"in o){s=o.expand(s),delete e[r];for(n in s)n in e||(e[n]=s[n],t[n]=i)}else t[r]=i}}function Gn(e,t,n){var r,i,s,o,u,a,f,l,c,h=this,p=e.style,d={},m=[],g=e.nodeType&&Gt(e);n.queue||(l=v._queueHooks(e,"fx"),l.unqueued==null&&(l.unqueued=0,c=l.empty.fire,l.empty.fire=function(){l.unqueued||c()}),l.unqueued++,h.always(function(){h.always(function(){l.unqueued--,v.queue(e,"fx").length||l.empty.fire()})})),e.nodeType===1&&("height"in t||"width"in t)&&(n.overflow=[p.overflow,p.overflowX,p.overflowY],v.css(e,"display")==="inline"&&v.css(e,"float")==="none"&&(!v.support.inlineBlockNeedsLayout||nn(e.nodeName)==="inline"?p.display="inline-block":p.zoom=1)),n.overflow&&(p.overflow="hidden",v.support.shrinkWrapBlocks||h.done(function(){p.overflow=n.overflow[0],p.overflowX=n.overflow[1],p.overflowY=n.overflow[2]}));for(r in t){s=t[r];if(Un.exec(s)){delete t[r],a=a||s==="toggle";if(s===(g?"hide":"show"))continue;m.push(r)}}o=m.length;if(o){u=v._data(e,"fxshow")||v._data(e,"fxshow",{}),"hidden"in u&&(g=u.hidden),a&&(u.hidden=!g),g?v(e).show():h.done(function(){v(e).hide()}),h.done(function(){var t;v.removeData(e,"fxshow",!0);for(t in d)v.style(e,t,d[t])});for(r=0;r<o;r++)i=m[r],f=h.createTween(i,g?u[i]:0),d[i]=u[i]||v.style(e,i),i in u||(u[i]=f.start,g&&(f.end=f.start,f.start=i==="width"||i==="height"?1:0))}}function Yn(e,t,n,r,i){return new Yn.prototype.init(e,t,n,r,i)}function Zn(e,t){var n,r={height:e},i=0;t=t?1:0;for(;i<4;i+=2-t)n=$t[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}function tr(e){return v.isWindow(e)?e:e.nodeType===9?e.defaultView||e.parentWindow:!1}var n,r,i=e.document,s=e.location,o=e.navigator,u=e.jQuery,a=e.$,f=Array.prototype.push,l=Array.prototype.slice,c=Array.prototype.indexOf,h=Object.prototype.toString,p=Object.prototype.hasOwnProperty,d=String.prototype.trim,v=function(e,t){return new v.fn.init(e,t,n)},m=/[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,g=/\S/,y=/\s+/,b=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,w=/^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,E=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,S=/^[\],:{}\s]*$/,x=/(?:^|:|,)(?:\s*\[)+/g,T=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,N=/"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,C=/^-ms-/,k=/-([\da-z])/gi,L=function(e,t){return(t+"").toUpperCase()},A=function(){i.addEventListener?(i.removeEventListener("DOMContentLoaded",A,!1),v.ready()):i.readyState==="complete"&&(i.detachEvent("onreadystatechange",A),v.ready())},O={};v.fn=v.prototype={constructor:v,init:function(e,n,r){var s,o,u,a;if(!e)return this;if(e.nodeType)return this.context=this[0]=e,this.length=1,this;if(typeof e=="string"){e.charAt(0)==="<"&&e.charAt(e.length-1)===">"&&e.length>=3?s=[null,e,null]:s=w.exec(e);if(s&&(s[1]||!n)){if(s[1])return n=n instanceof v?n[0]:n,a=n&&n.nodeType?n.ownerDocument||n:i,e=v.parseHTML(s[1],a,!0),E.test(s[1])&&v.isPlainObject(n)&&this.attr.call(e,n,!0),v.merge(this,e);o=i.getElementById(s[2]);if(o&&o.parentNode){if(o.id!==s[2])return r.find(e);this.length=1,this[0]=o}return this.context=i,this.selector=e,this}return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e)}return v.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),v.makeArray(e,this))},selector:"",jquery:"1.8.3",length:0,size:function(){return this.length},toArray:function(){return l.call(this)},get:function(e){return e==null?this.toArray():e<0?this[this.length+e]:this[e]},pushStack:function(e,t,n){var r=v.merge(this.constructor(),e);return r.prevObject=this,r.context=this.context,t==="find"?r.selector=this.selector+(this.selector?" ":"")+n:t&&(r.selector=this.selector+"."+t+"("+n+")"),r},each:function(e,t){return v.each(this,e,t)},ready:function(e){return v.ready.promise().done(e),this},eq:function(e){return e=+e,e===-1?this.slice(e):this.slice(e,e+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(l.apply(this,arguments),"slice",l.call(arguments).join(","))},map:function(e){return this.pushStack(v.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:[].sort,splice:[].splice},v.fn.init.prototype=v.fn,v.extend=v.fn.extend=function(){var e,n,r,i,s,o,u=arguments[0]||{},a=1,f=arguments.length,l=!1;typeof u=="boolean"&&(l=u,u=arguments[1]||{},a=2),typeof u!="object"&&!v.isFunction(u)&&(u={}),f===a&&(u=this,--a);for(;a<f;a++)if((e=arguments[a])!=null)for(n in e){r=u[n],i=e[n];if(u===i)continue;l&&i&&(v.isPlainObject(i)||(s=v.isArray(i)))?(s?(s=!1,o=r&&v.isArray(r)?r:[]):o=r&&v.isPlainObject(r)?r:{},u[n]=v.extend(l,o,i)):i!==t&&(u[n]=i)}return u},v.extend({noConflict:function(t){return e.$===v&&(e.$=a),t&&e.jQuery===v&&(e.jQuery=u),v},isReady:!1,readyWait:1,holdReady:function(e){e?v.readyWait++:v.ready(!0)},ready:function(e){if(e===!0?--v.readyWait:v.isReady)return;if(!i.body)return setTimeout(v.ready,1);v.isReady=!0;if(e!==!0&&--v.readyWait>0)return;r.resolveWith(i,[v]),v.fn.trigger&&v(i).trigger("ready").off("ready")},isFunction:function(e){return v.type(e)==="function"},isArray:Array.isArray||function(e){return v.type(e)==="array"},isWindow:function(e){return e!=null&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return e==null?String(e):O[h.call(e)]||"object"},isPlainObject:function(e){if(!e||v.type(e)!=="object"||e.nodeType||v.isWindow(e))return!1;try{if(e.constructor&&!p.call(e,"constructor")&&!p.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(n){return!1}var r;for(r in e);return r===t||p.call(e,r)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw new Error(e)},parseHTML:function(e,t,n){var r;return!e||typeof e!="string"?null:(typeof t=="boolean"&&(n=t,t=0),t=t||i,(r=E.exec(e))?[t.createElement(r[1])]:(r=v.buildFragment([e],t,n?null:[]),v.merge([],(r.cacheable?v.clone(r.fragment):r.fragment).childNodes)))},parseJSON:function(t){if(!t||typeof t!="string")return null;t=v.trim(t);if(e.JSON&&e.JSON.parse)return e.JSON.parse(t);if(S.test(t.replace(T,"@").replace(N,"]").replace(x,"")))return(new Function("return "+t))();v.error("Invalid JSON: "+t)},parseXML:function(n){var r,i;if(!n||typeof n!="string")return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,"text/xml")):(r=new ActiveXObject("Microsoft.XMLDOM"),r.async="false",r.loadXML(n))}catch(s){r=t}return(!r||!r.documentElement||r.getElementsByTagName("parsererror").length)&&v.error("Invalid XML: "+n),r},noop:function(){},globalEval:function(t){t&&g.test(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(C,"ms-").replace(k,L)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,n,r){var i,s=0,o=e.length,u=o===t||v.isFunction(e);if(r){if(u){for(i in e)if(n.apply(e[i],r)===!1)break}else for(;s<o;)if(n.apply(e[s++],r)===!1)break}else if(u){for(i in e)if(n.call(e[i],i,e[i])===!1)break}else for(;s<o;)if(n.call(e[s],s,e[s++])===!1)break;return e},trim:d&&!d.call("\ufeff\u00a0")?function(e){return e==null?"":d.call(e)}:function(e){return e==null?"":(e+"").replace(b,"")},makeArray:function(e,t){var n,r=t||[];return e!=null&&(n=v.type(e),e.length==null||n==="string"||n==="function"||n==="regexp"||v.isWindow(e)?f.call(r,e):v.merge(r,e)),r},inArray:function(e,t,n){var r;if(t){if(c)return c.call(t,e,n);r=t.length,n=n?n<0?Math.max(0,r+n):n:0;for(;n<r;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,s=0;if(typeof r=="number")for(;s<r;s++)e[i++]=n[s];else while(n[s]!==t)e[i++]=n[s++];return e.length=i,e},grep:function(e,t,n){var r,i=[],s=0,o=e.length;n=!!n;for(;s<o;s++)r=!!t(e[s],s),n!==r&&i.push(e[s]);return i},map:function(e,n,r){var i,s,o=[],u=0,a=e.length,f=e instanceof v||a!==t&&typeof a=="number"&&(a>0&&e[0]&&e[a-1]||a===0||v.isArray(e));if(f)for(;u<a;u++)i=n(e[u],u,r),i!=null&&(o[o.length]=i);else for(s in e)i=n(e[s],s,r),i!=null&&(o[o.length]=i);return o.concat.apply([],o)},guid:1,proxy:function(e,n){var r,i,s;return typeof n=="string"&&(r=e[n],n=e,e=r),v.isFunction(e)?(i=l.call(arguments,2),s=function(){return e.apply(n,i.concat(l.call(arguments)))},s.guid=e.guid=e.guid||v.guid++,s):t},access:function(e,n,r,i,s,o,u){var a,f=r==null,l=0,c=e.length;if(r&&typeof r=="object"){for(l in r)v.access(e,n,l,r[l],1,o,i);s=1}else if(i!==t){a=u===t&&v.isFunction(i),f&&(a?(a=n,n=function(e,t,n){return a.call(v(e),n)}):(n.call(e,i),n=null));if(n)for(;l<c;l++)n(e[l],r,a?i.call(e[l],l,n(e[l],r)):i,u);s=1}return s?e:f?n.call(e):c?n(e[0],r):o},now:function(){return(new Date).getTime()}}),v.ready.promise=function(t){if(!r){r=v.Deferred();if(i.readyState==="complete")setTimeout(v.ready,1);else if(i.addEventListener)i.addEventListener("DOMContentLoaded",A,!1),e.addEventListener("load",v.ready,!1);else{i.attachEvent("onreadystatechange",A),e.attachEvent("onload",v.ready);var n=!1;try{n=e.frameElement==null&&i.documentElement}catch(s){}n&&n.doScroll&&function o(){if(!v.isReady){try{n.doScroll("left")}catch(e){return setTimeout(o,50)}v.ready()}}()}}return r.promise(t)},v.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(e,t){O["[object "+t+"]"]=t.toLowerCase()}),n=v(i);var M={};v.Callbacks=function(e){e=typeof e=="string"?M[e]||_(e):v.extend({},e);var n,r,i,s,o,u,a=[],f=!e.once&&[],l=function(t){n=e.memory&&t,r=!0,u=s||0,s=0,o=a.length,i=!0;for(;a&&u<o;u++)if(a[u].apply(t[0],t[1])===!1&&e.stopOnFalse){n=!1;break}i=!1,a&&(f?f.length&&l(f.shift()):n?a=[]:c.disable())},c={add:function(){if(a){var t=a.length;(function r(t){v.each(t,function(t,n){var i=v.type(n);i==="function"?(!e.unique||!c.has(n))&&a.push(n):n&&n.length&&i!=="string"&&r(n)})})(arguments),i?o=a.length:n&&(s=t,l(n))}return this},remove:function(){return a&&v.each(arguments,function(e,t){var n;while((n=v.inArray(t,a,n))>-1)a.splice(n,1),i&&(n<=o&&o--,n<=u&&u--)}),this},has:function(e){return v.inArray(e,a)>-1},empty:function(){return a=[],this},disable:function(){return a=f=n=t,this},disabled:function(){return!a},lock:function(){return f=t,n||c.disable(),this},locked:function(){return!f},fireWith:function(e,t){return t=t||[],t=[e,t.slice?t.slice():t],a&&(!r||f)&&(i?f.push(t):l(t)),this},fire:function(){return c.fireWith(this,arguments),this},fired:function(){return!!r}};return c},v.extend({Deferred:function(e){var t=[["resolve","done",v.Callbacks("once memory"),"resolved"],["reject","fail",v.Callbacks("once memory"),"rejected"],["notify","progress",v.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return v.Deferred(function(n){v.each(t,function(t,r){var s=r[0],o=e[t];i[r[1]](v.isFunction(o)?function(){var e=o.apply(this,arguments);e&&v.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[s+"With"](this===i?n:this,[e])}:n[s])}),e=null}).promise()},promise:function(e){return e!=null?v.extend(e,r):r}},i={};return r.pipe=r.then,v.each(t,function(e,s){var o=s[2],u=s[3];r[s[1]]=o.add,u&&o.add(function(){n=u},t[e^1][2].disable,t[2][2].lock),i[s[0]]=o.fire,i[s[0]+"With"]=o.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=l.call(arguments),r=n.length,i=r!==1||e&&v.isFunction(e.promise)?r:0,s=i===1?e:v.Deferred(),o=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?l.call(arguments):r,n===u?s.notifyWith(t,n):--i||s.resolveWith(t,n)}},u,a,f;if(r>1){u=new Array(r),a=new Array(r),f=new Array(r);for(;t<r;t++)n[t]&&v.isFunction(n[t].promise)?n[t].promise().done(o(t,f,n)).fail(s.reject).progress(o(t,a,u)):--i}return i||s.resolveWith(f,n),s.promise()}}),v.support=function(){var t,n,r,s,o,u,a,f,l,c,h,p=i.createElement("div");p.setAttribute("className","t"),p.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",n=p.getElementsByTagName("*"),r=p.getElementsByTagName("a")[0];if(!n||!r||!n.length)return{};s=i.createElement("select"),o=s.appendChild(i.createElement("option")),u=p.getElementsByTagName("input")[0],r.style.cssText="top:1px;float:left;opacity:.5",t={leadingWhitespace:p.firstChild.nodeType===3,tbody:!p.getElementsByTagName("tbody").length,htmlSerialize:!!p.getElementsByTagName("link").length,style:/top/.test(r.getAttribute("style")),hrefNormalized:r.getAttribute("href")==="/a",opacity:/^0.5/.test(r.style.opacity),cssFloat:!!r.style.cssFloat,checkOn:u.value==="on",optSelected:o.selected,getSetAttribute:p.className!=="t",enctype:!!i.createElement("form").enctype,html5Clone:i.createElement("nav").cloneNode(!0).outerHTML!=="<:nav></:nav>",boxModel:i.compatMode==="CSS1Compat",submitBubbles:!0,changeBubbles:!0,focusinBubbles:!1,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0,boxSizingReliable:!0,pixelPosition:!1},u.checked=!0,t.noCloneChecked=u.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!o.disabled;try{delete p.test}catch(d){t.deleteExpando=!1}!p.addEventListener&&p.attachEvent&&p.fireEvent&&(p.attachEvent("onclick",h=function(){t.noCloneEvent=!1}),p.cloneNode(!0).fireEvent("onclick"),p.detachEvent("onclick",h)),u=i.createElement("input"),u.value="t",u.setAttribute("type","radio"),t.radioValue=u.value==="t",u.setAttribute("checked","checked"),u.setAttribute("name","t"),p.appendChild(u),a=i.createDocumentFragment(),a.appendChild(p.lastChild),t.checkClone=a.cloneNode(!0).cloneNode(!0).lastChild.checked,t.appendChecked=u.checked,a.removeChild(u),a.appendChild(p);if(p.attachEvent)for(l in{submit:!0,change:!0,focusin:!0})f="on"+l,c=f in p,c||(p.setAttribute(f,"return;"),c=typeof p[f]=="function"),t[l+"Bubbles"]=c;return v(function(){var n,r,s,o,u="padding:0;margin:0;border:0;display:block;overflow:hidden;",a=i.getElementsByTagName("body")[0];if(!a)return;n=i.createElement("div"),n.style.cssText="visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px",a.insertBefore(n,a.firstChild),r=i.createElement("div"),n.appendChild(r),r.innerHTML="<table><tr><td></td><td>t</td></tr></table>",s=r.getElementsByTagName("td"),s[0].style.cssText="padding:0;margin:0;border:0;display:none",c=s[0].offsetHeight===0,s[0].style.display="",s[1].style.display="none",t.reliableHiddenOffsets=c&&s[0].offsetHeight===0,r.innerHTML="",r.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",t.boxSizing=r.offsetWidth===4,t.doesNotIncludeMarginInBodyOffset=a.offsetTop!==1,e.getComputedStyle&&(t.pixelPosition=(e.getComputedStyle(r,null)||{}).top!=="1%",t.boxSizingReliable=(e.getComputedStyle(r,null)||{width:"4px"}).width==="4px",o=i.createElement("div"),o.style.cssText=r.style.cssText=u,o.style.marginRight=o.style.width="0",r.style.width="1px",r.appendChild(o),t.reliableMarginRight=!parseFloat((e.getComputedStyle(o,null)||{}).marginRight)),typeof r.style.zoom!="undefined"&&(r.innerHTML="",r.style.cssText=u+"width:1px;padding:1px;display:inline;zoom:1",t.inlineBlockNeedsLayout=r.offsetWidth===3,r.style.display="block",r.style.overflow="visible",r.innerHTML="<div></div>",r.firstChild.style.width="5px",t.shrinkWrapBlocks=r.offsetWidth!==3,n.style.zoom=1),a.removeChild(n),n=r=s=o=null}),a.removeChild(p),n=r=s=o=u=a=p=null,t}();var D=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,P=/([A-Z])/g;v.extend({cache:{},deletedIds:[],uuid:0,expando:"jQuery"+(v.fn.jquery+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(e){return e=e.nodeType?v.cache[e[v.expando]]:e[v.expando],!!e&&!B(e)},data:function(e,n,r,i){if(!v.acceptData(e))return;var s,o,u=v.expando,a=typeof n=="string",f=e.nodeType,l=f?v.cache:e,c=f?e[u]:e[u]&&u;if((!c||!l[c]||!i&&!l[c].data)&&a&&r===t)return;c||(f?e[u]=c=v.deletedIds.pop()||v.guid++:c=u),l[c]||(l[c]={},f||(l[c].toJSON=v.noop));if(typeof n=="object"||typeof n=="function")i?l[c]=v.extend(l[c],n):l[c].data=v.extend(l[c].data,n);return s=l[c],i||(s.data||(s.data={}),s=s.data),r!==t&&(s[v.camelCase(n)]=r),a?(o=s[n],o==null&&(o=s[v.camelCase(n)])):o=s,o},removeData:function(e,t,n){if(!v.acceptData(e))return;var r,i,s,o=e.nodeType,u=o?v.cache:e,a=o?e[v.expando]:v.expando;if(!u[a])return;if(t){r=n?u[a]:u[a].data;if(r){v.isArray(t)||(t in r?t=[t]:(t=v.camelCase(t),t in r?t=[t]:t=t.split(" ")));for(i=0,s=t.length;i<s;i++)delete r[t[i]];if(!(n?B:v.isEmptyObject)(r))return}}if(!n){delete u[a].data;if(!B(u[a]))return}o?v.cleanData([e],!0):v.support.deleteExpando||u!=u.window?delete u[a]:u[a]=null},_data:function(e,t,n){return v.data(e,t,n,!0)},acceptData:function(e){var t=e.nodeName&&v.noData[e.nodeName.toLowerCase()];return!t||t!==!0&&e.getAttribute("classid")===t}}),v.fn.extend({data:function(e,n){var r,i,s,o,u,a=this[0],f=0,l=null;if(e===t){if(this.length){l=v.data(a);if(a.nodeType===1&&!v._data(a,"parsedAttrs")){s=a.attributes;for(u=s.length;f<u;f++)o=s[f].name,o.indexOf("data-")||(o=v.camelCase(o.substring(5)),H(a,o,l[o]));v._data(a,"parsedAttrs",!0)}}return l}return typeof e=="object"?this.each(function(){v.data(this,e)}):(r=e.split(".",2),r[1]=r[1]?"."+r[1]:"",i=r[1]+"!",v.access(this,function(n){if(n===t)return l=this.triggerHandler("getData"+i,[r[0]]),l===t&&a&&(l=v.data(a,e),l=H(a,e,l)),l===t&&r[1]?this.data(r[0]):l;r[1]=n,this.each(function(){var t=v(this);t.triggerHandler("setData"+i,r),v.data(this,e,n),t.triggerHandler("changeData"+i,r)})},null,n,arguments.length>1,null,!1))},removeData:function(e){return this.each(function(){v.removeData(this,e)})}}),v.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=v._data(e,t),n&&(!r||v.isArray(n)?r=v._data(e,t,v.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=v.queue(e,t),r=n.length,i=n.shift(),s=v._queueHooks(e,t),o=function(){v.dequeue(e,t)};i==="inprogress"&&(i=n.shift(),r--),i&&(t==="fx"&&n.unshift("inprogress"),delete s.stop,i.call(e,o,s)),!r&&s&&s.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return v._data(e,n)||v._data(e,n,{empty:v.Callbacks("once memory").add(function(){v.removeData(e,t+"queue",!0),v.removeData(e,n,!0)})})}}),v.fn.extend({queue:function(e,n){var r=2;return typeof e!="string"&&(n=e,e="fx",r--),arguments.length<r?v.queue(this[0],e):n===t?this:this.each(function(){var t=v.queue(this,e,n);v._queueHooks(this,e),e==="fx"&&t[0]!=="inprogress"&&v.dequeue(this,e)})},dequeue:function(e){return this.each(function(){v.dequeue(this,e)})},delay:function(e,t){return e=v.fx?v.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var r,i=1,s=v.Deferred(),o=this,u=this.length,a=function(){--i||s.resolveWith(o,[o])};typeof e!="string"&&(n=e,e=t),e=e||"fx";while(u--)r=v._data(o[u],e+"queueHooks"),r&&r.empty&&(i++,r.empty.add(a));return a(),s.promise(n)}});var j,F,I,q=/[\t\r\n]/g,R=/\r/g,U=/^(?:button|input)$/i,z=/^(?:button|input|object|select|textarea)$/i,W=/^a(?:rea|)$/i,X=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,V=v.support.getSetAttribute;v.fn.extend({attr:function(e,t){return v.access(this,v.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){v.removeAttr(this,e)})},prop:function(e,t){return v.access(this,v.prop,e,t,arguments.length>1)},removeProp:function(e){return e=v.propFix[e]||e,this.each(function(){try{this[e]=t,delete this[e]}catch(n){}})},addClass:function(e){var t,n,r,i,s,o,u;if(v.isFunction(e))return this.each(function(t){v(this).addClass(e.call(this,t,this.className))});if(e&&typeof e=="string"){t=e.split(y);for(n=0,r=this.length;n<r;n++){i=this[n];if(i.nodeType===1)if(!i.className&&t.length===1)i.className=e;else{s=" "+i.className+" ";for(o=0,u=t.length;o<u;o++)s.indexOf(" "+t[o]+" ")<0&&(s+=t[o]+" ");i.className=v.trim(s)}}}return this},removeClass:function(e){var n,r,i,s,o,u,a;if(v.isFunction(e))return this.each(function(t){v(this).removeClass(e.call(this,t,this.className))});if(e&&typeof e=="string"||e===t){n=(e||"").split(y);for(u=0,a=this.length;u<a;u++){i=this[u];if(i.nodeType===1&&i.className){r=(" "+i.className+" ").replace(q," ");for(s=0,o=n.length;s<o;s++)while(r.indexOf(" "+n[s]+" ")>=0)r=r.replace(" "+n[s]+" "," ");i.className=e?v.trim(r):""}}}return this},toggleClass:function(e,t){var n=typeof e,r=typeof t=="boolean";return v.isFunction(e)?this.each(function(n){v(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if(n==="string"){var i,s=0,o=v(this),u=t,a=e.split(y);while(i=a[s++])u=r?u:!o.hasClass(i),o[u?"addClass":"removeClass"](i)}else if(n==="undefined"||n==="boolean")this.className&&v._data(this,"__className__",this.className),this.className=this.className||e===!1?"":v._data(this,"__className__")||""})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;n<r;n++)if(this[n].nodeType===1&&(" "+this[n].className+" ").replace(q," ").indexOf(t)>=0)return!0;return!1},val:function(e){var n,r,i,s=this[0];if(!arguments.length){if(s)return n=v.valHooks[s.type]||v.valHooks[s.nodeName.toLowerCase()],n&&"get"in n&&(r=n.get(s,"value"))!==t?r:(r=s.value,typeof r=="string"?r.replace(R,""):r==null?"":r);return}return i=v.isFunction(e),this.each(function(r){var s,o=v(this);if(this.nodeType!==1)return;i?s=e.call(this,r,o.val()):s=e,s==null?s="":typeof s=="number"?s+="":v.isArray(s)&&(s=v.map(s,function(e){return e==null?"":e+""})),n=v.valHooks[this.type]||v.valHooks[this.nodeName.toLowerCase()];if(!n||!("set"in n)||n.set(this,s,"value")===t)this.value=s})}}),v.extend({valHooks:{option:{get:function(e){var t=e.attributes.value;return!t||t.specified?e.value:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,s=e.type==="select-one"||i<0,o=s?null:[],u=s?i+1:r.length,a=i<0?u:s?i:0;for(;a<u;a++){n=r[a];if((n.selected||a===i)&&(v.support.optDisabled?!n.disabled:n.getAttribute("disabled")===null)&&(!n.parentNode.disabled||!v.nodeName(n.parentNode,"optgroup"))){t=v(n).val();if(s)return t;o.push(t)}}return o},set:function(e,t){var n=v.makeArray(t);return v(e).find("option").each(function(){this.selected=v.inArray(v(this).val(),n)>=0}),n.length||(e.selectedIndex=-1),n}}},attrFn:{},attr:function(e,n,r,i){var s,o,u,a=e.nodeType;if(!e||a===3||a===8||a===2)return;if(i&&v.isFunction(v.fn[n]))return v(e)[n](r);if(typeof e.getAttribute=="undefined")return v.prop(e,n,r);u=a!==1||!v.isXMLDoc(e),u&&(n=n.toLowerCase(),o=v.attrHooks[n]||(X.test(n)?F:j));if(r!==t){if(r===null){v.removeAttr(e,n);return}return o&&"set"in o&&u&&(s=o.set(e,r,n))!==t?s:(e.setAttribute(n,r+""),r)}return o&&"get"in o&&u&&(s=o.get(e,n))!==null?s:(s=e.getAttribute(n),s===null?t:s)},removeAttr:function(e,t){var n,r,i,s,o=0;if(t&&e.nodeType===1){r=t.split(y);for(;o<r.length;o++)i=r[o],i&&(n=v.propFix[i]||i,s=X.test(i),s||v.attr(e,i,""),e.removeAttribute(V?i:n),s&&n in e&&(e[n]=!1))}},attrHooks:{type:{set:function(e,t){if(U.test(e.nodeName)&&e.parentNode)v.error("type property can't be changed");else if(!v.support.radioValue&&t==="radio"&&v.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}},value:{get:function(e,t){return j&&v.nodeName(e,"button")?j.get(e,t):t in e?e.value:null},set:function(e,t,n){if(j&&v.nodeName(e,"button"))return j.set(e,t,n);e.value=t}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(e,n,r){var i,s,o,u=e.nodeType;if(!e||u===3||u===8||u===2)return;return o=u!==1||!v.isXMLDoc(e),o&&(n=v.propFix[n]||n,s=v.propHooks[n]),r!==t?s&&"set"in s&&(i=s.set(e,r,n))!==t?i:e[n]=r:s&&"get"in s&&(i=s.get(e,n))!==null?i:e[n]},propHooks:{tabIndex:{get:function(e){var n=e.getAttributeNode("tabindex");return n&&n.specified?parseInt(n.value,10):z.test(e.nodeName)||W.test(e.nodeName)&&e.href?0:t}}}}),F={get:function(e,n){var r,i=v.prop(e,n);return i===!0||typeof i!="boolean"&&(r=e.getAttributeNode(n))&&r.nodeValue!==!1?n.toLowerCase():t},set:function(e,t,n){var r;return t===!1?v.removeAttr(e,n):(r=v.propFix[n]||n,r in e&&(e[r]=!0),e.setAttribute(n,n.toLowerCase())),n}},V||(I={name:!0,id:!0,coords:!0},j=v.valHooks.button={get:function(e,n){var r;return r=e.getAttributeNode(n),r&&(I[n]?r.value!=="":r.specified)?r.value:t},set:function(e,t,n){var r=e.getAttributeNode(n);return r||(r=i.createAttribute(n),e.setAttributeNode(r)),r.value=t+""}},v.each(["width","height"],function(e,t){v.attrHooks[t]=v.extend(v.attrHooks[t],{set:function(e,n){if(n==="")return e.setAttribute(t,"auto"),n}})}),v.attrHooks.contenteditable={get:j.get,set:function(e,t,n){t===""&&(t="false"),j.set(e,t,n)}}),v.support.hrefNormalized||v.each(["href","src","width","height"],function(e,n){v.attrHooks[n]=v.extend(v.attrHooks[n],{get:function(e){var r=e.getAttribute(n,2);return r===null?t:r}})}),v.support.style||(v.attrHooks.style={get:function(e){return e.style.cssText.toLowerCase()||t},set:function(e,t){return e.style.cssText=t+""}}),v.support.optSelected||(v.propHooks.selected=v.extend(v.propHooks.selected,{get:function(e){var t=e.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}})),v.support.enctype||(v.propFix.enctype="encoding"),v.support.checkOn||v.each(["radio","checkbox"],function(){v.valHooks[this]={get:function(e){return e.getAttribute("value")===null?"on":e.value}}}),v.each(["radio","checkbox"],function(){v.valHooks[this]=v.extend(v.valHooks[this],{set:function(e,t){if(v.isArray(t))return e.checked=v.inArray(v(e).val(),t)>=0}})});var $=/^(?:textarea|input|select)$/i,J=/^([^\.]*|)(?:\.(.+)|)$/,K=/(?:^|\s)hover(\.\S+|)\b/,Q=/^key/,G=/^(?:mouse|contextmenu)|click/,Y=/^(?:focusinfocus|focusoutblur)$/,Z=function(e){return v.event.special.hover?e:e.replace(K,"mouseenter$1 mouseleave$1")};v.event={add:function(e,n,r,i,s){var o,u,a,f,l,c,h,p,d,m,g;if(e.nodeType===3||e.nodeType===8||!n||!r||!(o=v._data(e)))return;r.handler&&(d=r,r=d.handler,s=d.selector),r.guid||(r.guid=v.guid++),a=o.events,a||(o.events=a={}),u=o.handle,u||(o.handle=u=function(e){return typeof v=="undefined"||!!e&&v.event.triggered===e.type?t:v.event.dispatch.apply(u.elem,arguments)},u.elem=e),n=v.trim(Z(n)).split(" ");for(f=0;f<n.length;f++){l=J.exec(n[f])||[],c=l[1],h=(l[2]||"").split(".").sort(),g=v.event.special[c]||{},c=(s?g.delegateType:g.bindType)||c,g=v.event.special[c]||{},p=v.extend({type:c,origType:l[1],data:i,handler:r,guid:r.guid,selector:s,needsContext:s&&v.expr.match.needsContext.test(s),namespace:h.join(".")},d),m=a[c];if(!m){m=a[c]=[],m.delegateCount=0;if(!g.setup||g.setup.call(e,i,h,u)===!1)e.addEventListener?e.addEventListener(c,u,!1):e.attachEvent&&e.attachEvent("on"+c,u)}g.add&&(g.add.call(e,p),p.handler.guid||(p.handler.guid=r.guid)),s?m.splice(m.delegateCount++,0,p):m.push(p),v.event.global[c]=!0}e=null},global:{},remove:function(e,t,n,r,i){var s,o,u,a,f,l,c,h,p,d,m,g=v.hasData(e)&&v._data(e);if(!g||!(h=g.events))return;t=v.trim(Z(t||"")).split(" ");for(s=0;s<t.length;s++){o=J.exec(t[s])||[],u=a=o[1],f=o[2];if(!u){for(u in h)v.event.remove(e,u+t[s],n,r,!0);continue}p=v.event.special[u]||{},u=(r?p.delegateType:p.bindType)||u,d=h[u]||[],l=d.length,f=f?new RegExp("(^|\\.)"+f.split(".").sort().join("\\.(?:.*\\.|)")+"(\\.|$)"):null;for(c=0;c<d.length;c++)m=d[c],(i||a===m.origType)&&(!n||n.guid===m.guid)&&(!f||f.test(m.namespace))&&(!r||r===m.selector||r==="**"&&m.selector)&&(d.splice(c--,1),m.selector&&d.delegateCount--,p.remove&&p.remove.call(e,m));d.length===0&&l!==d.length&&((!p.teardown||p.teardown.call(e,f,g.handle)===!1)&&v.removeEvent(e,u,g.handle),delete h[u])}v.isEmptyObject(h)&&(delete g.handle,v.removeData(e,"events",!0))},customEvent:{getData:!0,setData:!0,changeData:!0},trigger:function(n,r,s,o){if(!s||s.nodeType!==3&&s.nodeType!==8){var u,a,f,l,c,h,p,d,m,g,y=n.type||n,b=[];if(Y.test(y+v.event.triggered))return;y.indexOf("!")>=0&&(y=y.slice(0,-1),a=!0),y.indexOf(".")>=0&&(b=y.split("."),y=b.shift(),b.sort());if((!s||v.event.customEvent[y])&&!v.event.global[y])return;n=typeof n=="object"?n[v.expando]?n:new v.Event(y,n):new v.Event(y),n.type=y,n.isTrigger=!0,n.exclusive=a,n.namespace=b.join("."),n.namespace_re=n.namespace?new RegExp("(^|\\.)"+b.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,h=y.indexOf(":")<0?"on"+y:"";if(!s){u=v.cache;for(f in u)u[f].events&&u[f].events[y]&&v.event.trigger(n,r,u[f].handle.elem,!0);return}n.result=t,n.target||(n.target=s),r=r!=null?v.makeArray(r):[],r.unshift(n),p=v.event.special[y]||{};if(p.trigger&&p.trigger.apply(s,r)===!1)return;m=[[s,p.bindType||y]];if(!o&&!p.noBubble&&!v.isWindow(s)){g=p.delegateType||y,l=Y.test(g+y)?s:s.parentNode;for(c=s;l;l=l.parentNode)m.push([l,g]),c=l;c===(s.ownerDocument||i)&&m.push([c.defaultView||c.parentWindow||e,g])}for(f=0;f<m.length&&!n.isPropagationStopped();f++)l=m[f][0],n.type=m[f][1],d=(v._data(l,"events")||{})[n.type]&&v._data(l,"handle"),d&&d.apply(l,r),d=h&&l[h],d&&v.acceptData(l)&&d.apply&&d.apply(l,r)===!1&&n.preventDefault();return n.type=y,!o&&!n.isDefaultPrevented()&&(!p._default||p._default.apply(s.ownerDocument,r)===!1)&&(y!=="click"||!v.nodeName(s,"a"))&&v.acceptData(s)&&h&&s[y]&&(y!=="focus"&&y!=="blur"||n.target.offsetWidth!==0)&&!v.isWindow(s)&&(c=s[h],c&&(s[h]=null),v.event.triggered=y,s[y](),v.event.triggered=t,c&&(s[h]=c)),n.result}return},dispatch:function(n){n=v.event.fix(n||e.event);var r,i,s,o,u,a,f,c,h,p,d=(v._data(this,"events")||{})[n.type]||[],m=d.delegateCount,g=l.call(arguments),y=!n.exclusive&&!n.namespace,b=v.event.special[n.type]||{},w=[];g[0]=n,n.delegateTarget=this;if(b.preDispatch&&b.preDispatch.call(this,n)===!1)return;if(m&&(!n.button||n.type!=="click"))for(s=n.target;s!=this;s=s.parentNode||this)if(s.disabled!==!0||n.type!=="click"){u={},f=[];for(r=0;r<m;r++)c=d[r],h=c.selector,u[h]===t&&(u[h]=c.needsContext?v(h,this).index(s)>=0:v.find(h,this,null,[s]).length),u[h]&&f.push(c);f.length&&w.push({elem:s,matches:f})}d.length>m&&w.push({elem:this,matches:d.slice(m)});for(r=0;r<w.length&&!n.isPropagationStopped();r++){a=w[r],n.currentTarget=a.elem;for(i=0;i<a.matches.length&&!n.isImmediatePropagationStopped();i++){c=a.matches[i];if(y||!n.namespace&&!c.namespace||n.namespace_re&&n.namespace_re.test(c.namespace))n.data=c.data,n.handleObj=c,o=((v.event.special[c.origType]||{}).handle||c.handler).apply(a.elem,g),o!==t&&(n.result=o,o===!1&&(n.preventDefault(),n.stopPropagation()))}}return b.postDispatch&&b.postDispatch.call(this,n),n.result},props:"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return e.which==null&&(e.which=t.charCode!=null?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,n){var r,s,o,u=n.button,a=n.fromElement;return e.pageX==null&&n.clientX!=null&&(r=e.target.ownerDocument||i,s=r.documentElement,o=r.body,e.pageX=n.clientX+(s&&s.scrollLeft||o&&o.scrollLeft||0)-(s&&s.clientLeft||o&&o.clientLeft||0),e.pageY=n.clientY+(s&&s.scrollTop||o&&o.scrollTop||0)-(s&&s.clientTop||o&&o.clientTop||0)),!e.relatedTarget&&a&&(e.relatedTarget=a===e.target?n.toElement:a),!e.which&&u!==t&&(e.which=u&1?1:u&2?3:u&4?2:0),e}},fix:function(e){if(e[v.expando])return e;var t,n,r=e,s=v.event.fixHooks[e.type]||{},o=s.props?this.props.concat(s.props):this.props;e=v.Event(r);for(t=o.length;t;)n=o[--t],e[n]=r[n];return e.target||(e.target=r.srcElement||i),e.target.nodeType===3&&(e.target=e.target.parentNode),e.metaKey=!!e.metaKey,s.filter?s.filter(e,r):e},special:{load:{noBubble:!0},focus:{delegateType:"focusin"},blur:{delegateType:"focusout"},beforeunload:{setup:function(e,t,n){v.isWindow(this)&&(this.onbeforeunload=n)},teardown:function(e,t){this.onbeforeunload===t&&(this.onbeforeunload=null)}}},simulate:function(e,t,n,r){var i=v.extend(new v.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?v.event.trigger(i,null,t):v.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},v.event.handle=v.event.dispatch,v.removeEvent=i.removeEventListener?function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)}:function(e,t,n){var r="on"+t;e.detachEvent&&(typeof e[r]=="undefined"&&(e[r]=null),e.detachEvent(r,n))},v.Event=function(e,t){if(!(this instanceof v.Event))return new v.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.returnValue===!1||e.getPreventDefault&&e.getPreventDefault()?tt:et):this.type=e,t&&v.extend(this,t),this.timeStamp=e&&e.timeStamp||v.now(),this[v.expando]=!0},v.Event.prototype={preventDefault:function(){this.isDefaultPrevented=tt;var e=this.originalEvent;if(!e)return;e.preventDefault?e.preventDefault():e.returnValue=!1},stopPropagation:function(){this.isPropagationStopped=tt;var e=this.originalEvent;if(!e)return;e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=tt,this.stopPropagation()},isDefaultPrevented:et,isPropagationStopped:et,isImmediatePropagationStopped:et},v.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){v.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,s=e.handleObj,o=s.selector;if(!i||i!==r&&!v.contains(r,i))e.type=s.origType,n=s.handler.apply(this,arguments),e.type=t;return n}}}),v.support.submitBubbles||(v.event.special.submit={setup:function(){if(v.nodeName(this,"form"))return!1;v.event.add(this,"click._submit keypress._submit",function(e){var n=e.target,r=v.nodeName(n,"input")||v.nodeName(n,"button")?n.form:t;r&&!v._data(r,"_submit_attached")&&(v.event.add(r,"submit._submit",function(e){e._submit_bubble=!0}),v._data(r,"_submit_attached",!0))})},postDispatch:function(e){e._submit_bubble&&(delete e._submit_bubble,this.parentNode&&!e.isTrigger&&v.event.simulate("submit",this.parentNode,e,!0))},teardown:function(){if(v.nodeName(this,"form"))return!1;v.event.remove(this,"._submit")}}),v.support.changeBubbles||(v.event.special.change={setup:function(){if($.test(this.nodeName)){if(this.type==="checkbox"||this.type==="radio")v.event.add(this,"propertychange._change",function(e){e.originalEvent.propertyName==="checked"&&(this._just_changed=!0)}),v.event.add(this,"click._change",function(e){this._just_changed&&!e.isTrigger&&(this._just_changed=!1),v.event.simulate("change",this,e,!0)});return!1}v.event.add(this,"beforeactivate._change",function(e){var t=e.target;$.test(t.nodeName)&&!v._data(t,"_change_attached")&&(v.event.add(t,"change._change",function(e){this.parentNode&&!e.isSimulated&&!e.isTrigger&&v.event.simulate("change",this.parentNode,e,!0)}),v._data(t,"_change_attached",!0))})},handle:function(e){var t=e.target;if(this!==t||e.isSimulated||e.isTrigger||t.type!=="radio"&&t.type!=="checkbox")return e.handleObj.handler.apply(this,arguments)},teardown:function(){return v.event.remove(this,"._change"),!$.test(this.nodeName)}}),v.support.focusinBubbles||v.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){v.event.simulate(t,e.target,v.event.fix(e),!0)};v.event.special[t]={setup:function(){n++===0&&i.addEventListener(e,r,!0)},teardown:function(){--n===0&&i.removeEventListener(e,r,!0)}}}),v.fn.extend({on:function(e,n,r,i,s){var o,u;if(typeof e=="object"){typeof n!="string"&&(r=r||n,n=t);for(u in e)this.on(u,n,r,e[u],s);return this}r==null&&i==null?(i=n,r=n=t):i==null&&(typeof n=="string"?(i=r,r=t):(i=r,r=n,n=t));if(i===!1)i=et;else if(!i)return this;return s===1&&(o=i,i=function(e){return v().off(e),o.apply(this,arguments)},i.guid=o.guid||(o.guid=v.guid++)),this.each(function(){v.event.add(this,e,i,r,n)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,n,r){var i,s;if(e&&e.preventDefault&&e.handleObj)return i=e.handleObj,v(e.delegateTarget).off(i.namespace?i.origType+"."+i.namespace:i.origType,i.selector,i.handler),this;if(typeof e=="object"){for(s in e)this.off(s,n,e[s]);return this}if(n===!1||typeof n=="function")r=n,n=t;return r===!1&&(r=et),this.each(function(){v.event.remove(this,e,r,n)})},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},live:function(e,t,n){return v(this.context).on(e,this.selector,t,n),this},die:function(e,t){return v(this.context).off(e,this.selector||"**",t),this},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return arguments.length===1?this.off(e,"**"):this.off(t,e||"**",n)},trigger:function(e,t){return this.each(function(){v.event.trigger(e,t,this)})},triggerHandler:function(e,t){if(this[0])return v.event.trigger(e,t,this[0],!0)},toggle:function(e){var t=arguments,n=e.guid||v.guid++,r=0,i=function(n){var i=(v._data(this,"lastToggle"+e.guid)||0)%r;return v._data(this,"lastToggle"+e.guid,i+1),n.preventDefault(),t[i].apply(this,arguments)||!1};i.guid=n;while(r<t.length)t[r++].guid=n;return this.click(i)},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),v.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){v.fn[t]=function(e,n){return n==null&&(n=e,e=null),arguments.length>0?this.on(t,null,e,n):this.trigger(t)},Q.test(t)&&(v.event.fixHooks[t]=v.event.keyHooks),G.test(t)&&(v.event.fixHooks[t]=v.event.mouseHooks)}),function(e,t){function nt(e,t,n,r){n=n||[],t=t||g;var i,s,a,f,l=t.nodeType;if(!e||typeof e!="string")return n;if(l!==1&&l!==9)return[];a=o(t);if(!a&&!r)if(i=R.exec(e))if(f=i[1]){if(l===9){s=t.getElementById(f);if(!s||!s.parentNode)return n;if(s.id===f)return n.push(s),n}else if(t.ownerDocument&&(s=t.ownerDocument.getElementById(f))&&u(t,s)&&s.id===f)return n.push(s),n}else{if(i[2])return S.apply(n,x.call(t.getElementsByTagName(e),0)),n;if((f=i[3])&&Z&&t.getElementsByClassName)return S.apply(n,x.call(t.getElementsByClassName(f),0)),n}return vt(e.replace(j,"$1"),t,n,r,a)}function rt(e){return function(t){var n=t.nodeName.toLowerCase();return n==="input"&&t.type===e}}function it(e){return function(t){var n=t.nodeName.toLowerCase();return(n==="input"||n==="button")&&t.type===e}}function st(e){return N(function(t){return t=+t,N(function(n,r){var i,s=e([],n.length,t),o=s.length;while(o--)n[i=s[o]]&&(n[i]=!(r[i]=n[i]))})})}function ot(e,t,n){if(e===t)return n;var r=e.nextSibling;while(r){if(r===t)return-1;r=r.nextSibling}return 1}function ut(e,t){var n,r,s,o,u,a,f,l=L[d][e+" "];if(l)return t?0:l.slice(0);u=e,a=[],f=i.preFilter;while(u){if(!n||(r=F.exec(u)))r&&(u=u.slice(r[0].length)||u),a.push(s=[]);n=!1;if(r=I.exec(u))s.push(n=new m(r.shift())),u=u.slice(n.length),n.type=r[0].replace(j," ");for(o in i.filter)(r=J[o].exec(u))&&(!f[o]||(r=f[o](r)))&&(s.push(n=new m(r.shift())),u=u.slice(n.length),n.type=o,n.matches=r);if(!n)break}return t?u.length:u?nt.error(e):L(e,a).slice(0)}function at(e,t,r){var i=t.dir,s=r&&t.dir==="parentNode",o=w++;return t.first?function(t,n,r){while(t=t[i])if(s||t.nodeType===1)return e(t,n,r)}:function(t,r,u){if(!u){var a,f=b+" "+o+" ",l=f+n;while(t=t[i])if(s||t.nodeType===1){if((a=t[d])===l)return t.sizset;if(typeof a=="string"&&a.indexOf(f)===0){if(t.sizset)return t}else{t[d]=l;if(e(t,r,u))return t.sizset=!0,t;t.sizset=!1}}}else while(t=t[i])if(s||t.nodeType===1)if(e(t,r,u))return t}}function ft(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function lt(e,t,n,r,i){var s,o=[],u=0,a=e.length,f=t!=null;for(;u<a;u++)if(s=e[u])if(!n||n(s,r,i))o.push(s),f&&t.push(u);return o}function ct(e,t,n,r,i,s){return r&&!r[d]&&(r=ct(r)),i&&!i[d]&&(i=ct(i,s)),N(function(s,o,u,a){var f,l,c,h=[],p=[],d=o.length,v=s||dt(t||"*",u.nodeType?[u]:u,[]),m=e&&(s||!t)?lt(v,h,e,u,a):v,g=n?i||(s?e:d||r)?[]:o:m;n&&n(m,g,u,a);if(r){f=lt(g,p),r(f,[],u,a),l=f.length;while(l--)if(c=f[l])g[p[l]]=!(m[p[l]]=c)}if(s){if(i||e){if(i){f=[],l=g.length;while(l--)(c=g[l])&&f.push(m[l]=c);i(null,g=[],f,a)}l=g.length;while(l--)(c=g[l])&&(f=i?T.call(s,c):h[l])>-1&&(s[f]=!(o[f]=c))}}else g=lt(g===o?g.splice(d,g.length):g),i?i(null,o,g,a):S.apply(o,g)})}function ht(e){var t,n,r,s=e.length,o=i.relative[e[0].type],u=o||i.relative[" "],a=o?1:0,f=at(function(e){return e===t},u,!0),l=at(function(e){return T.call(t,e)>-1},u,!0),h=[function(e,n,r){return!o&&(r||n!==c)||((t=n).nodeType?f(e,n,r):l(e,n,r))}];for(;a<s;a++)if(n=i.relative[e[a].type])h=[at(ft(h),n)];else{n=i.filter[e[a].type].apply(null,e[a].matches);if(n[d]){r=++a;for(;r<s;r++)if(i.relative[e[r].type])break;return ct(a>1&&ft(h),a>1&&e.slice(0,a-1).join("").replace(j,"$1"),n,a<r&&ht(e.slice(a,r)),r<s&&ht(e=e.slice(r)),r<s&&e.join(""))}h.push(n)}return ft(h)}function pt(e,t){var r=t.length>0,s=e.length>0,o=function(u,a,f,l,h){var p,d,v,m=[],y=0,w="0",x=u&&[],T=h!=null,N=c,C=u||s&&i.find.TAG("*",h&&a.parentNode||a),k=b+=N==null?1:Math.E;T&&(c=a!==g&&a,n=o.el);for(;(p=C[w])!=null;w++){if(s&&p){for(d=0;v=e[d];d++)if(v(p,a,f)){l.push(p);break}T&&(b=k,n=++o.el)}r&&((p=!v&&p)&&y--,u&&x.push(p))}y+=w;if(r&&w!==y){for(d=0;v=t[d];d++)v(x,m,a,f);if(u){if(y>0)while(w--)!x[w]&&!m[w]&&(m[w]=E.call(l));m=lt(m)}S.apply(l,m),T&&!u&&m.length>0&&y+t.length>1&&nt.uniqueSort(l)}return T&&(b=k,c=N),x};return o.el=0,r?N(o):o}function dt(e,t,n){var r=0,i=t.length;for(;r<i;r++)nt(e,t[r],n);return n}function vt(e,t,n,r,s){var o,u,f,l,c,h=ut(e),p=h.length;if(!r&&h.length===1){u=h[0]=h[0].slice(0);if(u.length>2&&(f=u[0]).type==="ID"&&t.nodeType===9&&!s&&i.relative[u[1].type]){t=i.find.ID(f.matches[0].replace($,""),t,s)[0];if(!t)return n;e=e.slice(u.shift().length)}for(o=J.POS.test(e)?-1:u.length-1;o>=0;o--){f=u[o];if(i.relative[l=f.type])break;if(c=i.find[l])if(r=c(f.matches[0].replace($,""),z.test(u[0].type)&&t.parentNode||t,s)){u.splice(o,1),e=r.length&&u.join("");if(!e)return S.apply(n,x.call(r,0)),n;break}}}return a(e,h)(r,t,s,n,z.test(e)),n}function mt(){}var n,r,i,s,o,u,a,f,l,c,h=!0,p="undefined",d=("sizcache"+Math.random()).replace(".",""),m=String,g=e.document,y=g.documentElement,b=0,w=0,E=[].pop,S=[].push,x=[].slice,T=[].indexOf||function(e){var t=0,n=this.length;for(;t<n;t++)if(this[t]===e)return t;return-1},N=function(e,t){return e[d]=t==null||t,e},C=function(){var e={},t=[];return N(function(n,r){return t.push(n)>i.cacheLength&&delete e[t.shift()],e[n+" "]=r},e)},k=C(),L=C(),A=C(),O="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",_=M.replace("w","w#"),D="([*^$|!~]?=)",P="\\["+O+"*("+M+")"+O+"*(?:"+D+O+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+_+")|)|)"+O+"*\\]",H=":("+M+")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:"+P+")|[^:]|\\\\.)*|.*))\\)|)",B=":(even|odd|eq|gt|lt|nth|first|last)(?:\\("+O+"*((?:-\\d)?\\d*)"+O+"*\\)|)(?=[^-]|$)",j=new RegExp("^"+O+"+|((?:^|[^\\\\])(?:\\\\.)*)"+O+"+$","g"),F=new RegExp("^"+O+"*,"+O+"*"),I=new RegExp("^"+O+"*([\\x20\\t\\r\\n\\f>+~])"+O+"*"),q=new RegExp(H),R=/^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,U=/^:not/,z=/[\x20\t\r\n\f]*[+~]/,W=/:not\($/,X=/h\d/i,V=/input|select|textarea|button/i,$=/\\(?!\\)/g,J={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),NAME:new RegExp("^\\[name=['\"]?("+M+")['\"]?\\]"),TAG:new RegExp("^("+M.replace("w","w*")+")"),ATTR:new RegExp("^"+P),PSEUDO:new RegExp("^"+H),POS:new RegExp(B,"i"),CHILD:new RegExp("^:(only|nth|first|last)-child(?:\\("+O+"*(even|odd|(([+-]|)(\\d*)n|)"+O+"*(?:([+-]|)"+O+"*(\\d+)|))"+O+"*\\)|)","i"),needsContext:new RegExp("^"+O+"*[>+~]|"+B,"i")},K=function(e){var t=g.createElement("div");try{return e(t)}catch(n){return!1}finally{t=null}},Q=K(function(e){return e.appendChild(g.createComment("")),!e.getElementsByTagName("*").length}),G=K(function(e){return e.innerHTML="<a href='#'></a>",e.firstChild&&typeof e.firstChild.getAttribute!==p&&e.firstChild.getAttribute("href")==="#"}),Y=K(function(e){e.innerHTML="<select></select>";var t=typeof e.lastChild.getAttribute("multiple");return t!=="boolean"&&t!=="string"}),Z=K(function(e){return e.innerHTML="<div class='hidden e'></div><div class='hidden'></div>",!e.getElementsByClassName||!e.getElementsByClassName("e").length?!1:(e.lastChild.className="e",e.getElementsByClassName("e").length===2)}),et=K(function(e){e.id=d+0,e.innerHTML="<a name='"+d+"'></a><div name='"+d+"'></div>",y.insertBefore(e,y.firstChild);var t=g.getElementsByName&&g.getElementsByName(d).length===2+g.getElementsByName(d+0).length;return r=!g.getElementById(d),y.removeChild(e),t});try{x.call(y.childNodes,0)[0].nodeType}catch(tt){x=function(e){var t,n=[];for(;t=this[e];e++)n.push(t);return n}}nt.matches=function(e,t){return nt(e,null,null,t)},nt.matchesSelector=function(e,t){return nt(t,null,null,[e]).length>0},s=nt.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(i===1||i===9||i===11){if(typeof e.textContent=="string")return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=s(e)}else if(i===3||i===4)return e.nodeValue}else for(;t=e[r];r++)n+=s(t);return n},o=nt.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?t.nodeName!=="HTML":!1},u=nt.contains=y.contains?function(e,t){var n=e.nodeType===9?e.documentElement:e,r=t&&t.parentNode;return e===r||!!(r&&r.nodeType===1&&n.contains&&n.contains(r))}:y.compareDocumentPosition?function(e,t){return t&&!!(e.compareDocumentPosition(t)&16)}:function(e,t){while(t=t.parentNode)if(t===e)return!0;return!1},nt.attr=function(e,t){var n,r=o(e);return r||(t=t.toLowerCase()),(n=i.attrHandle[t])?n(e):r||Y?e.getAttribute(t):(n=e.getAttributeNode(t),n?typeof e[t]=="boolean"?e[t]?t:null:n.specified?n.value:null:null)},i=nt.selectors={cacheLength:50,createPseudo:N,match:J,attrHandle:G?{}:{href:function(e){return e.getAttribute("href",2)},type:function(e){return e.getAttribute("type")}},find:{ID:r?function(e,t,n){if(typeof t.getElementById!==p&&!n){var r=t.getElementById(e);return r&&r.parentNode?[r]:[]}}:function(e,n,r){if(typeof n.getElementById!==p&&!r){var i=n.getElementById(e);return i?i.id===e||typeof i.getAttributeNode!==p&&i.getAttributeNode("id").value===e?[i]:t:[]}},TAG:Q?function(e,t){if(typeof t.getElementsByTagName!==p)return t.getElementsByTagName(e)}:function(e,t){var n=t.getElementsByTagName(e);if(e==="*"){var r,i=[],s=0;for(;r=n[s];s++)r.nodeType===1&&i.push(r);return i}return n},NAME:et&&function(e,t){if(typeof t.getElementsByName!==p)return t.getElementsByName(name)},CLASS:Z&&function(e,t,n){if(typeof t.getElementsByClassName!==p&&!n)return t.getElementsByClassName(e)}},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace($,""),e[3]=(e[4]||e[5]||"").replace($,""),e[2]==="~="&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),e[1]==="nth"?(e[2]||nt.error(e[0]),e[3]=+(e[3]?e[4]+(e[5]||1):2*(e[2]==="even"||e[2]==="odd")),e[4]=+(e[6]+e[7]||e[2]==="odd")):e[2]&&nt.error(e[0]),e},PSEUDO:function(e){var t,n;if(J.CHILD.test(e[0]))return null;if(e[3])e[2]=e[3];else if(t=e[4])q.test(t)&&(n=ut(t,!0))&&(n=t.indexOf(")",t.length-n)-t.length)&&(t=t.slice(0,n),e[0]=e[0].slice(0,n)),e[2]=t;return e.slice(0,3)}},filter:{ID:r?function(e){return e=e.replace($,""),function(t){return t.getAttribute("id")===e}}:function(e){return e=e.replace($,""),function(t){var n=typeof t.getAttributeNode!==p&&t.getAttributeNode("id");return n&&n.value===e}},TAG:function(e){return e==="*"?function(){return!0}:(e=e.replace($,"").toLowerCase(),function(t){return t.nodeName&&t.nodeName.toLowerCase()===e})},CLASS:function(e){var t=k[d][e+" "];return t||(t=new RegExp("(^|"+O+")"+e+"("+O+"|$)"))&&k(e,function(e){return t.test(e.className||typeof e.getAttribute!==p&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r,i){var s=nt.attr(r,e);return s==null?t==="!=":t?(s+="",t==="="?s===n:t==="!="?s!==n:t==="^="?n&&s.indexOf(n)===0:t==="*="?n&&s.indexOf(n)>-1:t==="$="?n&&s.substr(s.length-n.length)===n:t==="~="?(" "+s+" ").indexOf(n)>-1:t==="|="?s===n||s.substr(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r){return e==="nth"?function(e){var t,i,s=e.parentNode;if(n===1&&r===0)return!0;if(s){i=0;for(t=s.firstChild;t;t=t.nextSibling)if(t.nodeType===1){i++;if(e===t)break}}return i-=r,i===n||i%n===0&&i/n>=0}:function(t){var n=t;switch(e){case"only":case"first":while(n=n.previousSibling)if(n.nodeType===1)return!1;if(e==="first")return!0;n=t;case"last":while(n=n.nextSibling)if(n.nodeType===1)return!1;return!0}}},PSEUDO:function(e,t){var n,r=i.pseudos[e]||i.setFilters[e.toLowerCase()]||nt.error("unsupported pseudo: "+e);return r[d]?r(t):r.length>1?(n=[e,e,"",t],i.setFilters.hasOwnProperty(e.toLowerCase())?N(function(e,n){var i,s=r(e,t),o=s.length;while(o--)i=T.call(e,s[o]),e[i]=!(n[i]=s[o])}):function(e){return r(e,0,n)}):r}},pseudos:{not:N(function(e){var t=[],n=[],r=a(e.replace(j,"$1"));return r[d]?N(function(e,t,n,i){var s,o=r(e,null,i,[]),u=e.length;while(u--)if(s=o[u])e[u]=!(t[u]=s)}):function(e,i,s){return t[0]=e,r(t,null,s,n),!n.pop()}}),has:N(function(e){return function(t){return nt(e,t).length>0}}),contains:N(function(e){return function(t){return(t.textContent||t.innerText||s(t)).indexOf(e)>-1}}),enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return t==="input"&&!!e.checked||t==="option"&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},parent:function(e){return!i.pseudos.empty(e)},empty:function(e){var t;e=e.firstChild;while(e){if(e.nodeName>"@"||(t=e.nodeType)===3||t===4)return!1;e=e.nextSibling}return!0},header:function(e){return X.test(e.nodeName)},text:function(e){var t,n;return e.nodeName.toLowerCase()==="input"&&(t=e.type)==="text"&&((n=e.getAttribute("type"))==null||n.toLowerCase()===t)},radio:rt("radio"),checkbox:rt("checkbox"),file:rt("file"),password:rt("password"),image:rt("image"),submit:it("submit"),reset:it("reset"),button:function(e){var t=e.nodeName.toLowerCase();return t==="input"&&e.type==="button"||t==="button"},input:function(e){return V.test(e.nodeName)},focus:function(e){var t=e.ownerDocument;return e===t.activeElement&&(!t.hasFocus||t.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},active:function(e){return e===e.ownerDocument.activeElement},first:st(function(){return[0]}),last:st(function(e,t){return[t-1]}),eq:st(function(e,t,n){return[n<0?n+t:n]}),even:st(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:st(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:st(function(e,t,n){for(var r=n<0?n+t:n;--r>=0;)e.push(r);return e}),gt:st(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}},f=y.compareDocumentPosition?function(e,t){return e===t?(l=!0,0):(!e.compareDocumentPosition||!t.compareDocumentPosition?e.compareDocumentPosition:e.compareDocumentPosition(t)&4)?-1:1}:function(e,t){if(e===t)return l=!0,0;if(e.sourceIndex&&t.sourceIndex)return e.sourceIndex-t.sourceIndex;var n,r,i=[],s=[],o=e.parentNode,u=t.parentNode,a=o;if(o===u)return ot(e,t);if(!o)return-1;if(!u)return 1;while(a)i.unshift(a),a=a.parentNode;a=u;while(a)s.unshift(a),a=a.parentNode;n=i.length,r=s.length;for(var f=0;f<n&&f<r;f++)if(i[f]!==s[f])return ot(i[f],s[f]);return f===n?ot(e,s[f],-1):ot(i[f],t,1)},[0,0].sort(f),h=!l,nt.uniqueSort=function(e){var t,n=[],r=1,i=0;l=h,e.sort(f);if(l){for(;t=e[r];r++)t===e[r-1]&&(i=n.push(r));while(i--)e.splice(n[i],1)}return e},nt.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},a=nt.compile=function(e,t){var n,r=[],i=[],s=A[d][e+" "];if(!s){t||(t=ut(e)),n=t.length;while(n--)s=ht(t[n]),s[d]?r.push(s):i.push(s);s=A(e,pt(i,r))}return s},g.querySelectorAll&&function(){var e,t=vt,n=/'|\\/g,r=/\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,i=[":focus"],s=[":active"],u=y.matchesSelector||y.mozMatchesSelector||y.webkitMatchesSelector||y.oMatchesSelector||y.msMatchesSelector;K(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||i.push("\\["+O+"*(?:checked|disabled|ismap|multiple|readonly|selected|value)"),e.querySelectorAll(":checked").length||i.push(":checked")}),K(function(e){e.innerHTML="<p test=''></p>",e.querySelectorAll("[test^='']").length&&i.push("[*^$]="+O+"*(?:\"\"|'')"),e.innerHTML="<input type='hidden'/>",e.querySelectorAll(":enabled").length||i.push(":enabled",":disabled")}),i=new RegExp(i.join("|")),vt=function(e,r,s,o,u){if(!o&&!u&&!i.test(e)){var a,f,l=!0,c=d,h=r,p=r.nodeType===9&&e;if(r.nodeType===1&&r.nodeName.toLowerCase()!=="object"){a=ut(e),(l=r.getAttribute("id"))?c=l.replace(n,"\\$&"):r.setAttribute("id",c),c="[id='"+c+"'] ",f=a.length;while(f--)a[f]=c+a[f].join("");h=z.test(e)&&r.parentNode||r,p=a.join(",")}if(p)try{return S.apply(s,x.call(h.querySelectorAll(p),0)),s}catch(v){}finally{l||r.removeAttribute("id")}}return t(e,r,s,o,u)},u&&(K(function(t){e=u.call(t,"div");try{u.call(t,"[test!='']:sizzle"),s.push("!=",H)}catch(n){}}),s=new RegExp(s.join("|")),nt.matchesSelector=function(t,n){n=n.replace(r,"='$1']");if(!o(t)&&!s.test(n)&&!i.test(n))try{var a=u.call(t,n);if(a||e||t.document&&t.document.nodeType!==11)return a}catch(f){}return nt(n,null,null,[t]).length>0})}(),i.pseudos.nth=i.pseudos.eq,i.filters=mt.prototype=i.pseudos,i.setFilters=new mt,nt.attr=v.attr,v.find=nt,v.expr=nt.selectors,v.expr[":"]=v.expr.pseudos,v.unique=nt.uniqueSort,v.text=nt.getText,v.isXMLDoc=nt.isXML,v.contains=nt.contains}(e);var nt=/Until$/,rt=/^(?:parents|prev(?:Until|All))/,it=/^.[^:#\[\.,]*$/,st=v.expr.match.needsContext,ot={children:!0,contents:!0,next:!0,prev:!0};v.fn.extend({find:function(e){var t,n,r,i,s,o,u=this;if(typeof e!="string")return v(e).filter(function(){for(t=0,n=u.length;t<n;t++)if(v.contains(u[t],this))return!0});o=this.pushStack("","find",e);for(t=0,n=this.length;t<n;t++){r=o.length,v.find(e,this[t],o);if(t>0)for(i=r;i<o.length;i++)for(s=0;s<r;s++)if(o[s]===o[i]){o.splice(i--,1);break}}return o},has:function(e){var t,n=v(e,this),r=n.length;return this.filter(function(){for(t=0;t<r;t++)if(v.contains(this,n[t]))return!0})},not:function(e){return this.pushStack(ft(this,e,!1),"not",e)},filter:function(e){return this.pushStack(ft(this,e,!0),"filter",e)},is:function(e){return!!e&&(typeof e=="string"?st.test(e)?v(e,this.context).index(this[0])>=0:v.filter(e,this).length>0:this.filter(e).length>0)},closest:function(e,t){var n,r=0,i=this.length,s=[],o=st.test(e)||typeof e!="string"?v(e,t||this.context):0;for(;r<i;r++){n=this[r];while(n&&n.ownerDocument&&n!==t&&n.nodeType!==11){if(o?o.index(n)>-1:v.find.matchesSelector(n,e)){s.push(n);break}n=n.parentNode}}return s=s.length>1?v.unique(s):s,this.pushStack(s,"closest",e)},index:function(e){return e?typeof e=="string"?v.inArray(this[0],v(e)):v.inArray(e.jquery?e[0]:e,this):this[0]&&this[0].parentNode?this.prevAll().length:-1},add:function(e,t){var n=typeof e=="string"?v(e,t):v.makeArray(e&&e.nodeType?[e]:e),r=v.merge(this.get(),n);return this.pushStack(ut(n[0])||ut(r[0])?r:v.unique(r))},addBack:function(e){return this.add(e==null?this.prevObject:this.prevObject.filter(e))}}),v.fn.andSelf=v.fn.addBack,v.each({parent:function(e){var t=e.parentNode;return t&&t.nodeType!==11?t:null},parents:function(e){return v.dir(e,"parentNode")},parentsUntil:function(e,t,n){return v.dir(e,"parentNode",n)},next:function(e){return at(e,"nextSibling")},prev:function(e){return at(e,"previousSibling")},nextAll:function(e){return v.dir(e,"nextSibling")},prevAll:function(e){return v.dir(e,"previousSibling")},nextUntil:function(e,t,n){return v.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return v.dir(e,"previousSibling",n)},siblings:function(e){return v.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return v.sibling(e.firstChild)},contents:function(e){return v.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:v.merge([],e.childNodes)}},function(e,t){v.fn[e]=function(n,r){var i=v.map(this,t,n);return nt.test(e)||(r=n),r&&typeof r=="string"&&(i=v.filter(r,i)),i=this.length>1&&!ot[e]?v.unique(i):i,this.length>1&&rt.test(e)&&(i=i.reverse()),this.pushStack(i,e,l.call(arguments).join(","))}}),v.extend({filter:function(e,t,n){return n&&(e=":not("+e+")"),t.length===1?v.find.matchesSelector(t[0],e)?[t[0]]:[]:v.find.matches(e,t)},dir:function(e,n,r){var i=[],s=e[n];while(s&&s.nodeType!==9&&(r===t||s.nodeType!==1||!v(s).is(r)))s.nodeType===1&&i.push(s),s=s[n];return i},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)e.nodeType===1&&e!==t&&n.push(e);return n}});var ct="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",ht=/ jQuery\d+="(?:null|\d+)"/g,pt=/^\s+/,dt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,vt=/<([\w:]+)/,mt=/<tbody/i,gt=/<|&#?\w+;/,yt=/<(?:script|style|link)/i,bt=/<(?:script|object|embed|option|style)/i,wt=new RegExp("<(?:"+ct+")[\\s/>]","i"),Et=/^(?:checkbox|radio)$/,St=/checked\s*(?:[^=]|=\s*.checked.)/i,xt=/\/(java|ecma)script/i,Tt=/^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g,Nt={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]},Ct=lt(i),kt=Ct.appendChild(i.createElement("div"));Nt.optgroup=Nt.option,Nt.tbody=Nt.tfoot=Nt.colgroup=Nt.caption=Nt.thead,Nt.th=Nt.td,v.support.htmlSerialize||(Nt._default=[1,"X<div>","</div>"]),v.fn.extend({text:function(e){return v.access(this,function(e){return e===t?v.text(this):this.empty().append((this[0]&&this[0].ownerDocument||i).createTextNode(e))},null,e,arguments.length)},wrapAll:function(e){if(v.isFunction(e))return this.each(function(t){v(this).wrapAll(e.call(this,t))});if(this[0]){var t=v(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstChild&&e.firstChild.nodeType===1)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return v.isFunction(e)?this.each(function(t){v(this).wrapInner(e.call(this,t))}):this.each(function(){var t=v(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=v.isFunction(e);return this.each(function(n){v(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){v.nodeName(this,"body")||v(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(e){(this.nodeType===1||this.nodeType===11)&&this.appendChild(e)})},prepend:function(){return this.domManip(arguments,!0,function(e){(this.nodeType===1||this.nodeType===11)&&this.insertBefore(e,this.firstChild)})},before:function(){if(!ut(this[0]))return this.domManip(arguments,!1,function(e){this.parentNode.insertBefore(e,this)});if(arguments.length){var e=v.clean(arguments);return this.pushStack(v.merge(e,this),"before",this.selector)}},after:function(){if(!ut(this[0]))return this.domManip(arguments,!1,function(e){this.parentNode.insertBefore(e,this.nextSibling)});if(arguments.length){var e=v.clean(arguments);return this.pushStack(v.merge(this,e),"after",this.selector)}},remove:function(e,t){var n,r=0;for(;(n=this[r])!=null;r++)if(!e||v.filter(e,[n]).length)!t&&n.nodeType===1&&(v.cleanData(n.getElementsByTagName("*")),v.cleanData([n])),n.parentNode&&n.parentNode.removeChild(n);return this},empty:function(){var e,t=0;for(;(e=this[t])!=null;t++){e.nodeType===1&&v.cleanData(e.getElementsByTagName("*"));while(e.firstChild)e.removeChild(e.firstChild)}return this},clone:function(e,t){return e=e==null?!1:e,t=t==null?e:t,this.map(function(){return v.clone(this,e,t)})},html:function(e){return v.access(this,function(e){var n=this[0]||{},r=0,i=this.length;if(e===t)return n.nodeType===1?n.innerHTML.replace(ht,""):t;if(typeof e=="string"&&!yt.test(e)&&(v.support.htmlSerialize||!wt.test(e))&&(v.support.leadingWhitespace||!pt.test(e))&&!Nt[(vt.exec(e)||["",""])[1].toLowerCase()]){e=e.replace(dt,"<$1></$2>");try{for(;r<i;r++)n=this[r]||{},n.nodeType===1&&(v.cleanData(n.getElementsByTagName("*")),n.innerHTML=e);n=0}catch(s){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(e){return ut(this[0])?this.length?this.pushStack(v(v.isFunction(e)?e():e),"replaceWith",e):this:v.isFunction(e)?this.each(function(t){var n=v(this),r=n.html();n.replaceWith(e.call(this,t,r))}):(typeof e!="string"&&(e=v(e).detach()),this.each(function(){var t=this.nextSibling,n=this.parentNode;v(this).remove(),t?v(t).before(e):v(n).append(e)}))},detach:function(e){return this.remove(e,!0)},domManip:function(e,n,r){e=[].concat.apply([],e);var i,s,o,u,a=0,f=e[0],l=[],c=this.length;if(!v.support.checkClone&&c>1&&typeof f=="string"&&St.test(f))return this.each(function(){v(this).domManip(e,n,r)});if(v.isFunction(f))return this.each(function(i){var s=v(this);e[0]=f.call(this,i,n?s.html():t),s.domManip(e,n,r)});if(this[0]){i=v.buildFragment(e,this,l),o=i.fragment,s=o.firstChild,o.childNodes.length===1&&(o=s);if(s){n=n&&v.nodeName(s,"tr");for(u=i.cacheable||c-1;a<c;a++)r.call(n&&v.nodeName(this[a],"table")?Lt(this[a],"tbody"):this[a],a===u?o:v.clone(o,!0,!0))}o=s=null,l.length&&v.each(l,function(e,t){t.src?v.ajax?v.ajax({url:t.src,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0}):v.error("no ajax"):v.globalEval((t.text||t.textContent||t.innerHTML||"").replace(Tt,"")),t.parentNode&&t.parentNode.removeChild(t)})}return this}}),v.buildFragment=function(e,n,r){var s,o,u,a=e[0];return n=n||i,n=!n.nodeType&&n[0]||n,n=n.ownerDocument||n,e.length===1&&typeof a=="string"&&a.length<512&&n===i&&a.charAt(0)==="<"&&!bt.test(a)&&(v.support.checkClone||!St.test(a))&&(v.support.html5Clone||!wt.test(a))&&(o=!0,s=v.fragments[a],u=s!==t),s||(s=n.createDocumentFragment(),v.clean(e,n,s,r),o&&(v.fragments[a]=u&&s)),{fragment:s,cacheable:o}},v.fragments={},v.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){v.fn[e]=function(n){var r,i=0,s=[],o=v(n),u=o.length,a=this.length===1&&this[0].parentNode;if((a==null||a&&a.nodeType===11&&a.childNodes.length===1)&&u===1)return o[t](this[0]),this;for(;i<u;i++)r=(i>0?this.clone(!0):this).get(),v(o[i])[t](r),s=s.concat(r);return this.pushStack(s,e,o.selector)}}),v.extend({clone:function(e,t,n){var r,i,s,o;v.support.html5Clone||v.isXMLDoc(e)||!wt.test("<"+e.nodeName+">")?o=e.cloneNode(!0):(kt.innerHTML=e.outerHTML,kt.removeChild(o=kt.firstChild));if((!v.support.noCloneEvent||!v.support.noCloneChecked)&&(e.nodeType===1||e.nodeType===11)&&!v.isXMLDoc(e)){Ot(e,o),r=Mt(e),i=Mt(o);for(s=0;r[s];++s)i[s]&&Ot(r[s],i[s])}if(t){At(e,o);if(n){r=Mt(e),i=Mt(o);for(s=0;r[s];++s)At(r[s],i[s])}}return r=i=null,o},clean:function(e,t,n,r){var s,o,u,a,f,l,c,h,p,d,m,g,y=t===i&&Ct,b=[];if(!t||typeof t.createDocumentFragment=="undefined")t=i;for(s=0;(u=e[s])!=null;s++){typeof u=="number"&&(u+="");if(!u)continue;if(typeof u=="string")if(!gt.test(u))u=t.createTextNode(u);else{y=y||lt(t),c=t.createElement("div"),y.appendChild(c),u=u.replace(dt,"<$1></$2>"),a=(vt.exec(u)||["",""])[1].toLowerCase(),f=Nt[a]||Nt._default,l=f[0],c.innerHTML=f[1]+u+f[2];while(l--)c=c.lastChild;if(!v.support.tbody){h=mt.test(u),p=a==="table"&&!h?c.firstChild&&c.firstChild.childNodes:f[1]==="<table>"&&!h?c.childNodes:[];for(o=p.length-1;o>=0;--o)v.nodeName(p[o],"tbody")&&!p[o].childNodes.length&&p[o].parentNode.removeChild(p[o])}!v.support.leadingWhitespace&&pt.test(u)&&c.insertBefore(t.createTextNode(pt.exec(u)[0]),c.firstChild),u=c.childNodes,c.parentNode.removeChild(c)}u.nodeType?b.push(u):v.merge(b,u)}c&&(u=c=y=null);if(!v.support.appendChecked)for(s=0;(u=b[s])!=null;s++)v.nodeName(u,"input")?_t(u):typeof u.getElementsByTagName!="undefined"&&v.grep(u.getElementsByTagName("input"),_t);if(n){m=function(e){if(!e.type||xt.test(e.type))return r?r.push(e.parentNode?e.parentNode.removeChild(e):e):n.appendChild(e)};for(s=0;(u=b[s])!=null;s++)if(!v.nodeName(u,"script")||!m(u))n.appendChild(u),typeof u.getElementsByTagName!="undefined"&&(g=v.grep(v.merge([],u.getElementsByTagName("script")),m),b.splice.apply(b,[s+1,0].concat(g)),s+=g.length)}return b},cleanData:function(e,t){var n,r,i,s,o=0,u=v.expando,a=v.cache,f=v.support.deleteExpando,l=v.event.special;for(;(i=e[o])!=null;o++)if(t||v.acceptData(i)){r=i[u],n=r&&a[r];if(n){if(n.events)for(s in n.events)l[s]?v.event.remove(i,s):v.removeEvent(i,s,n.handle);a[r]&&(delete a[r],f?delete i[u]:i.removeAttribute?i.removeAttribute(u):i[u]=null,v.deletedIds.push(r))}}}}),function(){var e,t;v.uaMatch=function(e){e=e.toLowerCase();var t=/(chrome)[ \/]([\w.]+)/.exec(e)||/(webkit)[ \/]([\w.]+)/.exec(e)||/(opera)(?:.*version|)[ \/]([\w.]+)/.exec(e)||/(msie) ([\w.]+)/.exec(e)||e.indexOf("compatible")<0&&/(mozilla)(?:.*? rv:([\w.]+)|)/.exec(e)||[];return{browser:t[1]||"",version:t[2]||"0"}},e=v.uaMatch(o.userAgent),t={},e.browser&&(t[e.browser]=!0,t.version=e.version),t.chrome?t.webkit=!0:t.webkit&&(t.safari=!0),v.browser=t,v.sub=function(){function e(t,n){return new e.fn.init(t,n)}v.extend(!0,e,this),e.superclass=this,e.fn=e.prototype=this(),e.fn.constructor=e,e.sub=this.sub,e.fn.init=function(r,i){return i&&i instanceof v&&!(i instanceof e)&&(i=e(i)),v.fn.init.call(this,r,i,t)},e.fn.init.prototype=e.fn;var t=e(i);return e}}();var Dt,Pt,Ht,Bt=/alpha\([^)]*\)/i,jt=/opacity=([^)]*)/,Ft=/^(top|right|bottom|left)$/,It=/^(none|table(?!-c[ea]).+)/,qt=/^margin/,Rt=new RegExp("^("+m+")(.*)$","i"),Ut=new RegExp("^("+m+")(?!px)[a-z%]+$","i"),zt=new RegExp("^([-+])=("+m+")","i"),Wt={BODY:"block"},Xt={position:"absolute",visibility:"hidden",display:"block"},Vt={letterSpacing:0,fontWeight:400},$t=["Top","Right","Bottom","Left"],Jt=["Webkit","O","Moz","ms"],Kt=v.fn.toggle;v.fn.extend({css:function(e,n){return v.access(this,function(e,n,r){return r!==t?v.style(e,n,r):v.css(e,n)},e,n,arguments.length>1)},show:function(){return Yt(this,!0)},hide:function(){return Yt(this)},toggle:function(e,t){var n=typeof e=="boolean";return v.isFunction(e)&&v.isFunction(t)?Kt.apply(this,arguments):this.each(function(){(n?e:Gt(this))?v(this).show():v(this).hide()})}}),v.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Dt(e,"opacity");return n===""?"1":n}}}},cssNumber:{fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":v.support.cssFloat?"cssFloat":"styleFloat"},style:function(e,n,r,i){if(!e||e.nodeType===3||e.nodeType===8||!e.style)return;var s,o,u,a=v.camelCase(n),f=e.style;n=v.cssProps[a]||(v.cssProps[a]=Qt(f,a)),u=v.cssHooks[n]||v.cssHooks[a];if(r===t)return u&&"get"in u&&(s=u.get(e,!1,i))!==t?s:f[n];o=typeof r,o==="string"&&(s=zt.exec(r))&&(r=(s[1]+1)*s[2]+parseFloat(v.css(e,n)),o="number");if(r==null||o==="number"&&isNaN(r))return;o==="number"&&!v.cssNumber[a]&&(r+="px");if(!u||!("set"in u)||(r=u.set(e,r,i))!==t)try{f[n]=r}catch(l){}},css:function(e,n,r,i){var s,o,u,a=v.camelCase(n);return n=v.cssProps[a]||(v.cssProps[a]=Qt(e.style,a)),u=v.cssHooks[n]||v.cssHooks[a],u&&"get"in u&&(s=u.get(e,!0,i)),s===t&&(s=Dt(e,n)),s==="normal"&&n in Vt&&(s=Vt[n]),r||i!==t?(o=parseFloat(s),r||v.isNumeric(o)?o||0:s):s},swap:function(e,t,n){var r,i,s={};for(i in t)s[i]=e.style[i],e.style[i]=t[i];r=n.call(e);for(i in t)e.style[i]=s[i];return r}}),e.getComputedStyle?Dt=function(t,n){var r,i,s,o,u=e.getComputedStyle(t,null),a=t.style;return u&&(r=u.getPropertyValue(n)||u[n],r===""&&!v.contains(t.ownerDocument,t)&&(r=v.style(t,n)),Ut.test(r)&&qt.test(n)&&(i=a.width,s=a.minWidth,o=a.maxWidth,a.minWidth=a.maxWidth=a.width=r,r=u.width,a.width=i,a.minWidth=s,a.maxWidth=o)),r}:i.documentElement.currentStyle&&(Dt=function(e,t){var n,r,i=e.currentStyle&&e.currentStyle[t],s=e.style;return i==null&&s&&s[t]&&(i=s[t]),Ut.test(i)&&!Ft.test(t)&&(n=s.left,r=e.runtimeStyle&&e.runtimeStyle.left,r&&(e.runtimeStyle.left=e.currentStyle.left),s.left=t==="fontSize"?"1em":i,i=s.pixelLeft+"px",s.left=n,r&&(e.runtimeStyle.left=r)),i===""?"auto":i}),v.each(["height","width"],function(e,t){v.cssHooks[t]={get:function(e,n,r){if(n)return e.offsetWidth===0&&It.test(Dt(e,"display"))?v.swap(e,Xt,function(){return tn(e,t,r)}):tn(e,t,r)},set:function(e,n,r){return Zt(e,n,r?en(e,t,r,v.support.boxSizing&&v.css(e,"boxSizing")==="border-box"):0)}}}),v.support.opacity||(v.cssHooks.opacity={get:function(e,t){return jt.test((t&&e.currentStyle?e.currentStyle.filter:e.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":t?"1":""},set:function(e,t){var n=e.style,r=e.currentStyle,i=v.isNumeric(t)?"alpha(opacity="+t*100+")":"",s=r&&r.filter||n.filter||"";n.zoom=1;if(t>=1&&v.trim(s.replace(Bt,""))===""&&n.removeAttribute){n.removeAttribute("filter");if(r&&!r.filter)return}n.filter=Bt.test(s)?s.replace(Bt,i):s+" "+i}}),v(function(){v.support.reliableMarginRight||(v.cssHooks.marginRight={get:function(e,t){return v.swap(e,{display:"inline-block"},function(){if(t)return Dt(e,"marginRight")})}}),!v.support.pixelPosition&&v.fn.position&&v.each(["top","left"],function(e,t){v.cssHooks[t]={get:function(e,n){if(n){var r=Dt(e,t);return Ut.test(r)?v(e).position()[t]+"px":r}}}})}),v.expr&&v.expr.filters&&(v.expr.filters.hidden=function(e){return e.offsetWidth===0&&e.offsetHeight===0||!v.support.reliableHiddenOffsets&&(e.style&&e.style.display||Dt(e,"display"))==="none"},v.expr.filters.visible=function(e){return!v.expr.filters.hidden(e)}),v.each({margin:"",padding:"",border:"Width"},function(e,t){v.cssHooks[e+t]={expand:function(n){var r,i=typeof n=="string"?n.split(" "):[n],s={};for(r=0;r<4;r++)s[e+$t[r]+t]=i[r]||i[r-2]||i[0];return s}},qt.test(e)||(v.cssHooks[e+t].set=Zt)});var rn=/%20/g,sn=/\[\]$/,on=/\r?\n/g,un=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,an=/^(?:select|textarea)/i;v.fn.extend({serialize:function(){return v.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?v.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||an.test(this.nodeName)||un.test(this.type))}).map(function(e,t){var n=v(this).val();return n==null?null:v.isArray(n)?v.map(n,function(e,n){return{name:t.name,value:e.replace(on,"\r\n")}}):{name:t.name,value:n.replace(on,"\r\n")}}).get()}}),v.param=function(e,n){var r,i=[],s=function(e,t){t=v.isFunction(t)?t():t==null?"":t,i[i.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};n===t&&(n=v.ajaxSettings&&v.ajaxSettings.traditional);if(v.isArray(e)||e.jquery&&!v.isPlainObject(e))v.each(e,function(){s(this.name,this.value)});else for(r in e)fn(r,e[r],n,s);return i.join("&").replace(rn,"+")};var ln,cn,hn=/#.*$/,pn=/^(.*?):[ \t]*([^\r\n]*)\r?$/mg,dn=/^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,vn=/^(?:GET|HEAD)$/,mn=/^\/\//,gn=/\?/,yn=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,bn=/([?&])_=[^&]*/,wn=/^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,En=v.fn.load,Sn={},xn={},Tn=["*/"]+["*"];try{cn=s.href}catch(Nn){cn=i.createElement("a"),cn.href="",cn=cn.href}ln=wn.exec(cn.toLowerCase())||[],v.fn.load=function(e,n,r){if(typeof e!="string"&&En)return En.apply(this,arguments);if(!this.length)return this;var i,s,o,u=this,a=e.indexOf(" ");return a>=0&&(i=e.slice(a,e.length),e=e.slice(0,a)),v.isFunction(n)?(r=n,n=t):n&&typeof n=="object"&&(s="POST"),v.ajax({url:e,type:s,dataType:"html",data:n,complete:function(e,t){r&&u.each(r,o||[e.responseText,t,e])}}).done(function(e){o=arguments,u.html(i?v("<div>").append(e.replace(yn,"")).find(i):e)}),this},v.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(e,t){v.fn[t]=function(e){return this.on(t,e)}}),v.each(["get","post"],function(e,n){v[n]=function(e,r,i,s){return v.isFunction(r)&&(s=s||i,i=r,r=t),v.ajax({type:n,url:e,data:r,success:i,dataType:s})}}),v.extend({getScript:function(e,n){return v.get(e,t,n,"script")},getJSON:function(e,t,n){return v.get(e,t,n,"json")},ajaxSetup:function(e,t){return t?Ln(e,v.ajaxSettings):(t=e,e=v.ajaxSettings),Ln(e,t),e},ajaxSettings:{url:cn,isLocal:dn.test(ln[1]),global:!0,type:"GET",contentType:"application/x-www-form-urlencoded; charset=UTF-8",processData:!0,async:!0,accepts:{xml:"application/xml, text/xml",html:"text/html",text:"text/plain",json:"application/json, text/javascript","*":Tn},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":e.String,"text html":!0,"text json":v.parseJSON,"text xml":v.parseXML},flatOptions:{context:!0,url:!0}},ajaxPrefilter:Cn(Sn),ajaxTransport:Cn(xn),ajax:function(e,n){function T(e,n,s,a){var l,y,b,w,S,T=n;if(E===2)return;E=2,u&&clearTimeout(u),o=t,i=a||"",x.readyState=e>0?4:0,s&&(w=An(c,x,s));if(e>=200&&e<300||e===304)c.ifModified&&(S=x.getResponseHeader("Last-Modified"),S&&(v.lastModified[r]=S),S=x.getResponseHeader("Etag"),S&&(v.etag[r]=S)),e===304?(T="notmodified",l=!0):(l=On(c,w),T=l.state,y=l.data,b=l.error,l=!b);else{b=T;if(!T||e)T="error",e<0&&(e=0)}x.status=e,x.statusText=(n||T)+"",l?d.resolveWith(h,[y,T,x]):d.rejectWith(h,[x,T,b]),x.statusCode(g),g=t,f&&p.trigger("ajax"+(l?"Success":"Error"),[x,c,l?y:b]),m.fireWith(h,[x,T]),f&&(p.trigger("ajaxComplete",[x,c]),--v.active||v.event.trigger("ajaxStop"))}typeof e=="object"&&(n=e,e=t),n=n||{};var r,i,s,o,u,a,f,l,c=v.ajaxSetup({},n),h=c.context||c,p=h!==c&&(h.nodeType||h instanceof v)?v(h):v.event,d=v.Deferred(),m=v.Callbacks("once memory"),g=c.statusCode||{},b={},w={},E=0,S="canceled",x={readyState:0,setRequestHeader:function(e,t){if(!E){var n=e.toLowerCase();e=w[n]=w[n]||e,b[e]=t}return this},getAllResponseHeaders:function(){return E===2?i:null},getResponseHeader:function(e){var n;if(E===2){if(!s){s={};while(n=pn.exec(i))s[n[1].toLowerCase()]=n[2]}n=s[e.toLowerCase()]}return n===t?null:n},overrideMimeType:function(e){return E||(c.mimeType=e),this},abort:function(e){return e=e||S,o&&o.abort(e),T(0,e),this}};d.promise(x),x.success=x.done,x.error=x.fail,x.complete=m.add,x.statusCode=function(e){if(e){var t;if(E<2)for(t in e)g[t]=[g[t],e[t]];else t=e[x.status],x.always(t)}return this},c.url=((e||c.url)+"").replace(hn,"").replace(mn,ln[1]+"//"),c.dataTypes=v.trim(c.dataType||"*").toLowerCase().split(y),c.crossDomain==null&&(a=wn.exec(c.url.toLowerCase()),c.crossDomain=!(!a||a[1]===ln[1]&&a[2]===ln[2]&&(a[3]||(a[1]==="http:"?80:443))==(ln[3]||(ln[1]==="http:"?80:443)))),c.data&&c.processData&&typeof c.data!="string"&&(c.data=v.param(c.data,c.traditional)),kn(Sn,c,n,x);if(E===2)return x;f=c.global,c.type=c.type.toUpperCase(),c.hasContent=!vn.test(c.type),f&&v.active++===0&&v.event.trigger("ajaxStart");if(!c.hasContent){c.data&&(c.url+=(gn.test(c.url)?"&":"?")+c.data,delete c.data),r=c.url;if(c.cache===!1){var N=v.now(),C=c.url.replace(bn,"$1_="+N);c.url=C+(C===c.url?(gn.test(c.url)?"&":"?")+"_="+N:"")}}(c.data&&c.hasContent&&c.contentType!==!1||n.contentType)&&x.setRequestHeader("Content-Type",c.contentType),c.ifModified&&(r=r||c.url,v.lastModified[r]&&x.setRequestHeader("If-Modified-Since",v.lastModified[r]),v.etag[r]&&x.setRequestHeader("If-None-Match",v.etag[r])),x.setRequestHeader("Accept",c.dataTypes[0]&&c.accepts[c.dataTypes[0]]?c.accepts[c.dataTypes[0]]+(c.dataTypes[0]!=="*"?", "+Tn+"; q=0.01":""):c.accepts["*"]);for(l in c.headers)x.setRequestHeader(l,c.headers[l]);if(!c.beforeSend||c.beforeSend.call(h,x,c)!==!1&&E!==2){S="abort";for(l in{success:1,error:1,complete:1})x[l](c[l]);o=kn(xn,c,n,x);if(!o)T(-1,"No Transport");else{x.readyState=1,f&&p.trigger("ajaxSend",[x,c]),c.async&&c.timeout>0&&(u=setTimeout(function(){x.abort("timeout")},c.timeout));try{E=1,o.send(b,T)}catch(k){if(!(E<2))throw k;T(-1,k)}}return x}return x.abort()},active:0,lastModified:{},etag:{}});var Mn=[],_n=/\?/,Dn=/(=)\?(?=&|$)|\?\?/,Pn=v.now();v.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Mn.pop()||v.expando+"_"+Pn++;return this[e]=!0,e}}),v.ajaxPrefilter("json jsonp",function(n,r,i){var s,o,u,a=n.data,f=n.url,l=n.jsonp!==!1,c=l&&Dn.test(f),h=l&&!c&&typeof a=="string"&&!(n.contentType||"").indexOf("application/x-www-form-urlencoded")&&Dn.test(a);if(n.dataTypes[0]==="jsonp"||c||h)return s=n.jsonpCallback=v.isFunction(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,o=e[s],c?n.url=f.replace(Dn,"$1"+s):h?n.data=a.replace(Dn,"$1"+s):l&&(n.url+=(_n.test(f)?"&":"?")+n.jsonp+"="+s),n.converters["script json"]=function(){return u||v.error(s+" was not called"),u[0]},n.dataTypes[0]="json",e[s]=function(){u=arguments},i.always(function(){e[s]=o,n[s]&&(n.jsonpCallback=r.jsonpCallback,Mn.push(s)),u&&v.isFunction(o)&&o(u[0]),u=o=t}),"script"}),v.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/javascript|ecmascript/},converters:{"text script":function(e){return v.globalEval(e),e}}}),v.ajaxPrefilter("script",function(e){e.cache===t&&(e.cache=!1),e.crossDomain&&(e.type="GET",e.global=!1)}),v.ajaxTransport("script",function(e){if(e.crossDomain){var n,r=i.head||i.getElementsByTagName("head")[0]||i.documentElement;return{send:function(s,o){n=i.createElement("script"),n.async="async",e.scriptCharset&&(n.charset=e.scriptCharset),n.src=e.url,n.onload=n.onreadystatechange=function(e,i){if(i||!n.readyState||/loaded|complete/.test(n.readyState))n.onload=n.onreadystatechange=null,r&&n.parentNode&&r.removeChild(n),n=t,i||o(200,"success")},r.insertBefore(n,r.firstChild)},abort:function(){n&&n.onload(0,1)}}}});var Hn,Bn=e.ActiveXObject?function(){for(var e in Hn)Hn[e](0,1)}:!1,jn=0;v.ajaxSettings.xhr=e.ActiveXObject?function(){return!this.isLocal&&Fn()||In()}:Fn,function(e){v.extend(v.support,{ajax:!!e,cors:!!e&&"withCredentials"in e})}(v.ajaxSettings.xhr()),v.support.ajax&&v.ajaxTransport(function(n){if(!n.crossDomain||v.support.cors){var r;return{send:function(i,s){var o,u,a=n.xhr();n.username?a.open(n.type,n.url,n.async,n.username,n.password):a.open(n.type,n.url,n.async);if(n.xhrFields)for(u in n.xhrFields)a[u]=n.xhrFields[u];n.mimeType&&a.overrideMimeType&&a.overrideMimeType(n.mimeType),!n.crossDomain&&!i["X-Requested-With"]&&(i["X-Requested-With"]="XMLHttpRequest");try{for(u in i)a.setRequestHeader(u,i[u])}catch(f){}a.send(n.hasContent&&n.data||null),r=function(e,i){var u,f,l,c,h;try{if(r&&(i||a.readyState===4)){r=t,o&&(a.onreadystatechange=v.noop,Bn&&delete Hn[o]);if(i)a.readyState!==4&&a.abort();else{u=a.status,l=a.getAllResponseHeaders(),c={},h=a.responseXML,h&&h.documentElement&&(c.xml=h);try{c.text=a.responseText}catch(p){}try{f=a.statusText}catch(p){f=""}!u&&n.isLocal&&!n.crossDomain?u=c.text?200:404:u===1223&&(u=204)}}}catch(d){i||s(-1,d)}c&&s(u,f,c,l)},n.async?a.readyState===4?setTimeout(r,0):(o=++jn,Bn&&(Hn||(Hn={},v(e).unload(Bn)),Hn[o]=r),a.onreadystatechange=r):r()},abort:function(){r&&r(0,1)}}}});var qn,Rn,Un=/^(?:toggle|show|hide)$/,zn=new RegExp("^(?:([-+])=|)("+m+")([a-z%]*)$","i"),Wn=/queueHooks$/,Xn=[Gn],Vn={"*":[function(e,t){var n,r,i=this.createTween(e,t),s=zn.exec(t),o=i.cur(),u=+o||0,a=1,f=20;if(s){n=+s[2],r=s[3]||(v.cssNumber[e]?"":"px");if(r!=="px"&&u){u=v.css(i.elem,e,!0)||n||1;do a=a||".5",u/=a,v.style(i.elem,e,u+r);while(a!==(a=i.cur()/o)&&a!==1&&--f)}i.unit=r,i.start=u,i.end=s[1]?u+(s[1]+1)*n:n}return i}]};v.Animation=v.extend(Kn,{tweener:function(e,t){v.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");var n,r=0,i=e.length;for(;r<i;r++)n=e[r],Vn[n]=Vn[n]||[],Vn[n].unshift(t)},prefilter:function(e,t){t?Xn.unshift(e):Xn.push(e)}}),v.Tween=Yn,Yn.prototype={constructor:Yn,init:function(e,t,n,r,i,s){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=s||(v.cssNumber[n]?"":"px")},cur:function(){var e=Yn.propHooks[this.prop];return e&&e.get?e.get(this):Yn.propHooks._default.get(this)},run:function(e){var t,n=Yn.propHooks[this.prop];return this.options.duration?this.pos=t=v.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):Yn.propHooks._default.set(this),this}},Yn.prototype.init.prototype=Yn.prototype,Yn.propHooks={_default:{get:function(e){var t;return e.elem[e.prop]==null||!!e.elem.style&&e.elem.style[e.prop]!=null?(t=v.css(e.elem,e.prop,!1,""),!t||t==="auto"?0:t):e.elem[e.prop]},set:function(e){v.fx.step[e.prop]?v.fx.step[e.prop](e):e.elem.style&&(e.elem.style[v.cssProps[e.prop]]!=null||v.cssHooks[e.prop])?v.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},Yn.propHooks.scrollTop=Yn.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},v.each(["toggle","show","hide"],function(e,t){var n=v.fn[t];v.fn[t]=function(r,i,s){return r==null||typeof r=="boolean"||!e&&v.isFunction(r)&&v.isFunction(i)?n.apply(this,arguments):this.animate(Zn(t,!0),r,i,s)}}),v.fn.extend({fadeTo:function(e,t,n,r){return this.filter(Gt).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=v.isEmptyObject(e),s=v.speed(t,n,r),o=function(){var t=Kn(this,v.extend({},e),s);i&&t.stop(!0)};return i||s.queue===!1?this.each(o):this.queue(s.queue,o)},stop:function(e,n,r){var i=function(e){var t=e.stop;delete e.stop,t(r)};return typeof e!="string"&&(r=n,n=e,e=t),n&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,n=e!=null&&e+"queueHooks",s=v.timers,o=v._data(this);if(n)o[n]&&o[n].stop&&i(o[n]);else for(n in o)o[n]&&o[n].stop&&Wn.test(n)&&i(o[n]);for(n=s.length;n--;)s[n].elem===this&&(e==null||s[n].queue===e)&&(s[n].anim.stop(r),t=!1,s.splice(n,1));(t||!r)&&v.dequeue(this,e)})}}),v.each({slideDown:Zn("show"),slideUp:Zn("hide"),slideToggle:Zn("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){v.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),v.speed=function(e,t,n){var r=e&&typeof e=="object"?v.extend({},e):{complete:n||!n&&t||v.isFunction(e)&&e,duration:e,easing:n&&t||t&&!v.isFunction(t)&&t};r.duration=v.fx.off?0:typeof r.duration=="number"?r.duration:r.duration in v.fx.speeds?v.fx.speeds[r.duration]:v.fx.speeds._default;if(r.queue==null||r.queue===!0)r.queue="fx";return r.old=r.complete,r.complete=function(){v.isFunction(r.old)&&r.old.call(this),r.queue&&v.dequeue(this,r.queue)},r},v.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},v.timers=[],v.fx=Yn.prototype.init,v.fx.tick=function(){var e,n=v.timers,r=0;qn=v.now();for(;r<n.length;r++)e=n[r],!e()&&n[r]===e&&n.splice(r--,1);n.length||v.fx.stop(),qn=t},v.fx.timer=function(e){e()&&v.timers.push(e)&&!Rn&&(Rn=setInterval(v.fx.tick,v.fx.interval))},v.fx.interval=13,v.fx.stop=function(){clearInterval(Rn),Rn=null},v.fx.speeds={slow:600,fast:200,_default:400},v.fx.step={},v.expr&&v.expr.filters&&(v.expr.filters.animated=function(e){return v.grep(v.timers,function(t){return e===t.elem}).length});var er=/^(?:body|html)$/i;v.fn.offset=function(e){if(arguments.length)return e===t?this:this.each(function(t){v.offset.setOffset(this,e,t)});var n,r,i,s,o,u,a,f={top:0,left:0},l=this[0],c=l&&l.ownerDocument;if(!c)return;return(r=c.body)===l?v.offset.bodyOffset(l):(n=c.documentElement,v.contains(n,l)?(typeof l.getBoundingClientRect!="undefined"&&(f=l.getBoundingClientRect()),i=tr(c),s=n.clientTop||r.clientTop||0,o=n.clientLeft||r.clientLeft||0,u=i.pageYOffset||n.scrollTop,a=i.pageXOffset||n.scrollLeft,{top:f.top+u-s,left:f.left+a-o}):f)},v.offset={bodyOffset:function(e){var t=e.offsetTop,n=e.offsetLeft;return v.support.doesNotIncludeMarginInBodyOffset&&(t+=parseFloat(v.css(e,"marginTop"))||0,n+=parseFloat(v.css(e,"marginLeft"))||0),{top:t,left:n}},setOffset:function(e,t,n){var r=v.css(e,"position");r==="static"&&(e.style.position="relative");var i=v(e),s=i.offset(),o=v.css(e,"top"),u=v.css(e,"left"),a=(r==="absolute"||r==="fixed")&&v.inArray("auto",[o,u])>-1,f={},l={},c,h;a?(l=i.position(),c=l.top,h=l.left):(c=parseFloat(o)||0,h=parseFloat(u)||0),v.isFunction(t)&&(t=t.call(e,n,s)),t.top!=null&&(f.top=t.top-s.top+c),t.left!=null&&(f.left=t.left-s.left+h),"using"in t?t.using.call(e,f):i.css(f)}},v.fn.extend({position:function(){if(!this[0])return;var e=this[0],t=this.offsetParent(),n=this.offset(),r=er.test(t[0].nodeName)?{top:0,left:0}:t.offset();return n.top-=parseFloat(v.css(e,"marginTop"))||0,n.left-=parseFloat(v.css(e,"marginLeft"))||0,r.top+=parseFloat(v.css(t[0],"borderTopWidth"))||0,r.left+=parseFloat(v.css(t[0],"borderLeftWidth"))||0,{top:n.top-r.top,left:n.left-r.left}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||i.body;while(e&&!er.test(e.nodeName)&&v.css(e,"position")==="static")e=e.offsetParent;return e||i.body})}}),v.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,n){var r=/Y/.test(n);v.fn[e]=function(i){return v.access(this,function(e,i,s){var o=tr(e);if(s===t)return o?n in o?o[n]:o.document.documentElement[i]:e[i];o?o.scrollTo(r?v(o).scrollLeft():s,r?s:v(o).scrollTop()):e[i]=s},e,i,arguments.length,null)}}),v.each({Height:"height",Width:"width"},function(e,n){v.each({padding:"inner"+e,content:n,"":"outer"+e},function(r,i){v.fn[i]=function(i,s){var o=arguments.length&&(r||typeof i!="boolean"),u=r||(i===!0||s===!0?"margin":"border");return v.access(this,function(n,r,i){var s;return v.isWindow(n)?n.document.documentElement["client"+e]:n.nodeType===9?(s=n.documentElement,Math.max(n.body["scroll"+e],s["scroll"+e],n.body["offset"+e],s["offset"+e],s["client"+e])):i===t?v.css(n,r,i,u):v.style(n,r,i,u)},n,o?i:t,o,null)}})}),e.jQuery=e.$=v,typeof define=="function"&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return v})})(window);
/*
 * jQuery Easing v1.3.2 - http://gsgd.co.uk/sandbox/jquery/easing/
*/
(function ($) {
    $.easing['jswing'] = $.easing['swing'];

    // t: current time, b: begInnIng value, c: change In value, d: duration
    $.extend($.easing,
    {
        def: 'easeInOutQuart',
        swing: function (x, t, b, c, d) {
            return jQuery.easing[jQuery.easing.def](x, t, b, c, d);
        },
        easeInOutQuart: function (x, t, b, c, d) {
            if ((t /= d / 2) < 1) return c / 2 * t * t * t * t + b;
            return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
        },
        easeOutQuad: function (x, t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        },
    });
})(jQuery);
/*! WOW - v1.0.2 - 2014-10-28
* Copyright (c) 2014 Matthieu Aussaguel; Licensed MIT */(function(){var a,b,c,d,e,f=function(a,b){return function(){return a.apply(b,arguments)}},g=[].indexOf||function(a){for(var b=0,c=this.length;c>b;b++)if(b in this&&this[b]===a)return b;return-1};b=function(){function a(){}return a.prototype.extend=function(a,b){var c,d;for(c in b)d=b[c],null==a[c]&&(a[c]=d);return a},a.prototype.isMobile=function(a){return/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(a)},a.prototype.addEvent=function(a,b,c){return null!=a.addEventListener?a.addEventListener(b,c,!1):null!=a.attachEvent?a.attachEvent("on"+b,c):a[b]=c},a.prototype.removeEvent=function(a,b,c){return null!=a.removeEventListener?a.removeEventListener(b,c,!1):null!=a.detachEvent?a.detachEvent("on"+b,c):delete a[b]},a.prototype.innerHeight=function(){return"innerHeight"in window?window.innerHeight:document.documentElement.clientHeight},a}(),c=this.WeakMap||this.MozWeakMap||(c=function(){function a(){this.keys=[],this.values=[]}return a.prototype.get=function(a){var b,c,d,e,f;for(f=this.keys,b=d=0,e=f.length;e>d;b=++d)if(c=f[b],c===a)return this.values[b]},a.prototype.set=function(a,b){var c,d,e,f,g;for(g=this.keys,c=e=0,f=g.length;f>e;c=++e)if(d=g[c],d===a)return void(this.values[c]=b);return this.keys.push(a),this.values.push(b)},a}()),a=this.MutationObserver||this.WebkitMutationObserver||this.MozMutationObserver||(a=function(){function a(){"undefined"!=typeof console&&null!==console&&console.warn("MutationObserver is not supported by your browser."),"undefined"!=typeof console&&null!==console&&console.warn("WOW.js cannot detect dom mutations, please call .sync() after loading new content.")}return a.notSupported=!0,a.prototype.observe=function(){},a}()),d=this.getComputedStyle||function(a){return this.getPropertyValue=function(b){var c;return"float"===b&&(b="styleFloat"),e.test(b)&&b.replace(e,function(a,b){return b.toUpperCase()}),(null!=(c=a.currentStyle)?c[b]:void 0)||null},this},e=/(\-([a-z]){1})/g,this.WOW=function(){function e(a){null==a&&(a={}),this.scrollCallback=f(this.scrollCallback,this),this.scrollHandler=f(this.scrollHandler,this),this.start=f(this.start,this),this.scrolled=!0,this.config=this.util().extend(a,this.defaults),this.animationNameCache=new c}return e.prototype.defaults={boxClass:"wow",animateClass:"animated",offset:0,mobile:!0,live:!0},e.prototype.init=function(){var a;return this.element=window.document.documentElement,"interactive"===(a=document.readyState)||"complete"===a?this.start():this.util().addEvent(document,"DOMContentLoaded",this.start),this.finished=[]},e.prototype.start=function(){var b,c,d,e;if(this.stopped=!1,this.boxes=function(){var a,c,d,e;for(d=this.element.querySelectorAll("."+this.config.boxClass),e=[],a=0,c=d.length;c>a;a++)b=d[a],e.push(b);return e}.call(this),this.all=function(){var a,c,d,e;for(d=this.boxes,e=[],a=0,c=d.length;c>a;a++)b=d[a],e.push(b);return e}.call(this),this.boxes.length)if(this.disabled())this.resetStyle();else for(e=this.boxes,c=0,d=e.length;d>c;c++)b=e[c],this.applyStyle(b,!0);return this.disabled()||(this.util().addEvent(window,"scroll",this.scrollHandler),this.util().addEvent(window,"resize",this.scrollHandler),this.interval=setInterval(this.scrollCallback,50)),this.config.live?new a(function(a){return function(b){var c,d,e,f,g;for(g=[],e=0,f=b.length;f>e;e++)d=b[e],g.push(function(){var a,b,e,f;for(e=d.addedNodes||[],f=[],a=0,b=e.length;b>a;a++)c=e[a],f.push(this.doSync(c));return f}.call(a));return g}}(this)).observe(document.body,{childList:!0,subtree:!0}):void 0},e.prototype.stop=function(){return this.stopped=!0,this.util().removeEvent(window,"scroll",this.scrollHandler),this.util().removeEvent(window,"resize",this.scrollHandler),null!=this.interval?clearInterval(this.interval):void 0},e.prototype.sync=function(){return a.notSupported?this.doSync(this.element):void 0},e.prototype.doSync=function(a){var b,c,d,e,f;if(null==a&&(a=this.element),1===a.nodeType){for(a=a.parentNode||a,e=a.querySelectorAll("."+this.config.boxClass),f=[],c=0,d=e.length;d>c;c++)b=e[c],g.call(this.all,b)<0?(this.boxes.push(b),this.all.push(b),this.stopped||this.disabled()?this.resetStyle():this.applyStyle(b,!0),f.push(this.scrolled=!0)):f.push(void 0);return f}},e.prototype.show=function(a){return this.applyStyle(a),a.className=""+a.className+" "+this.config.animateClass},e.prototype.applyStyle=function(a,b){var c,d,e;return d=a.getAttribute("data-wow-duration"),c=a.getAttribute("data-wow-delay"),e=a.getAttribute("data-wow-iteration"),this.animate(function(f){return function(){return f.customStyle(a,b,d,c,e)}}(this))},e.prototype.animate=function(){return"requestAnimationFrame"in window?function(a){return window.requestAnimationFrame(a)}:function(a){return a()}}(),e.prototype.resetStyle=function(){var a,b,c,d,e;for(d=this.boxes,e=[],b=0,c=d.length;c>b;b++)a=d[b],e.push(a.style.visibility="visible");return e},e.prototype.customStyle=function(a,b,c,d,e){return b&&this.cacheAnimationName(a),a.style.visibility=b?"hidden":"visible",c&&this.vendorSet(a.style,{animationDuration:c}),d&&this.vendorSet(a.style,{animationDelay:d}),e&&this.vendorSet(a.style,{animationIterationCount:e}),this.vendorSet(a.style,{animationName:b?"none":this.cachedAnimationName(a)}),a},e.prototype.vendors=["moz","webkit"],e.prototype.vendorSet=function(a,b){var c,d,e,f;f=[];for(c in b)d=b[c],a[""+c]=d,f.push(function(){var b,f,g,h;for(g=this.vendors,h=[],b=0,f=g.length;f>b;b++)e=g[b],h.push(a[""+e+c.charAt(0).toUpperCase()+c.substr(1)]=d);return h}.call(this));return f},e.prototype.vendorCSS=function(a,b){var c,e,f,g,h,i;for(e=d(a),c=e.getPropertyCSSValue(b),i=this.vendors,g=0,h=i.length;h>g;g++)f=i[g],c=c||e.getPropertyCSSValue("-"+f+"-"+b);return c},e.prototype.animationName=function(a){var b;try{b=this.vendorCSS(a,"animation-name").cssText}catch(c){b=d(a).getPropertyValue("animation-name")}return"none"===b?"":b},e.prototype.cacheAnimationName=function(a){return this.animationNameCache.set(a,this.animationName(a))},e.prototype.cachedAnimationName=function(a){return this.animationNameCache.get(a)},e.prototype.scrollHandler=function(){return this.scrolled=!0},e.prototype.scrollCallback=function(){var a;return!this.scrolled||(this.scrolled=!1,this.boxes=function(){var b,c,d,e;for(d=this.boxes,e=[],b=0,c=d.length;c>b;b++)a=d[b],a&&(this.isVisible(a)?this.show(a):e.push(a));return e}.call(this),this.boxes.length||this.config.live)?void 0:this.stop()},e.prototype.offsetTop=function(a){for(var b;void 0===a.offsetTop;)a=a.parentNode;for(b=a.offsetTop;a=a.offsetParent;)b+=a.offsetTop;return b},e.prototype.isVisible=function(a){var b,c,d,e,f;return c=a.getAttribute("data-wow-offset")||this.config.offset,f=window.pageYOffset,e=f+Math.min(this.element.clientHeight,this.util().innerHeight())-c,d=this.offsetTop(a),b=d+a.clientHeight,e>=d&&b>=f},e.prototype.util=function(){return null!=this._util?this._util:this._util=new b},e.prototype.disabled=function(){return!this.config.mobile&&this.util().isMobile(navigator.userAgent)},e}()}).call(this);

$.fn.placeholder = function () {
    return this.each(function () {
        var $this = $(this),
            w = $this.outerWidth(),
            h = $this.outerHeight();

        $this.parent().css("position", "relative");

        //Block
        var $placeholder = $("<div class=\"input-placeholder\"></div>").css({
            width: w,
            height: h,
            fontSize: $this.css("font-size"),
            paddingTop: $this.css("padding-top"),
            paddingLeft: $this.css("padding-left"),
            paddingRight: $this.css("padding-right"),
            paddingBottom: $this.css("padding-bottom")
        }).text($this.attr("placeholder"));

        //Initialization
        if (!$this.data("placeholder-inited")) {
            $this.before($placeholder).data("placeholder-inited", true);
        }

        if ($this.val()) {
            $placeholder.addClass("hide");
        }

        //Events
        $placeholder.on("click", function () {
            $this.focus();
        });

        $this.on("focus", function () {
            $placeholder.addClass("hide");
        });

        $this.on("blur", function () {
            if (!$this.val()) {
                $placeholder.removeClass("hide");
            }
        });
    });
};


$(function () {
    if (undefined === document.createElement("input").placeholder) {
        $('input[placeholder], textarea[placeholder]').placeholder();
    }
});
/* ========================================================================
 * Bootstrap: tooltip.js v3.3.1
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = function (element, options) {
    this.type       =
    this.options    =
    this.enabled    =
    this.timeout    =
    this.hoverState =
    this.$element   = null

    this.init('tooltip', element, options)
  }

  Tooltip.VERSION  = '3.3.1'

  Tooltip.TRANSITION_DURATION = 150

  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    }
  }

  Tooltip.prototype.init = function (type, element, options) {
    this.enabled   = true
    this.type      = type
    this.$element  = $(element)
    this.options   = this.getOptions(options)
    this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport)

    var triggers = this.options.trigger.split(' ')

    for (var i = triggers.length; i--;) {
      var trigger = triggers[i]

      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (trigger != 'manual') {
        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }
    }

    this.options.selector ?
      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
      this.fixTitle()
  }

  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS
  }

  Tooltip.prototype.getOptions = function (options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options)

    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      }
    }

    return options
  }

  Tooltip.prototype.getDelegateOptions = function () {
    var options  = {}
    var defaults = this.getDefaults()

    this._options && $.each(this._options, function (key, value) {
      if (defaults[key] != value) options[key] = value
    })

    return options
  }

  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (self && self.$tip && self.$tip.is(':visible')) {
      self.hoverState = 'in'
      return
    }

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    clearTimeout(self.timeout)

    self.hoverState = 'in'

    if (!self.options.delay || !self.options.delay.show) return self.show()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in') self.show()
    }, self.options.delay.show)
  }

  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    clearTimeout(self.timeout)

    self.hoverState = 'out'

    if (!self.options.delay || !self.options.delay.hide) return self.hide()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out') self.hide()
    }, self.options.delay.hide)
  }

  Tooltip.prototype.show = function () {
    var e = $.Event('show.bs.' + this.type)

    if (this.hasContent() && this.enabled) {
      this.$element.trigger(e)

      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
      if (e.isDefaultPrevented() || !inDom) return
      var that = this

      var $tip = this.tip()

      var tipId = this.getUID(this.type)

      this.setContent()
      $tip.attr('id', tipId)
      this.$element.attr('aria-describedby', tipId)

      if (this.options.animation) $tip.addClass('fade')

      var placement = typeof this.options.placement == 'function' ?
        this.options.placement.call(this, $tip[0], this.$element[0]) :
        this.options.placement

      var autoToken = /\s?auto?\s?/i
      var autoPlace = autoToken.test(placement)
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

      $tip
        .detach()
        .css({ top: 0, left: 0, display: 'block' })
        .addClass(placement)
        .data('bs.' + this.type, this)

      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

      var pos          = this.getPosition()
      var actualWidth  = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight

      if (autoPlace) {
        var orgPlacement = placement
        var $container   = this.options.container ? $(this.options.container) : this.$element.parent()
        var containerDim = this.getPosition($container)

        placement = placement == 'bottom' && pos.bottom + actualHeight > containerDim.bottom ? 'top'    :
                    placement == 'top'    && pos.top    - actualHeight < containerDim.top    ? 'bottom' :
                    placement == 'right'  && pos.right  + actualWidth  > containerDim.width  ? 'left'   :
                    placement == 'left'   && pos.left   - actualWidth  < containerDim.left   ? 'right'  :
                    placement

        $tip
          .removeClass(orgPlacement)
          .addClass(placement)
      }

      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

      this.applyPlacement(calculatedOffset, placement)

      var complete = function () {
        var prevHoverState = that.hoverState
        that.$element.trigger('shown.bs.' + that.type)
        that.hoverState = null

        if (prevHoverState == 'out') that.leave(that)
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        $tip
          .one('bsTransitionEnd', complete)
          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
        complete()
    }
  }

  Tooltip.prototype.applyPlacement = function (offset, placement) {
    var $tip   = this.tip()
    var width  = $tip[0].offsetWidth
    var height = $tip[0].offsetHeight

    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css('margin-top'), 10)
    var marginLeft = parseInt($tip.css('margin-left'), 10)

    // we must check for NaN for ie 8/9
    if (isNaN(marginTop))  marginTop  = 0
    if (isNaN(marginLeft)) marginLeft = 0

    offset.top  = offset.top  + marginTop
    offset.left = offset.left + marginLeft

    // $.fn.offset doesn't round pixel values
    // so we use setOffset directly with our own function B-0
    $.offset.setOffset($tip[0], $.extend({
      using: function (props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        })
      }
    }, offset), 0)

    $tip.addClass('in')

    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth  = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight

    if (placement == 'top' && actualHeight != height) {
      offset.top = offset.top + height - actualHeight
    }

    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

    if (delta.left) offset.left += delta.left
    else offset.top += delta.top

    var isVertical          = /top|bottom/.test(placement)
    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'

    $tip.offset(offset)
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
  }

  Tooltip.prototype.replaceArrow = function (delta, dimension, isHorizontal) {
    this.arrow()
      .css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
      .css(isHorizontal ? 'top' : 'left', '')
  }

  Tooltip.prototype.setContent = function () {
    var $tip  = this.tip()
    var title = this.getTitle()

    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
    $tip.removeClass('fade in top bottom left right')
  }

  Tooltip.prototype.hide = function (callback) {
    var that = this
    var $tip = this.tip()
    var e    = $.Event('hide.bs.' + this.type)

    function complete() {
      if (that.hoverState != 'in') $tip.detach()
      that.$element
        .removeAttr('aria-describedby')
        .trigger('hidden.bs.' + that.type)
      callback && callback()
    }

    this.$element.trigger(e)

    if (e.isDefaultPrevented()) return

    $tip.removeClass('in')

    $.support.transition && this.$tip.hasClass('fade') ?
      $tip
        .one('bsTransitionEnd', complete)
        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
      complete()

    this.hoverState = null

    return this
  }

  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element
    if ($e.attr('title') || typeof ($e.attr('data-original-title')) != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
    }
  }

  Tooltip.prototype.hasContent = function () {
    return this.getTitle()
  }

  Tooltip.prototype.getPosition = function ($element) {
    $element   = $element || this.$element

    var el     = $element[0]
    var isBody = el.tagName == 'BODY'

    var elRect    = el.getBoundingClientRect()
    if (elRect.width == null) {
      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
    }
    var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()
    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null

    return $.extend({}, elRect, scroll, outerDims, elOffset)
  }

  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2  } :
           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2  } :
           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width   }

  }

  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
    var delta = { top: 0, left: 0 }
    if (!this.$viewport) return delta

    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
    var viewportDimensions = this.getPosition(this.$viewport)

    if (/right|left/.test(placement)) {
      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
      if (topEdgeOffset < viewportDimensions.top) { // top overflow
        delta.top = viewportDimensions.top - topEdgeOffset
      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
      }
    } else {
      var leftEdgeOffset  = pos.left - viewportPadding
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
        delta.left = viewportDimensions.left - leftEdgeOffset
      } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow
        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
      }
    }

    return delta
  }

  Tooltip.prototype.getTitle = function () {
    var title
    var $e = this.$element
    var o  = this.options

    title = $e.attr('data-original-title')
      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

    return title
  }

  Tooltip.prototype.getUID = function (prefix) {
    do prefix += ~~(Math.random() * 1000000)
    while (document.getElementById(prefix))
    return prefix
  }

  Tooltip.prototype.tip = function () {
    return (this.$tip = this.$tip || $(this.options.template))
  }

  Tooltip.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
  }

  Tooltip.prototype.enable = function () {
    this.enabled = true
  }

  Tooltip.prototype.disable = function () {
    this.enabled = false
  }

  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled
  }

  Tooltip.prototype.toggle = function (e) {
    var self = this
    if (e) {
      self = $(e.currentTarget).data('bs.' + this.type)
      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
        $(e.currentTarget).data('bs.' + this.type, self)
      }
    }

    self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
  }

  Tooltip.prototype.destroy = function () {
    var that = this
    clearTimeout(this.timeout)
    this.hide(function () {
      that.$element.off('.' + that.type).removeData('bs.' + that.type)
    })
  }


  // TOOLTIP PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this    = $(this)
      var data     = $this.data('bs.tooltip')
      var options  = typeof option == 'object' && option
      var selector = options && options.selector

      if (!data && option == 'destroy') return
      if (selector) {
        if (!data) $this.data('bs.tooltip', (data = {}))
        if (!data[selector]) data[selector] = new Tooltip(this, options)
      } else {
        if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      }
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tooltip

  $.fn.tooltip             = Plugin
  $.fn.tooltip.Constructor = Tooltip


  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(jQuery);
/* ========================================================================
 * Bootstrap: popover.js v3.3.1
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
    this.init('popover', element, options)
  }

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

  Popover.VERSION  = '3.3.1'

  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })


  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

  Popover.prototype.constructor = Popover

  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS
  }

  Popover.prototype.setContent = function () {
    var $tip    = this.tip()
    var title   = this.getTitle()
    var content = this.getContent()

    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
    ](content)

    $tip.removeClass('fade top bottom left right in')

    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }

  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent()
  }

  Popover.prototype.getContent = function () {
    var $e = this.$element
    var o  = this.options

    return $e.attr('data-content')
      || (typeof o.content == 'function' ?
            o.content.call($e[0]) :
            o.content)
  }

  Popover.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
  }

  Popover.prototype.tip = function () {
    if (!this.$tip) this.$tip = $(this.options.template)
    return this.$tip
  }


  // POPOVER PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this    = $(this)
      var data     = $this.data('bs.popover')
      var options  = typeof option == 'object' && option
      var selector = options && options.selector

      if (!data && option == 'destroy') return
      if (selector) {
        if (!data) $this.data('bs.popover', (data = {}))
        if (!data[selector]) data[selector] = new Popover(this, options)
      } else {
        if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      }
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.popover

  $.fn.popover             = Plugin
  $.fn.popover.Constructor = Popover


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }

}(jQuery);
/**
 * Debounce and throttle function's decorator plugin 1.0.5
 *
 * Copyright (c) 2009 Filatov Dmitry (alpha@zforms.ru)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function($) {

$.extend({

    debounce : function(fn, timeout, invokeAsap, ctx) {

        if(arguments.length == 3 && typeof invokeAsap != 'boolean') {
            ctx = invokeAsap;
            invokeAsap = false;
        }

        var timer;

        return function() {

            var args = arguments;
            ctx = ctx || this;

            invokeAsap && !timer && fn.apply(ctx, args);

            clearTimeout(timer);

            timer = setTimeout(function() {
                !invokeAsap && fn.apply(ctx, args);
                timer = null;
            }, timeout);

        };

    },

    throttle : function(fn, timeout, ctx) {

        var timer, args, needInvoke;

        return function() {

            args = arguments;
            needInvoke = true;
            ctx = ctx || this;

            if(!timer) {
                (function() {
                    if(needInvoke) {
                        fn.apply(ctx, args);
                        needInvoke = false;
                        timer = setTimeout(arguments.callee, timeout);
                    }
                    else {
                        timer = null;
                    }
                })();
            }

        };

    }

});

})(jQuery);
(function () {
    // значение по умолчанию
    var defaults = {
        closeIcon: null,
        height: 'auto',
        skin: 'default/lightbox_new.css',
        template:
            '<div class="lightbox2">\
             <table class="centring">\
                <tbody><tr><td class="lightbox-cell">\
                    <div class="lightbox-wrapper">\
                        <div class="lightbox-loader"></div>\
                        <span class="lightbox2-close" title="Закрыть"><span class="lightbox-closeText">Закрыть</span> <span class="lb-cross">&times;</span></span>\
                        <div class="lightbox-content"></div>\
                   </div>\
               </tr></td></tbody>\
            </table>\
            </div>',
        wrapperStyle: false,
        contentStyle: false,
        lightboxClass: false,
        closeText: 'Закрыть',
        autoOpen: true,
        bottomPanelVisibility: true,
        buttons: false,
        buttonTemplate: '<span class="lb-button" />',
        veilClass: false,
        veilClickFade: true,
        panelHtml: false,
        esc: true,
        fullWindowWrapper: false,
        returnableDOM: false,
        preventDefaultEvents: false,
    };

    var lightboxes = [];

    var lightboxIdCounter = 0;

    var pageWrapper = $('#pageWrapper'),
        veil = $('#lightbox-veil'),
        myWindow = $(window),
        myDocument = $(document),
        windowHeight = myWindow.height(),
        currentScrollTop;
    
    function scrollbarWidth() {
        var parent = $('<div style="width:50px;height:50px;overflow:auto"><div/></div>').appendTo('body'),
            child = parent.children(),
            width = child.innerWidth() - child.height(99).innerWidth();
        parent.remove();
        return width;
    }
    
    function checkPageLayoutForLightbox() {
        pageWrapper = $('#pageWrapper');
        if (pageWrapper.size() == 0) {
            var bodyChild = $('body > :visible');
            if (bodyChild.size() == 1) {
                bodyChild.attr('id', 'pageWrapper');
            } else {
                $('body').wrapInner('<div id="pageWrapper" style="height: ' + windowHeight + 'px"></div>');
            }

            pageWrapper = $('#pageWrapper');
        }

        if (veil.size() == 0) {
            veil = $('<div>').attr({ id: 'lightbox-veil' });
            $('body').append(veil);
        }
    }

    function makeLightboxTemplate() {
        var obj = this;
        checkPageLayoutForLightbox();
        var lightbox = $(this.data('template'));
        this.data('content', lightbox.find('.lightbox-content'));
        this.data('root', lightbox.filter('.lightbox2'));
        this.data('wrapper', lightbox.find('.lightbox-wrapper'));

        lightboxIdCounter++;

        if (this.data('returnableDOM')) {
            this.data('flagID', 'lightboxFlag' + lightboxIdCounter);
            this.after('<input type="hidden" id="' + this.data('flagID') + '" />');
        }


        //bottomPanel
        if (this.data('bottomPanelVisibility')) {
            this.data('bottomPanel', $('<div class="lb-bottom"><div class="lb-clr"></div></div>'));
            this.data('content').after(this.data('bottomPanel'));

            //panelHtml
            if (obj.data('panelHtml')) {
                obj.data('bottomPanel').append($(obj.data('panelHtml')).clone(true));
            } else {
                //buttons placing
                var buttons = this.data('buttons');
                if (buttons) {
                    var closelLink = $('<span class="lb-closeLink">' + this.data('closeText') + '</span>');
                    closelLink.click(function () { closeLightbox(obj); return false; });
                    //buttons object type
                    if ($.type(buttons) === 'object' && !$.isEmptyObject(buttons)) {
                        this.data('bottomPanel').prepend(closelLink);
                        $.each(buttons, function (key, value) {
                            var button = $(obj.data('buttonTemplate'));
                            button.text(key);
                            button.append('<span class="button_orange-right"></span>');
                            obj.data('bottomPanel').prepend(button);
                            button.data('id', key);
                            button.click(function () {
                                value.apply(obj, arguments);
                            });
                        });
                        //buttons array type
                    } else if ($.isArray(buttons) && buttons.length > 0) {
                        obj.data('bottomPanel').prepend(closelLink);
                        $.each(buttons, function (key, value) {
                            var button = $(obj.data('buttonTemplate'));

                            $.each(value, function (btkey, btvalue) {
                                if (btkey == 'text') {
                                    button.text(value.text);
                                } else if (btkey == 'click') {
                                    button.click(function () {
                                        value.click.apply(obj, arguments);
                                    });
                                } else if (btkey == 'template') {
                                    button = $(btvalue);
                                } else {
                                    button.attr(btkey, btvalue);
                                }
                            });
                            button.append('<span class="button_orange-right"></span>');
                            obj.data('bottomPanel').prepend(button);
                        });
                    } else {
                        $.error('Buttons incorrect format or empty object');
                    }
                } else {
                    createDefaultBottomPanel(obj);
                }
            }
        }

        this.appendTo(obj.data('content'));

        this.data('wrapperStyle') ? this.data('wrapper').css(this.data('wrapperStyle')) : null;
        this.data('contentStyle') ? this.data('content').css(this.data('contentStyle')) : null;
        this.data('lightboxClass') ? lightbox.addClass(this.data('lightboxClass')) : null;

        //closeEvents
        lightbox.find('.lightbox2-close').click(function () {
            closeLightbox(obj);
        });

        $('body').append(lightbox);

        obj.data({
            isCreated: true,
            lightbox: lightbox
        });

        lightboxes.push(obj);

        //CALLBACK 'create'
        if ($.isFunction(obj.data('create'))) {
            obj.data('create').apply(obj, arguments);
        }
    }

    function createDefaultBottomPanel(obj) {
        var closeButton = $('<span class="lb-button js-lb-closeLink" value="">' + obj.data('closeText') + '</span>');
        closeButton.append('<span class="button_orange-right"></span>');
        obj.data('bottomPanel').html('<div class="lb-clr"></div>').prepend(closeButton);

        closeButton.click(function () {
            closeLightbox(obj);
        });
    }

    function updateParams(obj) {
        windowHeight = myWindow.height();
        veil.height(windowHeight);
        pageWrapper.height(windowHeight);
        /* check */
        obj.data('lightbox').height(windowHeight);
    }
    function updateLbHeight() {
        var obj = this;
        var wrapper = obj.data('wrapper');
        var bottomPanel = obj.data('bottomPanel');
        var bottomPanelHeight = bottomPanel ? bottomPanel.outerHeight() : 0;
        this.data('content').height(function () {
            var result = myWindow.height() - 40 - parseInt(wrapper.css('padding-top')) - parseInt(wrapper.css('padding-bottom')) - bottomPanelHeight - parseInt(obj.data('content').css('margin-bottom')) - parseInt(obj.data('content').css('margin-top'));
            return result;
        });

    }
    function veilClickfadeCheck(obj) {
        if (obj.data('veilClickFade')) {
            obj.data('lightbox').bind('mousedown.fadeLightbox', function (e) {
                var require1 = e.pageX < obj.data('wrapper').offset().left;
                var require2 = (e.pageX > (obj.data('wrapper').offset().left + obj.data('wrapper').outerWidth())) && e.pageX < (obj.data('lightbox').width() - scrollbarWidth());
                var require3 = e.pageY < obj.data('wrapper').offset().top;
                var require4 = (e.pageY > (obj.data('wrapper').offset().top + obj.data('wrapper').outerHeight())) && e.pageY < (obj.data('lightbox').height() - scrollbarWidth());
                var require5 = $(e.target).parents('.lightbox-wrapper').size() == 0 && !$(e.target).hasClass('lightbox-wrapper');
                
                //IE return undefined from $(e.target).context, if target is input:disabled
                var require6 = $(e.target).context !== undefined;
                
                if ((require1 || require2 || require3 || require4) && require5 && require6) {
                    closeLightbox(obj);
                    obj.data('lightbox').unbind('mousedown.fadeLightbox');
                }
            });
        } else {
            obj.data('lightbox').unbind('mousedown.fadeLightbox');
        }
    }
    function showLightbox(obj) {
        
        if ($('.spw').length) {
            $(window).trigger("swpClosed");
        }
        
        try {
            currentScrollTop = $(document).scrollTop();
        } catch(e) {
            //NOTE catch ie8 bug after changing trusted site status #17421
        }
        
        pageWrapper.addClass('lb-open');
        $('html, body').addClass('lb-on');
        
        myWindow.bind('resize.lightbox', function() {
            if (obj.data('isOpen')) {
                updateParams(obj);
            }
        });

        if (obj.data('esc')) {
            myDocument.bind('keyup.lightbox', function (e) {
                if (e.keyCode == 27) {
                    closeLightbox(obj);
                }
            });
        }

        if (obj.data('veilClass')) {
            veil.addClass(obj.data('veilClass'));
        }

        veilClickfadeCheck(obj);

        $.each(lightboxes, function (index, val) {
            if (val.lightbox('isOpen')) {
                hideLightbox(val);
            }
        });

        if (obj.data('returnableDOM')) {
            obj.appendTo(obj.data('content'));
        }

        $(document).on('click.closeLightbox', '.js-closeLightbox', function () {
            obj.lightbox('close');
        });

        //CALLBACK 'beforeOpen'
        if ($.isFunction(obj.data('beforeOpen'))) {
            obj.data('beforeOpen').apply(obj, arguments);
        }

        //fullWindow?
        if (obj.data('fullWindowWrapper')) {
            obj.data('root').addClass('fullWindow');
            updateLbHeight.apply(obj, arguments);
            myWindow.bind('resize.updateLbHeight', function () {
                updateLbHeight.apply(obj, arguments);
            });
        }
        
        updateParams(obj);

        veil.css('top', 0);
        try {
            obj.data('lightbox').css('top', 0);
        } catch (e) {
            //NOTE catch ie8 bug after changing trusted site status #17421
        }

        veil.fadeIn('fast');
        obj.data('lightbox').height(myWindow.height()).show();
        obj.data('lightbox').fadeIn('fast', function () {
            pageWrapper.scrollTop(currentScrollTop);
            //isOpen flag on
            obj.data('isOpen', true);

            //CALLBACK 'open'
            if ($.isFunction(obj.data('open'))) {
                obj.data('open').apply(obj, arguments);
            }
            
            //event registration
            
            if (!obj.data('preventDefaultEvents')) {
                if (obj.data('event')) {
                    myWindow.trigger('pageEvent', 'event-' + obj.data('event') + '-lightbox');
                } else {
                    myWindow.trigger('pageEvent', getLightboxEventName.call(obj));
                }
            }
        });
        if (obj.data('fullWindowWrapper')) {
            updateLbHeight.apply(obj, arguments);
        }
    }
    function closeLightbox(obj) {
        $(document).off('click.closeLightbox');

        //CALLBACK 'beforeClose'
        if ($.isFunction(obj.data('beforeClose'))) {
            var result = obj.data('beforeClose').apply(obj, arguments);
            if (result === false)
                return;
        }

        if (obj.data('fullWindowWrapper')) {
            myWindow.unbind('resize.updateLbHeight');
            obj.data('root').removeClass('fullWindow');
        }

        myWindow.unbind('resize.lightbox');
        myDocument.unbind('keyup.lightbox');

        obj.data('lightbox').unbind('click.fadeLightbox');

        veil.fadeOut('fast', function () {
            veil.removeClass(obj.data('veilClass'));
        });
        
        obj.data('lightbox').fadeOut('fast', function () {
            $('html, body').removeClass('lb-on');

            //isOpen flag on
            obj.data('isOpen', false);

            //CALLBACK 'close'
            if ($.isFunction(obj.data('close'))) {
                obj.data('close').apply(obj, arguments);
            }

            if (obj.data('returnableDOM')) {
                obj.insertBefore($('#' + obj.data('flagID')));
            }
            
            pageWrapper.removeClass('lb-open').removeAttr('style');
            $(document).scrollTop(currentScrollTop);

            //CALLBACK 'afterClose'
            if ($.isFunction(obj.data('afterClose'))) {
                obj.data('afterClose').apply(obj, arguments);
            }
        });
    }

    function hideLightbox(obj) {
        //CALLBACK 'beforeClose'
        if ($.isFunction(obj.data('beforeClose'))) {
            var result = obj.data('beforeClose').apply(obj, arguments);
            if (result === false)
                return;
        }
        if (obj.data('fullWindowWrapper')) {
            myWindow.unbind('resize.updateLbHeight');
            obj.data('root').removeClass('fullWindow');
        }
        obj.data('lightbox').unbind('click.fadeLightbox');
        obj.data('lightbox').hide().data('isOpen', false);

        //CALLBACK 'close'
        if ($.isFunction(obj.data('close'))) {
            obj.data('close').apply(obj, arguments);
        }
        currentScrollTop = pageWrapper.scrollTop();
        $(document).scrollTop(currentScrollTop);

        //CALLBACK 'afterClose'
        if ($.isFunction(obj.data('afterClose'))) {
            obj.data('afterClose').apply(obj, arguments);
        }
    }

    function getLightboxEventName() {
        var eventName = this.data('event') || this.data('event-name') || this.attr('action') || this.attr('id') || this.selector;
        return ('event-' + eventName + '-lightbox');
    }

    // наши публичные методы
    var methods = {
        // инициализация плагина
        init: function (params) {
            if (this.data('isCreated')) {
                if (this.data('autoOpen')) {
                    showLightbox(this);
                }
            }
            else if (this.size() == 1) {
                // актуальные настройки, будут индивидуальными при каждом запуске
                var options = $.extend({}, defaults, params);
                this.data(options);

                makeLightboxTemplate.apply(this, arguments);
                if (this.data('autoOpen')) {
                    showLightbox(this);
                }
            }
            else if (this.size() == 0) {
                $.error('content for lightbox not finded content selector: "' + this.selector + '"');
            } else if (this.size() > 1) {
                $.error('to many blocks for lightbox on page. (size > 1. Must be only one)');
            }

            return this;
        },
        // изменение цвета
        open: function () {
            showLightbox(this);
        },
        close: function () {
            closeLightbox(this);
        },
        destroy: function () {
            this.data('lightbox').remove();
            this.data('isCreated', false);
            this.remove();
            veil.hide();
        },
        isOpen: function () {
            if (this.data('isOpen')) {
                return true;
            } else {
                return false;
            }
        },
        saveState: function () {
            this.data('state', this.html());
        },
        loadState: function () {
            this.html(this.data('state'));
        },
        option: function (option, val) {
            var self = this;

            switch (option) {
                case 'disabled':
                    if ($.type(val) === 'boolean') {
                        //setter way
                        this.data('disabled', val);
                        return this;
                    } else {
                        //getter way
                        return this.data('disabled');
                    }
                case 'autoOpen':
                    if ($.type(val) === 'boolean') {
                        //setter way
                        this.data('autoOpen', val);
                        return this;
                    } else {
                        //getter way
                        return this.data('autoOpen');
                    }
                case 'buttons':
                    var closeLink;
                    if (val && $.type(val) === 'object' && !$.isEmptyObject(val)) {
                        //setter with obj
                        $.each(val, function (key, value) {
                            var button = $(self.data('buttonTemplate'));
                            button.text(key);
                            button.append('<span class="button_orange-right"></span>');
                            self.data('bottomPanel').prepend(button);
                            button.data('id', key);
                            button.click(function () {
                                value.apply(self, arguments);
                            });
                        });
                        closeLink = $('<span class="lb-closeLink">Закрыть</span>');
                        closeLink.click(function () {
                            closeLightbox(self);
                        });
                        this.data('bottomPanel').find('.lb-closeLink').replaceWith(closeLink);
                        return this;
                    } else if ($.isArray(val) && val.length > 0) {
                        //setter with array
                        $.each(val, function (key, value) {
                            var button = $(self.data('buttonTemplate'));

                            $.each(value, function (btkey, btvalue) {
                                if (btkey == 'text') {
                                    button.text(value.text);
                                } else if (btkey == 'click') {
                                    button.click(function () {
                                        value.click.apply(self, arguments);
                                    });
                                } else if (btkey == 'template') {
                                    button = $(btvalue);
                                } else {
                                    button.attr(btkey, btvalue);
                                }
                            });
                            button.append('<span class="button_orange-right"></span>');
                            self.data('bottomPanel').prepend(button);
                        });
                        closeLink = $('<span class="lb-closeLink">Закрыть</span>');
                        closeLink.click(function () {
                            closeLightbox(self);
                        });
                        this.data('bottomPanel').find('.js-lb-closeLink').replaceWith(closeLink);
                        return this;
                    }
                    else {
                        $.error('Неверный формат данных для кнопки');
                        return this;
                    }
                case 'bottomPanelVisibility':
                    if ($.type(val) === 'boolean') {
                        //setter way
                        if (val === true) {
                            if (this.data('bottomPanelVisibility') === false) {
                                this.data('bottomPanel', $('<div class="lb-bottom"></div>'));
                                this.data('bottomPanel').hide();
                                this.data('content').after(this.data('bottomPanel'));
                                this.data('bottomPanelVisibility', true);
                                this.data('bottomPanel').show();
                                createDefaultBottomPanel(this);
                            } else {
                                $.error('bottomPanel already exist');
                            }
                        } else {
                            if (this.data('bottomPanelVisibility') === true) {
                                this.data('bottomPanel').remove();
                                this.data('bottomPanelVisibility', false);
                            } else {
                                $.error('bottomPanel not exist');
                            }
                        }
                        return this;
                    } else if (val === 'default') {
                        this.data('bottomPanelVisibility', true);
                        createDefaultBottomPanel(this);
                    } else {
                        //getter way
                        return this.data('bottomPanelVisibility');
                    }
                    break;
                case 'closeText':
                    if ($.type(val) === 'string') {
                        //setterWay
                        this.data('closeText', val);
                        var closeControll = this.data('bottomPanel').find('.lb-closeLink');
                        if (closeControll.is(':input')) {
                            closeControll.val(val);
                        } else {
                            closeControll.text(val);
                        }
                    } else {
                        //getter way
                        return this.data('closeText');
                    }

                    break;
                case 'wrapperStyle':
                    if (val && $.type(val) === 'object' && !$.isEmptyObject(val)) {
                        //setter way
                        this.data('wrapperStyle', val);
                        this.data('wrapper').css(val);
                    } else {
                        $.error('Неверный формат стилей. Пример правильного использования — {width: "500px", padding: 0}');
                    }
                    break;
                case 'contentStyle':
                    if (val && $.type(val) === 'object' && !$.isEmptyObject(val)) {
                        //setter way
                        this.data('contentStyle', val);
                        this.data('content').css(val);
                    } else {
                        $.error('Неверный формат стилей. Пример правильного использования — {width: "500px", padding: 0}');
                    }
                    break;
                case 'lightboxClass':
                    if ($.type(val) === 'string' && val.length > 0) {
                        this.data('lightbox').addClass(val);
                    }
                    break;
                case 'fullWindowWrapper':
                    if ($.type(val) === 'boolean') {
                        this.data('root').addClass('fullWindow');
                        updateLbHeight.apply(this, arguments);
                        myWindow.bind('resize.updateLbHeight', function () {
                            updateLbHeight.apply(this, arguments);
                        });
                    }
                    break;
                case 'veilClass':
                    if ($.type(val) === 'string' && val.length > 0) {
                        this.data('veilClass', val);
                        veil.addClass(val);
                    }
                    return this;
                case 'veilClickFade':
                    if ($.type(val) === 'boolean') {
                        //setter way
                        this.data('veilClickFade', val);
                        veilClickfadeCheck(this);
                        return this;
                    } else {
                        //getter way
                        return this.data('veilClickFade');
                    }
                case 'open':
                    if ($.isFunction(val)) {
                        this.data('open', val);
                    }
                    break;
                case 'beforeOpen':
                    if ($.isFunction(val)) {
                        this.data('beforeOpen', val);
                    }
                    break;
                case 'afterClose':
                    if ($.isFunction(val)) {
                        this.data('afterClose', val);
                    }
                    break;
                case 'close':
                    if ($.isFunction(val)) {
                        this.data('close', val);
                    }
                    break;
                case 'beforeClose':
                    if ($.isFunction(val)) {
                        this.data('beforeClose', val);
                    }
                    break;
                case 'esc':
                    if ($.type(val) === 'boolean') {
                        //setter way
                        this.data('esc', val);
                        return this;
                    } else {
                        //getter Way
                        return this.data('esc');
                    }
                case 'panelHtml':
                    this.data('panelHtml', val);
                    this.data('bottomPanel').html('').append($(val).clone(true));
                    return this;
                    
                default:
                    $.error('Опция "' + option + '" не найдена в плагине jQuery.lightbox');
            }
            return this;
        }
    };

    $.fn.lightbox = function (method) {
        // немного магии
        if (methods[method]) {
            // если запрашиваемый метод существует, мы его вызываем
            // все параметры, кроме имени метода прийдут в метод
            // this так же перекочует в метод
            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof method === 'object' || !method) {
            // если первым параметром идет объект, либо совсем пусто
            // выполняем метод init
            return methods.init.apply(this, arguments);
        } else {
            // если ничего не получилось
            $.error('Метод "' + method + '" не найден в плагине jQuery.lightbox');
        }
    };
})(jQuery);

/* docs 

Example:
$('#dialog').lightbox({
    create: function () { console.log('create!') },
    open: function () { console.log('open!') },
    close: function () { console.log('close!') },
    beforeClose: function () { console.log('beforeClose!') },
    autoOpen: false,
    bottomPanelVisibility: false
    });

Callbacks:
    create, open, beforeOpen, close, beforeClose

Methods:
    Exemple:
    $('#text').lightbox('open');
    open, destroy, close, isOpen, option

Options:

    Exemple:
    $('#text').lightbox('option', 'bottomPanelVisibility', false);

    List:
    disable (в стадии заглушка) [bool] — сделать контент лайтбокса недоступным для кликов,
    wrapperStyle [object] — стили для обертки лайтбокса (белый прямоугольник)
    autoOpen [bool] — нужно ли автоматически открыть лайтбокс после инициализации. Если false, то открыться будет только при $('#lightbox').lightbox('open'),
    bottomPanelVisibility [bool] — включает нижнюю панель лайтбокса. Требуется для кнопок,
    buttons [[], {}] — расставляет кнопки и события по клику по ним,
    contentStyle [{}] — задать стили для контент-зоны лайтбокса,
    esc [bool] — закрывать ли лайтбокс по нажатии клавиши esc,
    lightboxClass [string] — добавить класс блоку базовому лайтбокса (не распространаяется на вуаль),
    closeText [string] — текс, отображающийся на кнопке/ссылке закрытия,
    veilClass — задает класс блоку затемнения документа, который будет присвоен ТОЛЬКО на момент показа лайтбокса.
    fullWindowWrapper [bool] — растягивает лайтбокс на всю высоту окна.
    returnableDOM: [bool] — при true после закрытия лайтбокса будет возвращать дом-объект в то место, откуда их выдрал.
    panelHtml — [selector] — хтмл, который будет находиться в нижней панели лайтбокса.
*/
;
var Slider = (function ($, global) {
    'use strict';

    var defaultOptions = {
        root: '',
        items: '',
        markerTemplate: '<span class="sliderMarker" />',
        slide: 1,
        visible: 1,
        cycle: true,
        auto: 0,
        markers: false,
        base: null,
        navBlock: null,
        speed: 500
    },
        bindEvents,
        init,
        checkForCssPropsSupport,
        updateDimension,
        slideTo,
        slideToCustomSlide,
        addNavMarkers,
        currentMarkerClass = 'sliderMarker_current_js',
        disabledControlClass = 'slider-control_disabled_js',
        hasTransitions,
        hasTranslate3D,
        cssPrefix = "",
        touchTimer = 0,
        detectPrefix,
        defineSlideMethod,
        touch,
        ontransitionend,
        animateWithBestMethod,
        currentSlideIndex = 0,
        updateCurrentMarker,
        updateControlsState,
        prepareLayout,
        makeSliderHtml,
        $global = $(global),
        addBasicStyles,
        extendLeftItemsBlock,
        extendRightItemsBlock,
        slideNext,
        slidePrev,
        module = function () {
            init.apply(this, arguments);
        };

    init = function (params) {
        this.options = $.extend({}, defaultOptions, params);
        this.$base = $(this.options.base);
        this.$root = $(this.options.root);
        this.$items = $(this.options.items);
        this.$container = $(this.options.container);
        this.$navBlock = $(this.options.navBlock);
        this.$markers = $();

        detectPrefix();
        makeSliderHtml.call(this);
        addBasicStyles.call(this);
        updateDimension.call(this);
        prepareLayout.call(this);
        updateControlsState.call(this);
        checkForCssPropsSupport.call(this);
        defineSlideMethod.call(this);
        bindEvents.call(this);
    };

    detectPrefix = function () {
        if ($.browser.msie && $.browser.version < 9) {
            return;
        }
        var styles = window.getComputedStyle(document.documentElement, '');
        cssPrefix = '-' + (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o']))[1] + '-';
    };

    //private methods
    makeSliderHtml = function () {
        var limiter = $('<div style="height: 100%;overflow: hidden; position: relative;" class="slider-limiter"></div>'),
            prevControl,
            nextControl;
        this.$root = $('<div data-role="root" class="slider-root" />');

        this.$root.append(limiter);
        this.$container = $('<div data-role="container" class="slider-container" />');
        limiter.append(this.$container);
        this.$container.append(this.$items);

        if (this.options.markers) {
            this.$navBlock = $('<div class="slider-nav" style="bottom: 8px; left: 60px; position: absolute; z-index: 3;"/>');
            this.$markersBlock = $('<div class="slider-markers" style="display: inline-block; vertical-align: middle; *display: inline; *zoom: 1; border: 1px solid transparent;" />');
            this.$navBlock.append(this.$markersBlock);
            this.$root.append(this.$navBlock);
            addNavMarkers.call(this);
        }

        if (!this.options.prevControl) {
            this.options.prevControl = '[data-role="prevControl"]';
            prevControl = $('<div data-role="prevControl" class="slider-prevControl" />');
            if (this.options.markers) {
                prevControl.prependTo(this.$navBlock);
            } else {
                this.$root.append(prevControl);
            }
        }
        if (!this.options.nextControl) {
            this.options.nextControl = '[data-role="nextControl"]';
            nextControl = $('<div data-role="nextControl" class="slider-nextControl" />');
            if (this.options.markers) {
                nextControl.appendTo(this.$navBlock);
            } else {
                this.$root.append(nextControl);
            }
        }

        this.$base.append(this.$root);
        this.$prevControl = this.$base.find(this.options.prevControl);
        this.$nextControl = this.$base.find(this.options.nextControl);
    };

    addBasicStyles = function () {
        this.$root.css({
            height: '100%',
            position: 'relative',
            userSelect: 'none'
        });

        this.$container.css({
            position: 'absolute',
            left: 0,
            top: 0,
            height: '100%',
            minWidth: '100%'
        }).css(cssPrefix + 'transition', cssPrefix + 'transform ' + this.options.speed + 'ms ease-in-out');

        this.$items.css({
            'float': 'left',
            'overflow': 'hidden',
            height: '100%'
        });
    };
    extendLeftItemsBlock = function () {
        this.extendLeftCount += 1;
        var deeperContainer = this.$leftContainer.clone().css('right', 100 * this.extendLeftCount + '%');
        deeperContainer.appendTo(this.$container);
        this.$leftContainer = deeperContainer;
        this.options.additionalLeftSlidesCount += this.options.itemsStepCount;
    };
    extendRightItemsBlock = function () {
        this.extendRightCount += 1;
        var deeperContainer = this.$rightContainer.clone().css('left', 100 * this.extendRightCount + '%');
        deeperContainer.appendTo(this.$container);
        this.$rightContainer = deeperContainer;
        this.options.additionalRightSlidesCount += this.options.itemsStepCount;
    };
    prepareLayout = function () {
        if (this.options.cycle) {
            this.$leftContainer = $('<div class="sliderLeftContainer" style="position: absolute; height: 100%; right: 100%; min-width: 100%; width: 100%; top: 0; *zoom: 1;" />');
            this.$rightContainer = $('<div class="sliderRightContainer" style="position: absolute; height: 100%; left: 100%; min-width: 100%; width: 100%; top: 0; *zoom: 1;" />');

            var itemsSize = this.$items.size();
            this.options.additionalLeftSlidesCount = itemsSize;
            this.options.additionalRightSlidesCount = itemsSize;
            this.options.itemsStepCount = itemsSize;

            this.$leftContainer.append(this.$items.clone());
            this.$rightContainer.append(this.$items.clone());

            this.$container.append(this.$leftContainer);
            this.$container.append(this.$rightContainer);

            this.extendLeftCount = 1;
            this.extendRightCount = 1;

            this.options.currentMarkerIndex = 0;
        }
    };
    checkForCssPropsSupport = function () {
        var s = document.createElement('p').style;
        hasTransitions = 'transition' in s ||
            'WebkitTransition' in s ||
            'MozTransition' in s ||
            'msTransition' in s ||
            'OTransition' in s;

        hasTranslate3D = function () {
            var el = document.createElement('p'),
                has3D,
                transforms = {
                    'webkitTransform': '-webkit-transform',
                    'OTransform': '-o-transform',
                    'msTransform': '-ms-transform',
                    'MozTransform': '-moz-transform',
                    'transform': 'transform'
                };

            // Add it to the body to get the computed style.
            document.body.insertBefore(el, null);

            for (var t in transforms) {
                if (el.style[t] !== undefined) {
                    el.style[t] = "translate3d(1px,1px,1px)";
                    has3D = window.getComputedStyle(el).getPropertyValue(transforms[t]);
                }
            }

            document.body.removeChild(el);

            return (has3D !== undefined && has3D.length > 0 && has3D !== "none");
        }();
    };

    updateControlsState = function () {
        if (this.options.cycle) {
            return;
        }
        this.$nextControl.removeClass(disabledControlClass);
        this.$prevControl.removeClass(disabledControlClass);

        if (currentSlideIndex + 1 === this.$items.size()) {
            this.$nextControl.addClass(disabledControlClass);
        }
        if (currentSlideIndex === 0) {
            this.$prevControl.addClass(disabledControlClass);
        }
    };
    bindEvents = function () {
        this.$root.on('click.slider', this.options.nextControl, $.proxy(function () {
            slideNext.call(this);
        }, this));
        this.$root.on('click.slider', this.options.prevControl, $.proxy(function () {
            slidePrev.call(this);
        }, this));

        var p = document.createElement('p');
        if (p.addEventListener) {
            this.$container[0].addEventListener("touchstart", $.proxy(function (e) {
                touch.onTouchStart.call(this, e);
            }, this), false);

            this.$container[0].addEventListener("touchmove", $.proxy(function (e) {
                touch.onTouchMove.call(this, e);
            }, this), false);

            this.$container[0].addEventListener("touchend", $.proxy(function (e) {
                e.preventDefault();
                touch.onTouchEnd.call(this);
            }, this), false);
        }

        if (this.options.markers) {
            this.$root.on('click.slider', '[data-bind="marker"]', $.proxy(function (e) {
                var $marker = $(e.target),
                    index = $marker.index();

                if (!$marker.hasClass(currentMarkerClass)) {
                    slideToCustomSlide.apply(this, [index]);
                }
            }, this));
        }

        if (this.options.auto) {
            this.options.autoTimer = 0;
            this.options.autoTimer = setInterval($.proxy(function () {
                slideNext.call(this);
            }, this), this.options.auto);

            this.$root
                .on('mouseenter.slider', $.proxy(function () {
                    clearInterval(this.options.autoTimer);
                    this.$root.trigger('slider.stopAutoTimer', [this.options.currentMarkerIndex]);
                }, this))
                .on('mouseleave.slider', $.proxy(function () {
                    this.options.autoTimer = setInterval($.proxy(function () {
                        slideNext.call(this);
                        this.$root.trigger('slider.autoSlideNext');
                    }, this), this.options.auto);
                }, this));
        }

        if ("ActiveXObject" in window) {
            var self = this;
            $(window).resize(function () {
                updateDimension.call(self);
            });
        }


        /*        (function () {
                    var myDiv;
                    myDiv = document.createElement('DIV');
                    if ('ontransitionend' in window) {
                        ontransitionend = 'transitionend';
                    } else if ('onwebkittransitionend' in window) {
                        ontransitionend = 'webkitTransitionEnd';
                    } else if ('onotransitionend' in myDiv || navigator.appName == 'Opera') {
                        ontransitionend = 'oTransitionEnd';
                    } else {
                        ontransitionend = false;
                    }
                })();
        
                if (ontransitionend) {
                    this.$container[0].addEventListener(ontransitionend, $.proxy(function () {
                        this.$container.css(cssPrefix + 'transition', cssPrefix + 'transform ' + this.options.speed + 'ms ease-in-out');
                    }, this), false);
                }*/
    };
    touch = {
        onTouchStart: function (e) {
            if (e.touches.length != 1 || this.touchStarted) {
                return;
            }

            this.touchDetecting = true;
            this.touch = e.changedTouches[0];
            this.pageX = this.touch.pageX;
            this.pageY = this.touch.pageY;
            this.offsetValue = this.$container.css(cssPrefix + 'transform').replace('matrix(', '').split(', ')[4] || 0;
        },
        onTouchMove: function (e) {
            if (!this.touchStarted && !this.touchDetecting) {
                return;
            }

            if (this.touchDetecting) {
                touch.detectTouchMove.call(this, e);
            }

            if (this.touchStarted) {
                touch.draw.call(this, e);
            }
        },
        onTouchEnd: function () {
            if (this.touchStarted) {
                this.delta < 0 ? slideNext.call(this) : slidePrev.call(this);
            }

            this.touchStarted = false;
            this.touchDetecting = false;

            this.$container.css(cssPrefix + 'transition', cssPrefix + 'transform ' + this.options.speed + 'ms ease-out');
        },
        detectTouchMove: function (e) {
            if (Math.abs(this.pageX - e.changedTouches[0].pageX) >= Math.abs(this.pageY - e.changedTouches[0].pageY)) {
                e.preventDefault();

                //log.text(this.touchTimer);
                this.touchStarted = true;
                this.touchDetecting = false;
                this.$container.css(cssPrefix + 'transition', 'none');
            } else {
                this.touchStarted = false;
                this.touchDetecting = false;
            }
        },
        draw: function (e) {
            e.preventDefault();
            this.delta = (this.pageX - e.changedTouches[0].pageX) * -1;
            touch.moveTo.call(this);
        },
        moveTo: function () {
            var val = this.offsetValue * 1 + this.delta;
            //log.text(this.offsetValue);
            this.$container.css(cssPrefix + 'transform', 'translate3d(' + val + 'px, 0, 0)');
        }
    };
    updateCurrentMarker = function (index) {
        if (!this.options.markers) {
            return;
        }
        this.$markers.removeClass(currentMarkerClass);
        this.$markers.eq(index).addClass(currentMarkerClass);
    };
    addNavMarkers = function () {
        var $markerTemplate = $(this.options.markerTemplate);
        $markerTemplate.attr('data-bind', 'marker');
        this.options.currentMarkerIndex = 0;
        this.options.markerSize = 0;
        this.$items.each($.proxy(function () {
            var marker = $markerTemplate.clone();
            this.$markers = this.$markers.add(marker);
            this.$markersBlock.append(marker);
            this.options.markerSize += 1;
        }, this));
        this.$markers.first().addClass(currentMarkerClass);

    };
    updateDimension = function () {
        var width = 100 + (100 / this.options.visible * (this.$items.size() - this.options.visible));
        this.$container.width(width + '%');
        //ToDo в ие баг с размером блоков, если options.visible > 1
        if ("ActiveXObject" in window && this.options.visible == 1) {
            this.$items.width(parseInt(this.$container.parent().width()) / this.options.visible + 'px');
        } else {
            this.$items.width(100 / this.$items.size() + '%');
        }
    };

    defineSlideMethod = function () {
        if (hasTransitions) {
            if (hasTranslate3D) {
                animateWithBestMethod = function (index) {
                    this.$container.css('transform', 'translate3d(' + (100 / this.$items.size()) * -index + '%, 0, 0)');
                };
            } else {
                animateWithBestMethod = function (index) {
                    this.$container.css('transform', 'translate(' + (100 / this.$items.size()) * -index + '%, 0)');
                };
            }
        } else {
            animateWithBestMethod = function (index) {
                this.$container.stop(true, false).animate({
                    marginLeft: (100 / this.options.visible) * -index + '%'
                }, this.options.speed);
            };
        }
    };

    slideTo = function (index) {
        index = parseInt(index, 10);
        this.$root.trigger('slider.slideTo', [this.options.currentMarkerIndex]);
        animateWithBestMethod.call(this, index);
    };

    slideToCustomSlide = function (index) {
        currentSlideIndex += index - this.options.currentMarkerIndex;

        this.options.currentMarkerIndex = index;
        slideTo.apply(this, [currentSlideIndex]);
        updateControlsState.call(this);
        updateCurrentMarker.apply(this, [this.options.currentMarkerIndex]);
    };
    slideNext = function () {
        if (this.options.cycle) {
            if (this.options.currentMarkerIndex === this.$items.size() - 1) {
                this.options.currentMarkerIndex = 0;
            } else {
                this.options.currentMarkerIndex += this.options.slide;
            }

            if (currentSlideIndex > 0 && this.options.additionalRightSlidesCount - currentSlideIndex <= this.options.visible * 2) {
                extendRightItemsBlock.call(this);
            }
        } else if (currentSlideIndex !== this.$items.size() - 1) {
            this.options.currentMarkerIndex += this.options.slide;
        } else if (!this.options.cycle) {
            return
        }

        currentSlideIndex += this.options.slide;

        updateCurrentMarker.apply(this, [this.options.currentMarkerIndex]);
        updateControlsState.call(this);
        this.$root.trigger('slider.slideNext', [this.options.currentMarkerIndex]);
        slideTo.apply(this, [currentSlideIndex]);
    };
    slidePrev = function () {
        if (this.options.cycle) {
            if (this.options.currentMarkerIndex === 0) {
                this.options.currentMarkerIndex = this.$items.size() - 1;
            } else {
                this.options.currentMarkerIndex -= this.options.slide;
            }

            if (currentSlideIndex < 0 && this.options.additionalLeftSlidesCount - Math.abs(currentSlideIndex) <= this.options.visible * 2) {
                extendLeftItemsBlock.call(this);
            }
        } else if (currentSlideIndex !== 0) {
            this.options.currentMarkerIndex -= this.options.slide;
        } else if (!this.options.cycle) {
            return;
        }

        currentSlideIndex -= this.options.slide;

        updateCurrentMarker.apply(this, [this.options.currentMarkerIndex]);
        updateControlsState.call(this);
        this.$root.trigger('slider.slidePrev', [this.options.currentMarkerIndex]);
        slideTo.apply(this, [currentSlideIndex]);
    };

    //public methods
    module.prototype.updateDimension = function () {
        updateDimension.call(this);
        return this;
    };
    module.prototype.slideTo = function (index) {
        slideToCustomSlide.apply(this, [index]);
        return this;
    };
    module.prototype.setVisible = function (amount) {
        if (amount > this.$items.size()) {
            amount = this.$items.size();
        }
        this.options.visible = amount;
        updateDimension.call(this);
        slideTo.apply(this, [currentSlideIndex]);
        return this;
    };
    module.prototype.setSlide = function (amount) {
        this.options.slide = amount;
        return this;
    };
    module.prototype.slideNext = function () {
        slideNext.call(this);
        return this;
    };
    module.prototype.slidePrev = function () {
        slidePrev.call(this);
        return this;
    };
    module.prototype.getOptions = function () {
        return this.options;
    };

    return module;
})(jQuery, window);
/**
*    @name                            Elastic
*    @descripton                        Elastic is jQuery plugin that grow and shrink your textareas automatically
*    @version                        1.6.11
*    @requires                        jQuery 1.2.6+
*
*    @author                            Jan Jarfalk
*    @author-email                    jan.jarfalk@unwrongest.com
*    @author-website                    http://www.unwrongest.com
*
*    @licence                        MIT License - http://www.opensource.org/licenses/mit-license.php
*/

(function ($) {
    jQuery.fn.extend({
        elastic: function () {

            //    We will create a div clone of the textarea
            //    by copying these attributes from the textarea to the div.
            var mimics = [
                'paddingTop',
                'paddingRight',
                'paddingBottom',
                'paddingLeft',
                'fontSize',
                'lineHeight',
                'fontFamily',
                'width',
                'fontWeight',
                'border-top-width',
                'border-right-width',
                'border-bottom-width',
                'border-left-width',
                'borderTopStyle',
                'borderTopColor',
                'borderRightStyle',
                'borderRightColor',
                'borderBottomStyle',
                'borderBottomColor',
                'borderLeftStyle',
                'borderLeftColor'
            ];

            return this.each(function () {
                // Elastic only works on textareas
                if (this.type !== 'textarea' || jQuery(this).data('elastic')) {
                    return false;
                }

                var $textarea = jQuery(this),
                    $twin = jQuery('<div />').css({
                        'position': 'absolute',
                        'display': 'none',
                        'word-wrap': 'break-word',
                        'white-space': 'pre-wrap'
                    }),
                    lineHeight = parseInt($textarea.css('line-height'), 10) || parseInt($textarea.css('font-size'), '10'),
                    minheight = parseInt($textarea.css('height'), 10) || lineHeight * 3,
                    maxheight = parseInt($textarea.css('max-height'), 10) || Number.MAX_VALUE,
                    goalheight = 0;
                if ($textarea.css('box-sizing') == 'border-box') {
                    minheight = minheight - parseInt($textarea.css('padding-top'), 10) - parseInt($textarea.css('padding-bottom'), 10);
                }

                $textarea.data('elastic', true);

                // Opera returns max-height of -1 if not set
                if (maxheight < 0) { maxheight = Number.MAX_VALUE; }

                // Append the twin to the DOM
                // We are going to meassure the height of this, not the textarea.
                $twin.appendTo($textarea.parent());

                // Copy the essential styles (mimics) from the textarea to the twin
                var i = mimics.length;
                while (i--) {
                    $twin.css(mimics[i].toString(), $textarea.css(mimics[i].toString()));
                }

                // Updates the width of the twin. (solution for textareas with widths in percent)
                function setTwinWidth() {
                    var curatedWidth = Math.floor(parseInt($textarea.width(), 10));
                    if ($twin.width() !== curatedWidth) {
                        $twin.css({ 'width': curatedWidth + 'px' });

                        // Update height of textarea
                        update(true);
                    }
                }

                // Sets a given height and overflow state on the textarea

                function setInlineStyles(height, overflow) {
                    var curratedHeight = Math.floor(parseInt(height, 10));
                    $textarea.css({ resize: 'none' });
                    if ($textarea.height() !== curratedHeight) {
                        $textarea.css({ 'height': curratedHeight + 'px', 'overflow': overflow });
                    }
                }

                // This function will update the height of the textarea if necessary
                function update(forced) {

                    // Get curated content from the textarea.
                    var textareaContent = $textarea.val().replace(/&/g, '&amp;').replace(/ {2}/g, '&nbsp;').replace(/<|>/g, '&gt;').replace(/\n/g, '<br />');

                    // Compare curated content with curated twin.
                    var twinContent = $twin.html().replace(/<br>/ig, '<br />');

                    if (forced || textareaContent + '&nbsp;' !== twinContent) {

                        // Add an extra white space so new rows are added when you are at the end of a row.
                        $twin.html(textareaContent + '&nbsp;');

                        // Change textarea height if twin plus the height of one line differs more than 3 pixel from textarea height
                        if (Math.abs($twin.height() + lineHeight - $textarea.height()) > 3) {
                            var goalheight = (textareaContent.length === 0) ? $twin.height() : $twin.height() + lineHeight;

                            if (goalheight >= maxheight) {
                                setInlineStyles(maxheight, 'auto');
                            } else if (goalheight <= minheight) {
                                setInlineStyles(minheight, 'hidden');
                            } else {
                                setInlineStyles(goalheight, 'hidden');
                            }

                        }

                    }

                }

                // Hide scrollbars
                $textarea.css({ 'overflow': 'hidden' });

                // Update textarea size on keyup, change, cut and paste
                $textarea.bind('keyup change cut paste', function () {
                    update();
                });

                // Update width of twin if browser or textarea is resized (solution for textareas with widths in percent)
                $(window).bind('resize', setTwinWidth);
                $textarea.bind('resize', setTwinWidth);
                $textarea.bind('update', update);

                // Compact textarea on blur
                /*$textarea.bind('blur', function () {
                    if ($twin.height() < maxheight) {
                        if ($twin.height() > minheight) {
                            $textarea.height($twin.height());
                        } else {
                            //$textarea.height(minheight);
                            $textarea.css('height', minheight);
                        }
                    }
                });*/

                // And this line is to catch the browser paste event
                $textarea.bind('input paste', function (e) { setTimeout(update, 250); });

                // Run update once when elastic is initialized
                update();

            });

        }
    });
})(jQuery);
;
function InitPostSimpleFormAsync(form, params) {
    var defaultOptions = {
        serverErrorMessage: "Сервер временно недоступен",
        notAuthtorizedMessage: "Ошибка доступа. Попробуйте обновить страницу",
        timeout: 10000
    };
    var options = $.extend({}, defaultOptions, params);
    RemoveErrors(form);
    ShowFormChildren(form, options);
    var submitting = false;
    form.unbind('submit');
    form.bind('submit', function () {
        if (submitting)
            return false;

        if (options.beforeSendCallback)
            options.beforeSendCallback(form);

        submitting = true;
        form.find("input[type=submit], button[type=submit]").attr("disabled", "disabled");
        RemoveErrors(form);

        if (options.validate && !options.validate(form)) {
            form.find("input[type=submit], button[type=submit]").removeAttr("disabled");
            submitting = false;
            return false;
        }

        var data = options.dataProvider
            ? options.dataProvider()
            : form.serializeArray();

        var url = options.url;
        if (!url)
            url = form.attr('action');

        var dataType = "json";
        var type = "POST";
        var contentType = "application/x-www-form-urlencoded; charset=utf-8";

        if (options.ajaxOnSubmitCallback) {
            options.ajaxOnSubmitCallback();
        }

        $.ajax({
            type: type,
            url: url,
            data: data,
            dataType: dataType,
            contentType: contentType,
            timeout: options.timeout,
            success: function (data) {
                RemoveErrors(form);
                var hasErrors = false;

                if (data.Errors) {
                    for (var k in data.Errors) {
                        hasErrors = true;
                        var input = form.find('[name="' + k + '"]');
                        //note хак выбираем инпуты, у которых нет нейма (отрезан textNote)
                        if (input.length == 0)
                            input = form.find('#' + k.replace(/\./gi, '_'));
                        input.addClass('input-validation-error');
                        var errorStr = "";
                        $.each(data.Errors[k], function (index, item) { errorStr += ' ' + item; });
                        AddFieldError(input.last(), errorStr)
                    }
                    if (data.Errors["Form"]) {
                        AddFormError(data.Errors["Form"][0]);
                    }
                }

                if (!hasErrors) {
                    if (!options.preventDefaultEvents) {
                        var relativeUrl = url.replace(/^(?:\/\/|[^\/]+)*\//, '');
                        $(window).trigger('pageEvent', ('event-' + (form.data('event') || form.data('event-name') || relativeUrl) + '-send'));
                    }

                    if (options.useDefaultSuccessMessageShowing !== false) {
                        ShowSuccessMessage(options.successMessage || data.Message, form);
                    }

                    if (options.clearTextInputsOnSuccess !== false) {
                        ClearTextInputs(form);
                    }

                    if (options.successCallback) {
                        options.successCallback(data, form);
                    }

                } else {
                    if (null == options.focusFirstErrorInput || options.focusFirstErrorInput) {
                        form.find('.input-validation-error:first').focus();
                    }
                    if (options.errorsShowedCallback) {
                        options.errorsShowedCallback(form, data);
                    }
                }

            },
            complete: function (jqXHR, textStatus) {
                var cancel = options.beforeCompleteCallback && options.beforeCompleteCallback(jqXHR, textStatus) === false;
                if (cancel)
                    return;

                form.find("input[type=submit], button[type=submit]").removeAttr("disabled");
                submitting = false;

                if (options.completeCallback)
                    options.completeCallback(jqXHR, textStatus);
            },
            error: function (jqXHR) {

                var isUnauthorized = jqXHR.status === 401;

                if (isUnauthorized && options.notAuthtorizedMessage) {
                    AddFormError(options.notAuthtorizedMessage);
                }

                if (!isUnauthorized && options.serverErrorMessage) {
                    AddFormError(options.serverErrorMessage);
                }

                if (options.errorCallback) {
                    options.errorCallback(data, form);
                }
            }
        });

        if (options.afterSendCallback)
            options.afterSendCallback(form);

        return false;
    });

    $(function () {
        var validator = form.data('validator');
        if (validator) {
            var settngs = validator.settings;
            var oldErrorPlacement = settngs.errorPlacement;
            settngs.errorPlacement = function (error, input) {
                var name = input.attr('name');
                $('[data-valmsg-for="' + name + '"]').remove();
                AddFieldError(input, error.text())
                oldErrorPlacement.call(form, error, input);
            };
        }
    });

    function AddFieldError(input, errorMessage) {
        var errorElement = GetErrorElement(input, errorMessage);
        if (options.errorPlacement) {
            options.errorPlacement(input, errorElement);
        } else {
            input.parent().append(errorElement);
        }
    }

    function GetErrorElement(input, errorMessage) {
        var fieldName = input.attr('name');
        return $('<span class="field-validation-error" data-valmsg-for="' + fieldName + '">' + errorMessage + '</span>');
    }

    function AddFormError(error) {
        var errorHtml = '<div class="form-validation-error"><span class = "field-validation-error">' + error + '</span></div>';
        if (options.formErrorPlacement) {
            options.formErrorPlacement(form, errorHtml, error);
            return;
        }

        if (options.errorAfterForm)
            form.append(errorHtml);
        else
            form.prepend(errorHtml);
    }

    //note Если на инпут повешано, что-то еще (например саджест), то могут возникнуть лишние запросы на сервер и др проблемы. Тк тут вызывается blur, для того, чтобы появилась серая подсказка (textNode)
    function ClearTextInputs(form) {
        if (options.clearTextInputs === undefined) {
            PostSimpleFormClearTextInputs(form);
        } else {
            options.clearTextInputs(form);
        }
    }

    function ShowFormChildren(form, options) {
        PostSimpleFormShowFormChildren(form, options);
    }

    function RemoveErrors(form) {
        if (options.removeErrors === undefined) {
            PostSimpleFormRemoveErrors(form);
        } else {
            options.removeErrors(form);
        }
    }

    function ShowSuccessMessage(message, form) {
        return PostSimpleFormShowSuccessMessage(message, form);
    }
}

function PostSimpleFormShowSuccessMessage(message, form) {
    var messageContainer = PostSimpleFormGetMessageContainer(form);
    form.children().hide();
    messageContainer.find('p').remove();
    if (message)
        messageContainer.html(message);
    messageContainer.show();
}

function PostSimpleFormClearTextInputs(form) {
    form.find("input[type=text], input[type=tel], input[type=email], textarea").each(PostSimpleFormClearInput);
}

function PostSimpleFormClearInput() {
    var domElement = this;
    var jqElement = $(domElement);
    jqElement.val(jqElement.attr('data-default-value'));
}

function PostSimpleFormRemoveErrors(form) {
    var inputs = form.find(":input");
    inputs.removeClass('input-validation-error');
    form.find(".field-validation-error").remove();
    form.find(".form-validation-error").remove();
    form.find("input[type=submit], button[type=submit]").removeAttr("disabled");
}

function PostSimpleFormShowFormChildren(form, options) {
    form.children().show();

    options = options || {};
    if (options.useDefaultSuccessMessageShowing !== false) {
        var messageContainer = PostSimpleFormGetMessageContainer(form);
        messageContainer.hide();
    }
}

function PostSimpleFormGetMessageContainer(form) {
    var messageContainer = form.find(".js-successMessage");
    if (messageContainer.length == 0)
        throw new Error('Ожидалось, что лайтбокс имеет класс js-successMessage');
    return messageContainer;
};
/* Simple JavaScript Inheritance
* By John Resig http://ejohn.org/
* MIT Licensed.
*/
// Inspired by base2 and Prototype
(function () {
    var initializing = false, fnTest = /xyz/.test(function () { xyz; }) ? /\b_super\b/ : /.*/;

    // The base Class implementation (does nothing)
    this.Class = function () { };

    // Create a new Class that inherits from this class
    Class.extend = function (prop) {
        var _super = this.prototype;

        // Instantiate a base class (but only create the instance,
        // don't run the init constructor)
        initializing = true;
        var prototype = new this();
        initializing = false;

        // Copy the properties over onto the new prototype
        for (var name in prop) {
            // Check if we're overwriting an existing function
            prototype[name] = typeof prop[name] == "function" &&
        typeof _super[name] == "function" && fnTest.test(prop[name]) ?
        (function (name, fn) {
            return function () {
                var tmp = this._super;

                // Add a new ._super() method that is the same method
                // but on the super-class
                this._super = _super[name];

                // The method only need to be bound temporarily, so we
                // remove it when we're done executing
                var ret = fn.apply(this, arguments);
                this._super = tmp;

                return ret;
            };
        })(name, prop[name]) :
        prop[name];
        }

        // The dummy class constructor
        function Class() {
            // All construction is actually done in the init method
            if (!initializing && this.init) {
                this.init.apply(this, arguments);
            }
            //checkAbstractMethodsImplemented.apply(this, this); //note немножко магии
        }

        // Populate our constructed prototype object
        Class.prototype = prototype;

        // Enforce the constructor to be what we expect
        Class.prototype.constructor = Class;

        // And make this class extendable
        Class.extend = arguments.callee;

        return Class;
    };
})();



//
var abstractMethod = function (funcName) {
    throw Error("Метод " + funcName + " помечен как абстрактный и не реализован.");
};

// todo реф может магию использовать тока в debug ?
var checkAbstractMethodsImplemented = function (context) {
    var errors = [];
    for (var m in context) {
        try {
            if (context[m] == abstractMethod)
                context[m](m);
        }
        catch (e) {
            errors.push(e);
        }
    }
    if (errors.length > 0)
        throw Error(errors.join(' '));
};
var Guid = Class.extend({
    _generatePart: function () {
        return Math.floor(
                Math.random() * 0x10000 /* 65536 */
            ).toString(16);
    },
    _generate: function () {
        return this._generatePart() + this._generatePart() + "-" +
            this._generatePart() + "-" +
                this._generatePart() + "-" +
                    this._generatePart() + "-" +
                        this._generatePart() + this._generatePart() + this._generatePart();
    },
    init: function () {
        this.value = this._generate();
    }
});

var UidHelper = Class.extend({
    generatePseudoGuid: function () {
        return new Guid().value;
    },
    generateByDateTime: function () {
        return (new Date().getTime() + "" + Math.floor(Math.random() * 1000000)).substr(0, 18);
    }
});
var Kontur = Kontur || {};

Kontur.Module = function (namespace, func, args) {

    var root = (function () { return this; })(),
        parts = namespace.split('.'),
        part;

    while (part = parts.shift()) {
        root = root[part] = root[part] || {};
    }

    return func.apply(root, args || []);
};
Kontur.Module("Kontur.Global", function() {
    this.get = function() {
        return (function() {
             return this;
        })();
    };
});
Kontur.Module("Kontur.Url.Theme", function($) {
    this.theme = function (path) {
        var themePath = $("body").data("theme-path") || "theme/";
        if (path.match("^/")) {
            themePath = "/" + themePath;
        }
        return themePath  + path;
    };
}, [jQuery]);
Kontur.Module('Kontur.UrlHelper', function (global) {
    var self = this,
        siteUrl;

    self.getSiteUrl = function() {
        return siteUrl;
    };

    self.setSiteUrl = function(newSiteUrl) {
        siteUrl = newSiteUrl;
    };

    self.addParameter = function (url, param, paramVal) {

        var indexOfHash = url.indexOf('#');
        var hash = indexOfHash === -1
            ? ''
            : url.substring(indexOfHash, url.length);

        if (indexOfHash !== -1) {
            url = url.substring(0, indexOfHash);
        }

        var newAdditionalUrl = "";
        var tempArray = url.split("?");
        var baseUrl = tempArray[0];
        var additionalUrl = tempArray[1];
        var temp = "";

        if (additionalUrl) {
            tempArray = additionalUrl.split("&");
            for (var i = 0; i < tempArray.length; i++) {
                if (tempArray[i].split('=')[0].toLowerCase() != param.toLowerCase()) {
                    newAdditionalUrl += temp + tempArray[i];
                    temp = "&";
                }
            }
        }

        var rowsTxt = temp + "" + param + "=" + paramVal;
        return baseUrl + "?" + newAdditionalUrl + rowsTxt + hash;
    }

    self.toAbsoluteUrl = function (baseUrl, localUrl) {
        var absoluteUrl = self.removeTrailingSlash(baseUrl) + '/' + self.trimSlashes(localUrl);
        return self.removeTrailingSlash(absoluteUrl);
    }

    self.removeTrailingSlash = function (url) {
        return url.replace(/\/+$/g, '');
    };

    self.trimSlashes = function (url) {
        return url.replace(/^[\/]+|[\/]+$/g, '');
    };

    self.removeParameters = function (url) {
        return url.replace(/\?.*$/g, '');
    };

    self.getQueryParams = function () {
        var window = global.get();

        return self.getParameters(window.location.href);
    };

    self.isRelative = function (url) {
        return startsWith(url, '/') && !startsWith(url, '//');
    }

    self.getPath = function (url) {
        return url.replace(/^(?:\/\/|[^\/]+)*\//, '/');
    }

    self.getParameters = function (url) {

        if (url.indexOf('?') === -1) {
            return {};
        }

        var indexOfHash = url.indexOf('#');
        if (indexOfHash !== -1) {
            url = url.substring(0, indexOfHash);
        }

        var parameters = {};
        var pairs = url.slice(url.indexOf('?') + 1).split('&');

        for (var i = 0; i < pairs.length; i++) {
            var pair = pairs[i].split('=');
            parameters[pair[0]] = typeof (pair[1]) == 'undefined' ? '' : pair[1];
        }

        return parameters;
    }

    function startsWith(str, prefix) {
        return str.lastIndexOf(prefix, 0) === 0;
    }

}, [Kontur.Global]);
/* Отслеживание событий */

Kontur.Module('Kontur.Counters.GoogleTagManager',
    function (global) {
        var window = global.get();

        this.sendEvent = function (eventName) {
            var dataLayer = window.dataLayer || [];
            dataLayer.push({ 'event': eventName });
        }

    }, [Kontur.Global]);

Kontur.Module('Kontur.Counters.GoogleAnalytics',
    function ($, global, gaDimensions) {
        var window = global.get(),
            defaultCategory = 'events';

        this.sendEvent = function (eventName, value, eventCategory, eventLabel) {
            var paramsArray = getAnalyticParamsArray(eventName, value, eventCategory, eventLabel);
            var gaParams = getGaParameters();
            gaParams.push(paramsArray);

            if (typeof window['ga'] == 'function') {
                var analyticParams = getAnalyticParamsJson(eventName, value, eventCategory, eventLabel);
                window.ga('send', analyticParams);
            }
        }

        this.sendPageView = function (page) {
            if (typeof window['ga'] == 'function') {
                window.ga('set', 'page', page);
                window.ga('send', 'pageview');
            } else {
                var gaq = getGaParameters();
                gaq.push(['_trackPageview', page]);
            }
        }

        this.setParameter = function (key, value) {
            if (!gaDimensions || typeof gaDimensions['getDimensions'] != 'function') return;
            var dimensionIndex = $.inArray(key, gaDimensions.getDimensions());
            if (dimensionIndex == -1) return;
            var ga = window.ga || (function () { window.console && window.console.log && window.console.log(arguments); });
            ga('set', 'dimension' + (dimensionIndex + 1), value);
        }

        function getGaParameters() {
            return (window._gaq = window._gaq || []);
        }

        function getAnalyticParamsArray(eventName, value, eventCategory, eventLabel) {
            var category = eventCategory || defaultCategory;
            var paramsArray = ['_trackEvent', category, eventName];
            if (eventLabel)
                paramsArray.push(eventLabel);
            if (value)
                paramsArray.push(value);
            return paramsArray;
        }

        function getAnalyticParamsJson(eventName, value, eventCategory, eventLabel) {
            var category = eventCategory || defaultCategory;
            var analyticParams = {
                'hitType': 'event', // Required.
                'eventCategory': category // Required.
            };
            if (eventName) {
                analyticParams.eventAction = eventName;
            }
            if (value) {
                analyticParams.eventValue = parseInt(value) || 0; // Value is a number.
            }
            if (eventLabel) {
                analyticParams.eventLabel = eventLabel;
            }
            return analyticParams;
        }
    },
    [jQuery, Kontur.Global, Kontur.GaDimensions]);

Kontur.Module('Kontur.Counters.YandexMetrika',
    function (global) {
        var window = global.get(),
            defaultCategory = 'events';

        this.sendEvent = function (eventName, value, eventCategory, eventLabel) {
            var analyticParams = getAnalyticParamsJson(null, value, eventCategory, eventLabel);
            var yaCounter = getYandexCounter();
            if (yaCounter) {
                yaCounter.reachGoal(eventName, analyticParams);
            }
            else {
                window.pageEvents = window.pageEvents || [];
                window.pageEvents.push(eventName);
            }
        }

        this.sendPageView = function (page) {
            var yaCounter = getYandexCounter();

            if (yaCounter) {
                yaCounter.hit(page);
            }
        }

        function getYandexCounter() {
            var yname = null;
            for (var name in window) {
                if (name.indexOf('yaCounter') == 0) {
                    yname = name;
                    break;
                }
            }
            return yname ? (getYandexCounter = function () {
                return window[yname];
            })() : null;
        }
        this.getYandexCounter = getYandexCounter;

        function getAnalyticParamsJson(eventName, value, eventCategory, eventLabel) {
            var category = eventCategory || defaultCategory;
            var analyticParams = {
                'hitType': 'event', // Required.
                'eventCategory': category // Required.
            };
            if (eventName) {
                analyticParams.eventAction = eventName;
            }
            if (value) {
                analyticParams.eventValue = parseInt(value) || 0; // Value is a number.
            }
            if (eventLabel) {
                analyticParams.eventLabel = eventLabel;
            }
            return analyticParams;
        }
    },
    [Kontur.Global]);

Kontur.Module('Kontur.Counters.LiveInternet',
    function ($, global) {
        var window = global.get();

        this.sendPageView = function (page, referrer) {
            var counter = getCurrentCounter();

            if (counter) {
                updateCounter(getBaseUrl(counter) + getRelativeUrl(page, referrer));
            }
        }

        function getCurrentCounter() {
            var elements = $('[src^="//counter.yadro.ru"]');

            return elements[0];
        }

        function getBaseUrl(counter) {
            var match = counter.src.match(/(\/\/counter.yadro.ru\/hit\?.*?)r/);

            return match[1];
        }

        function getRelativeUrl(page, referrer) {
            var origin = window.location.origin,
                screen = window.screen,
                document = window.document,
                referrerPart = 'r' + window.escape(referrer || document.referrer),
                screenPart = (typeof (screen) != 'undefined')
                    ? ';s' + screen.width + '*' + screen.height + '*' + (screen.colorDepth ? screen.colorDepth : screen.pixelDepth)
                    : '',
                urlPart = ';u' + window.escape(origin + page),
                randomPart = ';' + window.Math.random();

            return referrerPart + screenPart + urlPart + randomPart;
        }

        function updateCounter(source) {
            var image = window.document.createElement('img');

            image.src = source;
        }
    }, [jQuery, Kontur.Global]);

Kontur.Module("Kontur.Counters", function ($, global, gaDimensions, googleTagManager, googleAnalytics, yandexMetrika, liveInternet) {

    var me = this,
        initialized = false,
        window = global.get(),
        eventNameDecorator = null;

    me.registerPageView = function (page, referrer) {
        $(function () {
            googleAnalytics.sendPageView(page);
            yandexMetrika.sendPageView(page);
            liveInternet.sendPageView(page, referrer);

            if (window.console) {
                window.console.info('page view was registered: ' + page + ' (referrer: ' + referrer + ')');
            }
        });
    }

    me.setCustomParameter = function (key, value) {
        googleAnalytics.setParameter(key, value);
    };

    me.registerPageEvent = function (eventName, value, eventCategory, eventLabel) {
        $(function () {
            var cleanedEventName = cleanEventName(eventName);

            if (window.Kontur && window.Kontur.GoogleTagManagerStrictMode) {
                googleTagManager.sendEvent(cleanedEventName);
            } else {
                googleAnalytics.sendEvent(cleanedEventName, value, eventCategory, eventLabel);
                yandexMetrika.sendEvent(cleanedEventName, value, eventCategory, eventLabel);
            }

            if (window.console) {
                window.console.info('event was registred: ' + cleanedEventName);
            }
        });
    };

    me.setEventNameDecorator = function (decorator) {
        if (typeof decorator === "function") {
            eventNameDecorator = decorator;
        }
    };

    me.initialize = function () {
        if (!initialized) {
            window['loadScriptAsync'] = function (src) {
                var script = document.createElement('script');
                script.type = 'text/javascript';
                script.async = true;
                script.src = src;
                var firstScript = document.getElementsByTagName('script')[0];
                firstScript.parentNode.insertBefore(script, firstScript);
            };

            //fallback
            window.RegisterPageEvent = me.registerPageEvent;
            initialized = true;
        }
    };

    function cleanEventName(eventName) {
        var cleanName = eventName
            .replace(/[&=?#]/g, '')
            .replace(/(\/|-)+/g, '-')
            .replace(/^-+|-+$/g, '');

        return eventNameDecorator != null ? eventNameDecorator(cleanName) : cleanName;
    }
}, [jQuery, Kontur.Global, Kontur.GaDimensions, Kontur.Counters.GoogleTagManager, Kontur.Counters.GoogleAnalytics, Kontur.Counters.YandexMetrika, Kontur.Counters.LiveInternet]);

/* Отслеживание событий */

Kontur.Module("Kontur.PageEvents", function ($, global, counters) {
    var initialized = false;
    this.initialize = function () {
        var window = global.get();

        if (!initialized) {
            $(window).on('pageEvent', function (e, eventName) {
                counters.registerPageEvent(eventName);
            });

            if (!(window.Kontur && window.Kontur.GoogleTagManagerStrictMode)) {
                $(window.document).on('click', '[data-event-name]:not(form)', function (e) {
                    var target = $(e.currentTarget);
                    var eventName = target.data('event-name');
                    var eventValue = target.data('event-value');
                    var eventCategory = target.data('event-category');
                    var eventLabel = target.data('event-label');
                    counters.registerPageEvent(eventName, eventValue, eventCategory, eventLabel);
                });

                $(window.document).on('submit', 'form', function () {
                    var form = $(this),
                        eventName = form.data('event') || form.data('event-name') || form.attr('action');
                    var eventValue = form.data('event-value');
                    var eventCategory = form.data('event-category');
                    var eventLabel = form.data('event-label');
                    counters.registerPageEvent(('event-' + eventName + '-submit'), eventValue, eventCategory, eventLabel);
                });
            }

            initialized = true;
        }
    };
}, [jQuery, Kontur.Global, Kontur.Counters]);

Kontur.Counters.initialize();
Kontur.PageEvents.initialize();
jQuery.fn.preventDoubleSubmit = function () {
    $(this).on('submit', function (e) {
        var $form = $(this);

        if ($form.data('submitted') === true) {
            // Previously submitted - don't submit again
            e.preventDefault();
        } else if (!$form.valid || $form.valid()) {
            // Mark it so that the next submit can be ignored
            $form.data('submitted', true);
        }
    });

    // Keep chainability
    return this;
};
/*
 * cacheImage: a jQuery plugin
 *
 * cacheImage is a simple jQuery plugin for pre-caching images.  The
 * plugin can be used to eliminate flashes of unstyled content (FOUC) and
 * improve perceived page load time.  Callbacks for load, error and abort
 * events are provided.
 *
 * For usage and examples, visit:
 * http://github.com/alexrabarts/jquery-cacheimage
 *
 * Licensed under the MIT:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * Copyright (c) 2008 Stateless Systems (http://statelesssystems.com)
 *
 * @author   Alex Rabarts (alexrabarts -at- gmail -dawt- com)
 * @requires jQuery v1.2 or later
 * @version  0.2.1
 */

(function ($) {
  $.extend($, {
    cacheImage: function (src, options) {
      if (typeof src === 'object') {
        $.each(src, function () {
          $.cacheImage(String(this), options);
        });

        return;
      }

      var image = new Image();

      options = options || {};

      $.each(['load', 'error', 'abort'], function () { // Callbacks
        var e = String(this);
        if (typeof options[e] === 'function') { $(image).bind(e, options[e]); }

        if (typeof options.complete === 'function') {
          $(image).bind(e, options.complete);
        }
      });

      image.src = src;

      return image;
    }
  });

  $.extend($.fn, {
    cacheImage: function (options) {
      return this.each(function () {
        $.cacheImage(this.src, options);
      });
    }
  });
})(jQuery);
/*

Quicksand 1.3

Reorder and filter items with a nice shuffling animation.

Copyright (c) 2010 Jacek Galanciak (razorjack.net) and agilope.com
Big thanks for Piotr Petrus (riddle.pl) for deep code review and wonderful docs & demos.

Dual licensed under the MIT and GPL version 2 licenses.
http://github.com/jquery/jquery/blob/master/MIT-LICENSE.txt
http://github.com/jquery/jquery/blob/master/GPL-LICENSE.txt

Project site: http://razorjack.net/quicksand
Github site: http://github.com/razorjack/quicksand

 */

(function($) {
  $.fn.quicksand = function(collection, customOptions) {
    var options = {
      duration : 750,
      easing : 'swing',
      attribute : 'data-id',        // attribute to recognize same items within source and dest
      adjustHeight : 'auto',        // 'dynamic' animates height during shuffling (slow), 'auto' adjusts it
                                    // before or after the animation, false leaves height constant
      adjustWidth : 'auto',         // 'dynamic' animates width during shuffling (slow), 
                                    // 'auto' adjusts it before or after the animation, false leaves width constant
      useScaling : false,           // enable it if you're using scaling effect
      enhancement : function(c) {}, // Visual enhacement (eg. font replacement) function for cloned elements
      selector : '> *',
      atomic : false,
      dx : 0,
      dy : 0,
      maxWidth : 0,
      retainExisting : true         // disable if you want the collection of items to be replaced completely by incoming items.
    };
    $.extend(options, customOptions);

    // Got IE and want scaling effect? Kiss my ass.
    if ($.browser.msie || (typeof ($.fn.scale) == 'undefined')) {
      options.useScaling = false;
    }

    var callbackFunction;
    if (typeof (arguments[1]) == 'function') {
      callbackFunction = arguments[1];
    } else if (typeof (arguments[2] == 'function')) {
      callbackFunction = arguments[2];
    }

    return this.each(function(i) {
      var val;
      var animationQueue = []; // used to store all the animation params before starting the animation;
      // solves initial animation slowdowns
      var $collection;
      if (typeof(options.attribute) == 'function') {
        $collection = $(collection);
      } else {
        $collection = $(collection).filter('[' + options.attribute + ']').clone(); // destination (target) collection
      }
      var $sourceParent = $(this); // source, the visible container of source collection
      var sourceHeight = $(this).css('height'); // used to keep height and document flow during the animation
      var sourceWidth = $(this).css('width'); // used to keep  width and document flow during the animation
      var destHeight, destWidth;
      var adjustHeightOnCallback = false;
      var adjustWidthOnCallback = false;
      var offset = $($sourceParent).offset(); // offset of visible container, used in animation calculations
      var offsets = []; // coordinates of every source collection item
      var $source = $(this).find(options.selector); // source collection items
      var width = $($source).innerWidth(); // need for the responsive design

      // Replace the collection and quit if IE6
      if ($.browser.msie && parseInt($.browser.version, 10) < 7) {
        $sourceParent.html('').append($collection);
        return;
      }
      // Gets called when any animation is finished
      var postCallbackPerformed = 0; // prevents the function from being called more than one time
      var postCallback = function() {
        $(this).css('margin', '').css('position', '').css('top', '').css('left', '').css('opacity', '');
        if (!postCallbackPerformed) {
          postCallbackPerformed = 1;

          if (!options.atomic) {
            // hack: used to be: $sourceParent.html($dest.html()); 
            // put target HTML into visible source container  
            // but new webkit builds cause flickering when replacing the collections
            var $toDelete = $sourceParent.find(options.selector);
            if (!options.retainExisting) {
              $sourceParent.prepend($dest.find(options.selector));
              $toDelete.remove();
            } else {
              // Avoid replacing elements because we may have already altered items in significant
              // ways and it would be bad to have to do it again. (i.e. lazy load images) 
              // But $dest holds the correct ordering. So we must re-sequence items in $sourceParent to match.
              var $keepElements = $([]);
              $dest.find(options.selector).each(function(i) {
                var $matchedElement = $([]);
                if (typeof (options.attribute) == 'function') {
                  var val = options.attribute($(this));
                  $toDelete.each(function() {
                    if (options.attribute(this) == val) {
                      $matchedElement = $(this);
                      return false;
                    }
                  });
                } else {
                  $matchedElement = $toDelete.filter(
                    '[' + options.attribute + '="'+ 
                    $(this).attr(options.attribute) + '"]');
                }
                if ($matchedElement.length > 0) {
                  // There is a matching element in the $toDelete list and in $dest
                  // list, so make sure it is in the right location within $sourceParent
                  // and put it in the list of elements we need to not delete.
                  $keepElements = $keepElements.add($matchedElement);
                  if (i === 0) {
                    $sourceParent.prepend($matchedElement);
                  } else {
                    $matchedElement.insertAfter($sourceParent.find(options.selector).get(i - 1));
                  }
                }
              });
              // Remove whatever is remaining from the DOM
              $toDelete.not($keepElements).remove();
            }

            if (adjustHeightOnCallback) {
              $sourceParent.css('height', destHeight);
            }
            if (adjustWidthOnCallback) {
              $sourceParent.css('width', sourceWidth);
            }
          }
          options.enhancement($sourceParent); // Perform custom visual enhancements on a newly replaced collection
          if (typeof callbackFunction == 'function') {
            callbackFunction.call(this);
          }
        }

        if (false === options.adjustHeight) {
          $sourceParent.css('height', 'auto');
        }

        if (false === options.adjustWidth) {
          $sourceParent.css('width', 'auto');
        }
      };

      // Position: relative situations
      var $correctionParent = $sourceParent.offsetParent();
      var correctionOffset = $correctionParent.offset();
      if ($correctionParent.css('position') == 'relative') {
        if ($correctionParent.get(0).nodeName.toLowerCase() != 'body') {
          correctionOffset.top += (parseFloat($correctionParent.css('border-top-width')) || 0);
          correctionOffset.left += (parseFloat($correctionParent.css('border-left-width')) || 0);
        }
      } else {
        correctionOffset.top -= (parseFloat($correctionParent.css('border-top-width')) || 0);
        correctionOffset.left -= (parseFloat($correctionParent.css('border-left-width')) || 0);
        correctionOffset.top -= (parseFloat($correctionParent.css('margin-top')) || 0);
        correctionOffset.left -= (parseFloat($correctionParent.css('margin-left')) || 0);
      }

      // perform custom corrections from options (use when Quicksand fails to detect proper correction)
      if (isNaN(correctionOffset.left)) {
        correctionOffset.left = 0;
      }
      if (isNaN(correctionOffset.top)) {
        correctionOffset.top = 0;
      }

      correctionOffset.left -= options.dx;
      correctionOffset.top -= options.dy;

      // keeps nodes after source container, holding their position
      $sourceParent.css('height', $(this).height());
      $sourceParent.css('width', $(this).width());

      // get positions of source collections
      $source.each(function(i) {
        offsets[i] = $(this).offset();
      });

      // stops previous animations on source container
      $(this).stop();
      var dx = 0;
      var dy = 0;
      $source.each(function(i) {
        $(this).stop(); // stop animation of collection items
        var rawObj = $(this).get(0);
        if (rawObj.style.position == 'absolute') {
          dx = -options.dx;
          dy = -options.dy;
        } else {
          dx = options.dx;
          dy = options.dy;
        }

        rawObj.style.position = 'absolute';
        rawObj.style.margin = '0';

        if (!options.adjustWidth) {
          rawObj.style.width = (width + 'px'); // sets the width to the current element
          // with even if it has been changed
          // by a responsive design
        }

        rawObj.style.top = (offsets[i].top- parseFloat(rawObj.style.marginTop) - correctionOffset.top + dy) + 'px';
        rawObj.style.left = (offsets[i].left- parseFloat(rawObj.style.marginLeft) - correctionOffset.left + dx) + 'px';

        if (options.maxWidth > 0 && offsets[i].left > options.maxWidth) {
          rawObj.style.display = 'none';
        }
      });

      // create temporary container with destination collection
      var $dest = $($sourceParent).clone();
      var rawDest = $dest.get(0);
      rawDest.innerHTML = '';
      rawDest.setAttribute('id', '');
      rawDest.style.height = 'auto';
      rawDest.style.width = $sourceParent.width() + 'px';
      $dest.append($collection);
      // Inserts node into HTML. Note that the node is under visible source container in the exactly same position
      // The browser render all the items without showing them (opacity: 0.0) No offset calculations are needed, 
      // the browser just extracts position from underlayered destination items and sets animation to destination positions.
      $dest.insertBefore($sourceParent);
      $dest.css('opacity', 0.0);
      rawDest.style.zIndex = -1;

      rawDest.style.margin = '0';
      rawDest.style.position = 'absolute';
      rawDest.style.top = offset.top - correctionOffset.top + 'px';
      rawDest.style.left = offset.left - correctionOffset.left + 'px';

      if (options.adjustHeight === 'dynamic') {
        // If destination container has different height than source container the height can be animated,
        // adjusting it to destination height
        $sourceParent.animate({ height : $dest.height() }, options.duration, options.easing);
      } else if (options.adjustHeight === 'auto') {
        destHeight = $dest.height();
        if (parseFloat(sourceHeight) < parseFloat(destHeight)) {
          // Adjust the height now so that the items don't move out of the container
          $sourceParent.css('height', destHeight);
        } else {
          // Adjust later, on callback
          adjustHeightOnCallback = true;
        }
      }

      if (options.adjustWidth === 'dynamic') {
        // If destination container has different width than source container the width can be animated, 
        // adjusting it to destination width
        $sourceParent.animate({ width : $dest.width() }, options.duration, options.easing);
      } else if (options.adjustWidth === 'auto') {
        destWidth = $dest.width();
        if (parseFloat(sourceWidth) < parseFloat(destWidth)) {
          // Adjust the height now so that the items don't move out of the container
          $sourceParent.css('width', destWidth);
        } else {
          // Adjust later, on callback
          adjustWidthOnCallback = true;
        }
      }

      // Now it's time to do shuffling animation. First of all, we need to identify same elements within
      // source and destination collections
      $source.each(function(i) {
        var destElement = [];
        if (typeof (options.attribute) == 'function') {
          val = options.attribute($(this));
          $collection.each(function() {
            if (options.attribute(this) == val) {
              destElement = $(this);
              return false;
            }
          });
        } else {
          destElement = $collection.filter('[' + options.attribute + '="' + $(this).attr(options.attribute) + '"]');
        }
        if (destElement.length) {
          // The item is both in source and destination collections. It it's under different position, let's move it
          if (!options.useScaling) {
            animationQueue.push({
              element : $(this), dest : destElement,
              style : {
                top : $(this).offset().top,
                left : $(this).offset().left,
                opacity : ""
              },
              animation : {
                top : destElement.offset().top - correctionOffset.top,
                left : destElement.offset().left - correctionOffset.left,
                opacity : 1.0
              }
            });
          } else {
            animationQueue.push({
              element : $(this), dest : destElement,
              style : {
                top : $(this).offset().top,
                left : $(this).offset().left,
                opacity : ""
              },
              animation : {
                top : destElement.offset().top - correctionOffset.top,
                left : destElement.offset().left - correctionOffset.left,
                opacity : 1.0,
                scale : '1.0'
              }
            });
          }
        } else {
          // The item from source collection is not present in destination collections.  Let's remove it
          if (!options.useScaling) {
            animationQueue.push({
              element : $(this),
              style : {
                top : $(this).offset().top,
                left : $(this).offset().left,
                opacity : ""
              },
              animation : {
                opacity : '0.0'
              }
            });
          } else {
            animationQueue.push({
              element : $(this),
              animation : {
                opacity : '0.0',
                style : {
                  top : $(this).offset().top,
                  left : $(this).offset().left,
                  opacity : ""
                },
                scale : '0.0'
              }
            });
          }
        }
      });

      $collection.each(function(i) {
        // Grab all items from target collection not present in visible source collection
        var sourceElement = [];
        var destElement = [];
        if (typeof (options.attribute) == 'function') {
          val = options.attribute($(this));
          $source.each(function() {
            if (options.attribute(this) == val) {
              sourceElement = $(this);
              return false;
            }
          });

          $collection.each(function() {
            if (options.attribute(this) == val) {
              destElement = $(this);
              return false;
            }
          });
        } else {
          sourceElement = $source.filter('[' + options.attribute + '="' + $(this).attr(options.attribute) + '"]');
          destElement = $collection.filter('[' + options.attribute + '="' + $(this).attr(options.attribute) + '"]');
        }

        var animationOptions;
        if (sourceElement.length === 0 && destElement.length > 0) {

          // No such element in source collection...
          if (!options.useScaling) {
            animationOptions = {opacity : '1.0'};
          } else {
            animationOptions = {opacity : '1.0', scale : '1.0'};
          }

          // Let's create it
          var d = destElement.clone();
          var rawDestElement = d.get(0);
          rawDestElement.style.position = 'absolute';
          rawDestElement.style.margin = '0';

          if (!options.adjustWidth) {
            // sets the width to the current element with even if it has been changed by a responsive design
            rawDestElement.style.width = width + 'px'; 
          }

          rawDestElement.style.top = destElement.offset().top - correctionOffset.top + 'px';
          rawDestElement.style.left = destElement.offset().left - correctionOffset.left + 'px';

          d.css('opacity', 0.0); // IE

          if (options.useScaling) {
            d.css('transform', 'scale(0.0)');
          }
          d.appendTo($sourceParent);

          if (options.maxWidth === 0 || destElement.offset().left < options.maxWidth) {
            animationQueue.push({element : $(d), dest : destElement,animation : animationOptions});
          }
        }
      });

      $dest.remove();
      if (!options.atomic) {
        options.enhancement($sourceParent); // Perform custom visual enhancements during the animation
        for (i = 0; i < animationQueue.length; i++) {
          animationQueue[i].element.animate(animationQueue[i].animation, options.duration, options.easing, postCallback);
        }
      } else {
        $toDelete = $sourceParent.find(options.selector);
        $sourceParent.prepend($dest.find(options.selector));
        for (i = 0; i < animationQueue.length; i++) {
          if (animationQueue[i].dest && animationQueue[i].style) {
            var destElement = animationQueue[i].dest;
            var destOffset = destElement.offset();

            destElement.css({
              position : 'relative',
              top : (animationQueue[i].style.top - destOffset.top),
              left : (animationQueue[i].style.left - destOffset.left)
            });

            destElement.animate({top : "0", left : "0"}, 
                                options.duration, 
                                options.easing, 
                                postCallback);
          } else {
            animationQueue[i].element.animate(animationQueue[i].animation, 
                                              options.duration, 
                                              options.easing,
                                              postCallback);
          }
        }
        $toDelete.remove();
      }
    });
  };
})(jQuery);
;
/*! Copyright (c) 2011 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 * Thanks to: Seamus Leahy for adding deltaX and deltaY
 *
 * Version: 3.0.6
 * 
 * Requires: 1.2.2+
 */
(function(a){function d(b){var c=b||window.event,d=[].slice.call(arguments,1),e=0,f=!0,g=0,h=0;return b=a.event.fix(c),b.type="mousewheel",c.wheelDelta&&(e=c.wheelDelta/120),c.detail&&(e=-c.detail/3),h=e,c.axis!==undefined&&c.axis===c.HORIZONTAL_AXIS&&(h=0,g=-1*e),c.wheelDeltaY!==undefined&&(h=c.wheelDeltaY/120),c.wheelDeltaX!==undefined&&(g=-1*c.wheelDeltaX/120),d.unshift(b,e,g,h),(a.event.dispatch||a.event.handle).apply(this,d)}var b=["DOMMouseScroll","mousewheel"];if(a.event.fixHooks)for(var c=b.length;c;)a.event.fixHooks[b[--c]]=a.event.mouseHooks;a.event.special.mousewheel={setup:function(){if(this.addEventListener)for(var a=b.length;a;)this.addEventListener(b[--a],d,!1);else this.onmousewheel=d},teardown:function(){if(this.removeEventListener)for(var a=b.length;a;)this.removeEventListener(b[--a],d,!1);else this.onmousewheel=null}},a.fn.extend({mousewheel:function(a){return a?this.bind("mousewheel",a):this.trigger("mousewheel")},unmousewheel:function(a){return this.unbind("mousewheel",a)}})})(jQuery)
;
jQuery.cookie = function (name, value, options) {
    if (typeof value != 'undefined') { // name and value given, set cookie
        options = options || {};
        if (value === null) {
            value = '';
            options.expires = -1;
        }
        var expires = '';
        if (options.expires && (typeof options.expires == 'number' || options.expires.toUTCString)) {
            var date;
            if (typeof options.expires == 'number') {
                date = new Date();
                date.setTime(date.getTime() + (options.expires * 24 * 60 * 60 * 1000));
            } else {
                date = options.expires;
            }
            expires = '; expires=' + date.toUTCString(); // use expires attribute, max-age is not supported by IE
        }
        // CAUTION: Needed to parenthesize options.path and options.domain
        // in the following expressions, otherwise they evaluate to undefined
        // in the packed version for some reason...
        var path = options.path ? '; path=' + (options.path) : '';
        var domain = options.domain ? '; domain=' + (options.domain) : '';
        var secure = options.secure ? '; secure' : '';
        document.cookie = [name, '=', encodeURIComponent(value), expires, path, domain, secure].join('');
    } else { // only name given, get cookie
        var cookieValue = null;
        if (document.cookie && document.cookie != '') {
            var cookies = document.cookie.split(';');
            for (var i = 0; i < cookies.length; i++) {
                var cookie = jQuery.trim(cookies[i]);
                // Does this cookie string begin with the name we want?
                if (cookie.substring(0, name.length + 1) == (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
};
/* jQuery SelectBox - https://github.com/claviska/jquery-selectBox */
if(jQuery)(function($){$.extend($.fn,{selectBox:function(method,data){var typeTimer,typeSearch='',isMac=navigator.platform.match(/mac/i);var init=function(select,data){var options;if(navigator.userAgent.match(/iPad|iPhone|Android|IEMobile|BlackBerry/i))return false;if(select.tagName.toLowerCase()!=='select')return false;select=$(select);if(select.data('selectBox-control'))return false;var control=$('<a class="selectBox" />'),inline=select.attr('multiple')||parseInt(select.attr('size'))>1;var settings=data||{};control.width(select.outerWidth()).addClass(select.attr('class')).attr('title',select.attr('title')||'').attr('tabindex',parseInt(select.attr('tabindex'))).css('display','inline-block').bind('focus.selectBox',function(){if(this!==document.activeElement&&document.body!==document.activeElement)$(document.activeElement).blur();if(control.hasClass('selectBox-active'))return;control.addClass('selectBox-active');select.trigger('focus')}).bind('blur.selectBox',function(){if(!control.hasClass('selectBox-active'))return;control.removeClass('selectBox-active');select.trigger('blur')});if(!$(window).data('selectBox-bindings')){$(window).data('selectBox-bindings',true).bind('scroll.selectBox',hideMenus).bind('resize.selectBox',hideMenus)}if(select.attr('disabled'))control.addClass('selectBox-disabled');select.bind('click.selectBox',function(event){control.focus();event.preventDefault()});if(inline){options=getOptions(select,'inline');control.append(options).data('selectBox-options',options).addClass('selectBox-inline selectBox-menuShowing').bind('keydown.selectBox',function(event){handleKeyDown(select,event)}).bind('keypress.selectBox',function(event){handleKeyPress(select,event)}).bind('mousedown.selectBox',function(event){if($(event.target).is('A.selectBox-inline'))event.preventDefault();if(!control.hasClass('selectBox-focus'))control.focus()}).insertAfter(select);if(!select[0].style.height){var size=select.attr('size')?parseInt(select.attr('size')):5;var tmp=control.clone().removeAttr('id').css({position:'absolute',top:'-9999em'}).show().appendTo('body');tmp.find('.selectBox-options').html('<li><a>\u00A0</a></li>');var optionHeight=parseInt(tmp.find('.selectBox-options A:first').html('&nbsp;').outerHeight());tmp.remove();control.height(optionHeight*size)}disableSelection(control)}else{var label=$('<span class="selectBox-label" />'),arrow=$('<span class="selectBox-arrow" />');label.attr('class',getLabelClass(select)).text(getLabelText(select));options=getOptions(select,'dropdown');options.appendTo('BODY');control.data('selectBox-options',options).addClass('selectBox-dropdown').append(label).append(arrow).bind('mousedown.selectBox',function(event){if(control.hasClass('selectBox-menuShowing')){hideMenus()}else{event.stopPropagation();options.data('selectBox-down-at-x',event.screenX).data('selectBox-down-at-y',event.screenY);showMenu(select)}}).bind('keydown.selectBox',function(event){handleKeyDown(select,event)}).bind('keypress.selectBox',function(event){handleKeyPress(select,event)}).bind('open.selectBox',function(event,triggerData){if(triggerData&&triggerData._selectBox===true)return;showMenu(select)}).bind('close.selectBox',function(event,triggerData){if(triggerData&&triggerData._selectBox===true)return;hideMenus()}).insertAfter(select);var labelWidth=control.width()-arrow.outerWidth()-parseInt(label.css('paddingLeft'))-parseInt(label.css('paddingLeft'));label.width(labelWidth);disableSelection(control)}select.addClass('selectBox').data('selectBox-control',control).data('selectBox-settings',settings).hide()};var getOptions=function(select,type){var options;var _getOptions=function(select,options){select.children('OPTION, OPTGROUP').each(function(){if($(this).is('OPTION')){if($(this).length>0){generateOptions($(this),options)}else{options.append('<li>\u00A0</li>')}}else{var optgroup=$('<li class="selectBox-optgroup" />');optgroup.text($(this).attr('label'));options.append(optgroup);options=_getOptions($(this),options)}});return options};switch(type){case'inline':options=$('<ul class="selectBox-options" />');options=_getOptions(select,options);options.find('A').bind('mouseover.selectBox',function(event){addHover(select,$(this).parent())}).bind('mouseout.selectBox',function(event){removeHover(select,$(this).parent())}).bind('mousedown.selectBox',function(event){event.preventDefault();if(!select.selectBox('control').hasClass('selectBox-active'))select.selectBox('control').focus()}).bind('mouseup.selectBox',function(event){hideMenus();selectOption(select,$(this).parent(),event)});disableSelection(options);return options;case'dropdown':options=$('<ul class="selectBox-dropdown-menu selectBox-options" />');options=_getOptions(select,options);options.data('selectBox-select',select).css('display','none').appendTo('BODY').find('A').bind('mousedown.selectBox',function(event){event.preventDefault();if(event.screenX===options.data('selectBox-down-at-x')&&event.screenY===options.data('selectBox-down-at-y')){options.removeData('selectBox-down-at-x').removeData('selectBox-down-at-y');hideMenus()}}).bind('mouseup.selectBox',function(event){if(event.screenX===options.data('selectBox-down-at-x')&&event.screenY===options.data('selectBox-down-at-y')){return}else{options.removeData('selectBox-down-at-x').removeData('selectBox-down-at-y')}selectOption(select,$(this).parent());hideMenus()}).bind('mouseover.selectBox',function(event){addHover(select,$(this).parent())}).bind('mouseout.selectBox',function(event){removeHover(select,$(this).parent())});var classes=select.attr('class')||'';if(classes!==''){classes=classes.split(' ');for(var i in classes)options.addClass(classes[i]+'-selectBox-dropdown-menu')}disableSelection(options);return options}};var getLabelClass=function(select){var selected=$(select).find('OPTION:selected');return('selectBox-label '+(selected.attr('class')||'')).replace(/\s+$/,'')};var getLabelText=function(select){var selected=$(select).find('OPTION:selected');return selected.text()||'\u00A0'};var setLabel=function(select){select=$(select);var control=select.data('selectBox-control');if(!control)return;control.find('.selectBox-label').attr('class',getLabelClass(select)).text(getLabelText(select))};var destroy=function(select){select=$(select);var control=select.data('selectBox-control');if(!control)return;var options=control.data('selectBox-options');options.remove();control.remove();select.removeClass('selectBox').removeData('selectBox-control').data('selectBox-control',null).removeData('selectBox-settings').data('selectBox-settings',null).show()};var refresh=function(select){select=$(select);select.selectBox('options',select.html())};var showMenu=function(select){select=$(select);var control=select.data('selectBox-control'),settings=select.data('selectBox-settings'),options=control.data('selectBox-options');if(control.hasClass('selectBox-disabled'))return false;hideMenus();var borderBottomWidth=isNaN(control.css('borderBottomWidth'))?0:parseInt(control.css('borderBottomWidth'));options.width(control.innerWidth()).css({top:control.offset().top+control.outerHeight()-borderBottomWidth,left:control.offset().left});if(select.triggerHandler('beforeopen'))return false;var dispatchOpenEvent=function(){select.triggerHandler('open',{_selectBox:true})};switch(settings.menuTransition){case'fade':options.fadeIn(settings.menuSpeed,dispatchOpenEvent);break;case'slide':options.slideDown(settings.menuSpeed,dispatchOpenEvent);break;default:options.show(settings.menuSpeed,dispatchOpenEvent);break}if(!settings.menuSpeed)dispatchOpenEvent();var li=options.find('.selectBox-selected:first');keepOptionInView(select,li,true);addHover(select,li);control.addClass('selectBox-menuShowing');$(document).bind('mousedown.selectBox',function(event){if($(event.target).parents().andSelf().hasClass('selectBox-options'))return;hideMenus()})};var hideMenus=function(){if($(".selectBox-dropdown-menu:visible").length===0)return;$(document).unbind('mousedown.selectBox');$(".selectBox-dropdown-menu").each(function(){var options=$(this),select=options.data('selectBox-select'),control=select.data('selectBox-control'),settings=select.data('selectBox-settings');if(select.triggerHandler('beforeclose'))return false;var dispatchCloseEvent=function(){select.triggerHandler('close',{_selectBox:true})};if(settings){switch(settings.menuTransition){case'fade':options.fadeOut(settings.menuSpeed,dispatchCloseEvent);break;case'slide':options.slideUp(settings.menuSpeed,dispatchCloseEvent);break;default:options.hide(settings.menuSpeed,dispatchCloseEvent);break}if(!settings.menuSpeed)dispatchCloseEvent();control.removeClass('selectBox-menuShowing')}else{$(this).hide();$(this).triggerHandler('close',{_selectBox:true});$(this).removeClass('selectBox-menuShowing')}})};var selectOption=function(select,li,event){select=$(select);li=$(li);var control=select.data('selectBox-control'),settings=select.data('selectBox-settings');if(control.hasClass('selectBox-disabled'))return false;if(li.length===0||li.hasClass('selectBox-disabled'))return false;if(select.attr('multiple')){if(event.shiftKey&&control.data('selectBox-last-selected')){li.toggleClass('selectBox-selected');var affectedOptions;if(li.index()>control.data('selectBox-last-selected').index()){affectedOptions=li.siblings().slice(control.data('selectBox-last-selected').index(),li.index())}else{affectedOptions=li.siblings().slice(li.index(),control.data('selectBox-last-selected').index())}affectedOptions=affectedOptions.not('.selectBox-optgroup, .selectBox-disabled');if(li.hasClass('selectBox-selected')){affectedOptions.addClass('selectBox-selected')}else{affectedOptions.removeClass('selectBox-selected')}}else if((isMac&&event.metaKey)||(!isMac&&event.ctrlKey)){li.toggleClass('selectBox-selected')}else{li.siblings().removeClass('selectBox-selected');li.addClass('selectBox-selected')}}else{li.siblings().removeClass('selectBox-selected');li.addClass('selectBox-selected')}if(control.hasClass('selectBox-dropdown')){control.find('.selectBox-label').text(li.text())}var i=0,selection=[];if(select.attr('multiple')){control.find('.selectBox-selected A').each(function(){selection[i++]=$(this).attr('rel')})}else{selection=li.find('A').attr('rel')}control.data('selectBox-last-selected',li);if(select.val()!==selection){select.val(selection);setLabel(select);select.trigger('change')}return true};var addHover=function(select,li){select=$(select);li=$(li);var control=select.data('selectBox-control'),options=control.data('selectBox-options');options.find('.selectBox-hover').removeClass('selectBox-hover');li.addClass('selectBox-hover')};var removeHover=function(select,li){select=$(select);li=$(li);var control=select.data('selectBox-control'),options=control.data('selectBox-options');options.find('.selectBox-hover').removeClass('selectBox-hover')};var keepOptionInView=function(select,li,center){if(!li||li.length===0)return;select=$(select);var control=select.data('selectBox-control'),options=control.data('selectBox-options'),scrollBox=control.hasClass('selectBox-dropdown')?options:options.parent(),top=parseInt(li.offset().top-scrollBox.position().top),bottom=parseInt(top+li.outerHeight());if(center){scrollBox.scrollTop(li.offset().top-scrollBox.offset().top+scrollBox.scrollTop()-(scrollBox.height()/2))}else{if(top<0){scrollBox.scrollTop(li.offset().top-scrollBox.offset().top+scrollBox.scrollTop())}if(bottom>scrollBox.height()){scrollBox.scrollTop((li.offset().top+li.outerHeight())-scrollBox.offset().top+scrollBox.scrollTop()-scrollBox.height())}}};var handleKeyDown=function(select,event){select=$(select);var control=select.data('selectBox-control'),options=control.data('selectBox-options'),settings=select.data('selectBox-settings'),totalOptions=0,i=0;if(control.hasClass('selectBox-disabled'))return;switch(event.keyCode){case 8:event.preventDefault();typeSearch='';break;case 9:case 27:hideMenus();removeHover(select);break;case 13:if(control.hasClass('selectBox-menuShowing')){selectOption(select,options.find('LI.selectBox-hover:first'),event);if(control.hasClass('selectBox-dropdown'))hideMenus()}else{showMenu(select)}break;case 38:case 37:event.preventDefault();if(control.hasClass('selectBox-menuShowing')){var prev=options.find('.selectBox-hover').prev('LI');totalOptions=options.find('LI:not(.selectBox-optgroup)').length;i=0;while(prev.length===0||prev.hasClass('selectBox-disabled')||prev.hasClass('selectBox-optgroup')){prev=prev.prev('LI');if(prev.length===0){if(settings.loopOptions){prev=options.find('LI:last')}else{prev=options.find('LI:first')}}if(++i>=totalOptions)break}addHover(select,prev);selectOption(select,prev,event);keepOptionInView(select,prev)}else{showMenu(select)}break;case 40:case 39:event.preventDefault();if(control.hasClass('selectBox-menuShowing')){var next=options.find('.selectBox-hover').next('LI');totalOptions=options.find('LI:not(.selectBox-optgroup)').length;i=0;while(next.length===0||next.hasClass('selectBox-disabled')||next.hasClass('selectBox-optgroup')){next=next.next('LI');if(next.length===0){if(settings.loopOptions){next=options.find('LI:first')}else{next=options.find('LI:last')}}if(++i>=totalOptions)break}addHover(select,next);selectOption(select,next,event);keepOptionInView(select,next)}else{showMenu(select)}break}};var handleKeyPress=function(select,event){select=$(select);var control=select.data('selectBox-control'),options=control.data('selectBox-options');if(control.hasClass('selectBox-disabled'))return;switch(event.keyCode){case 9:case 27:case 13:case 38:case 37:case 40:case 39:break;default:if(!control.hasClass('selectBox-menuShowing'))showMenu(select);event.preventDefault();clearTimeout(typeTimer);typeSearch+=String.fromCharCode(event.charCode||event.keyCode);options.find('A').each(function(){if($(this).text().substr(0,typeSearch.length).toLowerCase()===typeSearch.toLowerCase()){addHover(select,$(this).parent());keepOptionInView(select,$(this).parent());return false}});typeTimer=setTimeout(function(){typeSearch=''},1000);break}};var enable=function(select){select=$(select);select.attr('disabled',false);var control=select.data('selectBox-control');if(!control)return;control.removeClass('selectBox-disabled')};var disable=function(select){select=$(select);select.attr('disabled',true);var control=select.data('selectBox-control');if(!control)return;control.addClass('selectBox-disabled')};var setValue=function(select,value){select=$(select);select.val(value);value=select.val();if(value===null){value=select.children().first().val();select.val(value)}var control=select.data('selectBox-control');if(!control)return;var settings=select.data('selectBox-settings'),options=control.data('selectBox-options');setLabel(select);options.find('.selectBox-selected').removeClass('selectBox-selected');options.find('A').each(function(){if(typeof(value)==='object'){for(var i=0;i<value.length;i++){if($(this).attr('rel')==value[i]){$(this).parent().addClass('selectBox-selected')}}}else{if($(this).attr('rel')==value){$(this).parent().addClass('selectBox-selected')}}});if(settings.change)settings.change.call(select)};var setOptions=function(select,options){select=$(select);var control=select.data('selectBox-control'),settings=select.data('selectBox-settings');switch(typeof(data)){case'string':select.html(data);break;case'object':select.html('');for(var i in data){if(data[i]===null)continue;if(typeof(data[i])==='object'){var optgroup=$('<optgroup label="'+i+'" />');for(var j in data[i]){optgroup.append('<option value="'+j+'">'+data[i][j]+'</option>')}select.append(optgroup)}else{var option=$('<option value="'+i+'">'+data[i]+'</option>');select.append(option)}}break}if(!control)return;control.data('selectBox-options').remove();var type=control.hasClass('selectBox-dropdown')?'dropdown':'inline';options=getOptions(select,type);control.data('selectBox-options',options);switch(type){case'inline':control.append(options);break;case'dropdown':setLabel(select);$("BODY").append(options);break}};var disableSelection=function(selector){$(selector).css('MozUserSelect','none').bind('selectstart',function(event){event.preventDefault()})};var generateOptions=function(self,options){var li=$('<li />'),a=$('<a />');li.addClass(self.attr('class'));li.data(self.data());a.attr('rel',self.val()).text(self.text());li.append(a);if(self.attr('disabled'))li.addClass('selectBox-disabled');if(self.attr('selected'))li.addClass('selectBox-selected');options.append(li)};switch(method){case'control':return $(this).data('selectBox-control');case'settings':if(!data)return $(this).data('selectBox-settings');$(this).each(function(){$(this).data('selectBox-settings',$.extend(true,$(this).data('selectBox-settings'),data))});break;case'options':if(data===undefined)return $(this).data('selectBox-control').data('selectBox-options');$(this).each(function(){setOptions(this,data)});break;case'value':if(data===undefined)return $(this).val();$(this).each(function(){setValue(this,data)});break;case'refresh':$(this).each(function(){refresh(this)});break;case'enable':$(this).each(function(){enable(this)});break;case'disable':$(this).each(function(){disable(this)});break;case'destroy':$(this).each(function(){destroy(this)});break;default:$(this).each(function(){init(this,method)});break}return $(this)}})})(jQuery);
var Kontur = Kontur || {};
Kontur.ItemsPreviewControl = (function ($) {
    'use strict';

    var defaultOptions = {
        contextSelector: '.videoList'
    },
        init,
        bindEvents,
        onShowFullClicking,
        onFullItemCloseClicking,
        checkClassActive,
        openItem,
        openItemById,
        isOpened,
        module = function () {
            init.apply(this, arguments);
        };

    init = function (params) {
        var options = this.options = $.extend({}, defaultOptions, params);
        this.context = $(options.contextSelector);

        bindEvents.call(this);
    };

    bindEvents = function () {
        this.context.on('click', '[data-showFull]', $.proxy(onShowFullClicking, this));
        this.context.on('click', '[data-action="close"]', $.proxy(onFullItemCloseClicking, this));
    };

    onShowFullClicking = function (e) {
        var target = $(e.currentTarget),
            id = target.data('item-id');
        openItem.call(this, id, target);
        checkClassActive(target);
        
        e.preventDefault();
    };
    
    checkClassActive = function (target) {
        if (target.hasClass('active')) {
            $('[data-showFull]').removeClass('active');
        } else {
            $('[data-showFull]').removeClass('active');
            target.addClass('active');
        }
    };
    
    openItemById = function (id) {
        var item = $('[data-showFull][data-item-id="' + id + '"]');
        openItem.call(this, id, item);
        checkClassActive(item);
    };

    openItem = function (id, item) {
        var extendedBlock = $('[dataExtendedItem][data-item-id="' + id + '"]', this.context),
            extendedBlockIsVisible = extendedBlock.is(':visible');

        $('[dataExtendedItem]', this.context).slideUp('middle');

        if (extendedBlockIsVisible) {
            extendedBlock.slideUp('middle');
            $('html, body').animate({ scrollTop: item.offset().top - 10 }, 'middle');
        } else {
            extendedBlock.slideDown('middle', function() {
                $('html, body').animate({ scrollTop: item.offset().top - 10 }, 'middle');
            });
            $(this).trigger('ItemOpened', [id]);
        }
    };

    isOpened = function (id) {
        var extendedBlock = $('[dataExtendedItem][data-item-id="' + id + '"]', this.context);

        return extendedBlock.is(':visible');
    };

    onFullItemCloseClicking = function (e) {
        $('[dataExtendedItem]', this.context).slideUp('middle');
        e.preventDefault();
        $('[data-showFull]').removeClass('active');
    };

    module.prototype.openItem = function (id) {
        openItemById.call(this, id);
    };

    module.prototype.isOpened = function (id) {
        return isOpened.call(this, id);
    };

    return module;
})(jQuery);
var Kontur = Kontur || {};
Kontur.User = (function ($) {
    return {        
        isAuthenticated: function () {
            return true === $('body').data('authenticated');
        }
    };
}(jQuery));
Kontur.Module('Kontur.Cookie', function (document) {

    this.setCookie = function (key, value, expireDays, path, domain) {
        var cookie = key + '=' + value;
        if (undefined !== expireDays) {
            var date = new Date();
            date.setTime(date.getTime() + (expireDays * 24 * 60 * 60 * 1000));
            cookie = cookie + ';expires=' + date.toUTCString();
        }

        if (path === undefined) {
            cookie = cookie + ';path=/';
        } else {
            cookie = cookie + ';path=' + path;
        }

        if (domain !== undefined) {
            cookie = cookie + ';domain=' + domain;
        }
        document.cookie = cookie;
    }

    this.getCookie = function (key) {
        var matches = document.cookie.match(new RegExp("(?:^|; )" + key.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + "=([^;]*)"));

        return matches ? decodeURIComponent(matches[1]) : undefined;
    }

}, [document]);
Kontur.Module('Kontur.Storage', function (window, cookie) {
    var defaultExpireDays = 365,
        storage;
    try {
        storage = window.localStorage;
    } catch (exc) {
        
    }

    this.setItem = function (key, value) {
        if (storage) {
            storage.setItem(key, value);
        } else {
            cookie.setCookie(key, value, defaultExpireDays);
        }
    };

    this.getItem = function (key) {
        return storage ? storage.getItem(key) : cookie.getCookie(key);
    };

}, [window, Kontur.Cookie]);
Kontur.Common = Kontur.Common || {};
Kontur.Common.ChangeSelectPopup = (function ($) {
    'use strict';
    var onItemClick = function (e) {
            var currentTarget = $(e.currentTarget),
                itemId = currentTarget.data('item-id');

            if (this.onItemSelect) {
                this.onItemSelect(itemId);
            }
        },
        onAllItemsClick = function (e) {
            if (this.onAllItemsSelect) {
                e.preventDefault();
                this.onAllItemsSelect();
            }
        },
        ChangeSelectPopup = function (id, onItemSelect, onAllItemsSelect) {
            var $el = this.$el = $('#' + id);
            this.onItemSelect = onItemSelect;
            this.onAllItemsSelect = onAllItemsSelect;

            this.$linkPopup = $el.find('[data-link]');
            this.$popup = $el.find('[data-popup]');
            this.$overlay = $el.find('.dropdownPopupOverlay');
            this.$items = $el.find('[data-item-id]');
            this.$allItemsLink = $el.find('[data-all-items]');
            this.$arrow = $el.find('[data-arrow]');

            this._bindEvents();
        };

    ChangeSelectPopup.init = function (id, onItemSelect, onAllItemsSelect) {
        return new ChangeSelectPopup(id, onItemSelect, onAllItemsSelect);
    };

    ChangeSelectPopup.prototype._bindEvents = function () {
        this.$linkPopup.on('click', $.proxy(this.open, this));
        this.$overlay.on('click', $.proxy(this.close, this));
        this.$items.on('click', $.proxy(onItemClick, this));
        this.$allItemsLink.on('click', $.proxy(onAllItemsClick, this));
    };

    ChangeSelectPopup.prototype._changeState = function () {
        this.$linkPopup.toggleClass('linkPopup_opened_js');
        this.$arrow.toggle();
        this.$overlay.fadeToggle(100);
        this.$popup.fadeToggle(100);
    };

    ChangeSelectPopup.prototype.open = function () {
        this._changeState();
    };

    ChangeSelectPopup.prototype.setTitle = function (title) {
        this.$el.find('[data-title]').html(title);
    }

    ChangeSelectPopup.prototype.setTitlePrefix = function (title) {
        this.$el.find('[data-title-prefix]').html(title);
    }

    ChangeSelectPopup.prototype.close = function () {
        if (this.$linkPopup.hasClass('linkPopup_opened_js')) {
            this._changeState();
        }
    };

    return ChangeSelectPopup;
}(jQuery));
Kontur.Module('Kontur.UrlParameters', function ($, global) {
    this.getParams = function() {
        var window = global.get();
        var getData = {};
        var _get = window.location.search.substring(1).split("&");
        for (var i = 0; i < _get.length; i++) {
            var getVar = _get[i].split("=");
            getData[getVar[0]] = typeof (getVar[1]) == "undefined" ? "" : getVar[1];
        }
        return getData;
    };
}, [$, Kontur.Global]);
/*! jQuery Validation Plugin - v1.11.1 - 3/22/2013\n* https://github.com/jzaefferer/jquery-validation
* Copyright (c) 2013 Jörn Zaefferer; Licensed MIT */(function(t){t.extend(t.fn,{validate:function(e){if(!this.length)return e&&e.debug&&window.console&&console.warn("Nothing selected, can't validate, returning nothing."),void 0;var i=t.data(this[0],"validator");return i?i:(this.attr("novalidate","novalidate"),i=new t.validator(e,this[0]),t.data(this[0],"validator",i),i.settings.onsubmit&&(this.validateDelegate(":submit","click",function(e){i.settings.submitHandler&&(i.submitButton=e.target),t(e.target).hasClass("cancel")&&(i.cancelSubmit=!0),void 0!==t(e.target).attr("formnovalidate")&&(i.cancelSubmit=!0)}),this.submit(function(e){function s(){var s;return i.settings.submitHandler?(i.submitButton&&(s=t("<input type='hidden'/>").attr("name",i.submitButton.name).val(t(i.submitButton).val()).appendTo(i.currentForm)),i.settings.submitHandler.call(i,i.currentForm,e),i.submitButton&&s.remove(),!1):!0}return i.settings.debug&&e.preventDefault(),i.cancelSubmit?(i.cancelSubmit=!1,s()):i.form()?i.pendingRequest?(i.formSubmitted=!0,!1):s():(i.focusInvalid(),!1)})),i)},valid:function(){if(t(this[0]).is("form"))return this.validate().form();var e=!0,i=t(this[0].form).validate();return this.each(function(){e=e&&i.element(this)}),e},removeAttrs:function(e){var i={},s=this;return t.each(e.split(/\s/),function(t,e){i[e]=s.attr(e),s.removeAttr(e)}),i},rules:function(e,i){var s=this[0];if(e){var r=t.data(s.form,"validator").settings,n=r.rules,a=t.validator.staticRules(s);switch(e){case"add":t.extend(a,t.validator.normalizeRule(i)),delete a.messages,n[s.name]=a,i.messages&&(r.messages[s.name]=t.extend(r.messages[s.name],i.messages));break;case"remove":if(!i)return delete n[s.name],a;var u={};return t.each(i.split(/\s/),function(t,e){u[e]=a[e],delete a[e]}),u}}var o=t.validator.normalizeRules(t.extend({},t.validator.classRules(s),t.validator.attributeRules(s),t.validator.dataRules(s),t.validator.staticRules(s)),s);if(o.required){var l=o.required;delete o.required,o=t.extend({required:l},o)}return o}}),t.extend(t.expr[":"],{blank:function(e){return!t.trim(""+t(e).val())},filled:function(e){return!!t.trim(""+t(e).val())},unchecked:function(e){return!t(e).prop("checked")}}),t.validator=function(e,i){this.settings=t.extend(!0,{},t.validator.defaults,e),this.currentForm=i,this.init()},t.validator.format=function(e,i){return 1===arguments.length?function(){var i=t.makeArray(arguments);return i.unshift(e),t.validator.format.apply(this,i)}:(arguments.length>2&&i.constructor!==Array&&(i=t.makeArray(arguments).slice(1)),i.constructor!==Array&&(i=[i]),t.each(i,function(t,i){e=e.replace(RegExp("\\{"+t+"\\}","g"),function(){return i})}),e)},t.extend(t.validator,{defaults:{messages:{},groups:{},rules:{},errorClass:"error",validClass:"valid",errorElement:"label",focusInvalid:!0,errorContainer:t([]),errorLabelContainer:t([]),onsubmit:!0,ignore:":hidden",ignoreTitle:!1,onfocusin:function(t){this.lastActive=t,this.settings.focusCleanup&&!this.blockFocusCleanup&&(this.settings.unhighlight&&this.settings.unhighlight.call(this,t,this.settings.errorClass,this.settings.validClass),this.addWrapper(this.errorsFor(t)).hide())},onfocusout:function(t){this.checkable(t)||!(t.name in this.submitted)&&this.optional(t)||this.element(t)},onkeyup:function(t,e){(9!==e.which||""!==this.elementValue(t))&&(t.name in this.submitted||t===this.lastElement)&&this.element(t)},onclick:function(t){t.name in this.submitted?this.element(t):t.parentNode.name in this.submitted&&this.element(t.parentNode)},highlight:function(e,i,s){"radio"===e.type?this.findByName(e.name).addClass(i).removeClass(s):t(e).addClass(i).removeClass(s)},unhighlight:function(e,i,s){"radio"===e.type?this.findByName(e.name).removeClass(i).addClass(s):t(e).removeClass(i).addClass(s)}},setDefaults:function(e){t.extend(t.validator.defaults,e)},messages:{required:"This field is required.",remote:"Please fix this field.",email:"Please enter a valid email address.",url:"Please enter a valid URL.",date:"Please enter a valid date.",dateISO:"Please enter a valid date (ISO).",number:"Please enter a valid number.",digits:"Please enter only digits.",creditcard:"Please enter a valid credit card number.",equalTo:"Please enter the same value again.",maxlength:t.validator.format("Please enter no more than {0} characters."),minlength:t.validator.format("Please enter at least {0} characters."),rangelength:t.validator.format("Please enter a value between {0} and {1} characters long."),range:t.validator.format("Please enter a value between {0} and {1}."),max:t.validator.format("Please enter a value less than or equal to {0}."),min:t.validator.format("Please enter a value greater than or equal to {0}.")},autoCreateRanges:!1,prototype:{init:function(){function e(e){var i=t.data(this[0].form,"validator"),s="on"+e.type.replace(/^validate/,"");i.settings[s]&&i.settings[s].call(i,this[0],e)}this.labelContainer=t(this.settings.errorLabelContainer),this.errorContext=this.labelContainer.length&&this.labelContainer||t(this.currentForm),this.containers=t(this.settings.errorContainer).add(this.settings.errorLabelContainer),this.submitted={},this.valueCache={},this.pendingRequest=0,this.pending={},this.invalid={},this.reset();var i=this.groups={};t.each(this.settings.groups,function(e,s){"string"==typeof s&&(s=s.split(/\s/)),t.each(s,function(t,s){i[s]=e})});var s=this.settings.rules;t.each(s,function(e,i){s[e]=t.validator.normalizeRule(i)}),t(this.currentForm).validateDelegate(":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'] ,[type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], [type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'] ","focusin focusout keyup",e).validateDelegate("[type='radio'], [type='checkbox'], select, option","click",e),this.settings.invalidHandler&&t(this.currentForm).bind("invalid-form.validate",this.settings.invalidHandler)},form:function(){return this.checkForm(),t.extend(this.submitted,this.errorMap),this.invalid=t.extend({},this.errorMap),this.valid()||t(this.currentForm).triggerHandler("invalid-form",[this]),this.showErrors(),this.valid()},checkForm:function(){this.prepareForm();for(var t=0,e=this.currentElements=this.elements();e[t];t++)this.check(e[t]);return this.valid()},element:function(e){e=this.validationTargetFor(this.clean(e)),this.lastElement=e,this.prepareElement(e),this.currentElements=t(e);var i=this.check(e)!==!1;return i?delete this.invalid[e.name]:this.invalid[e.name]=!0,this.numberOfInvalids()||(this.toHide=this.toHide.add(this.containers)),this.showErrors(),i},showErrors:function(e){if(e){t.extend(this.errorMap,e),this.errorList=[];for(var i in e)this.errorList.push({message:e[i],element:this.findByName(i)[0]});this.successList=t.grep(this.successList,function(t){return!(t.name in e)})}this.settings.showErrors?this.settings.showErrors.call(this,this.errorMap,this.errorList):this.defaultShowErrors()},resetForm:function(){t.fn.resetForm&&t(this.currentForm).resetForm(),this.submitted={},this.lastElement=null,this.prepareForm(),this.hideErrors(),this.elements().removeClass(this.settings.errorClass).removeData("previousValue")},numberOfInvalids:function(){return this.objectLength(this.invalid)},objectLength:function(t){var e=0;for(var i in t)e++;return e},hideErrors:function(){this.addWrapper(this.toHide).hide()},valid:function(){return 0===this.size()},size:function(){return this.errorList.length},focusInvalid:function(){if(this.settings.focusInvalid)try{t(this.findLastActive()||this.errorList.length&&this.errorList[0].element||[]).filter(":visible").focus().trigger("focusin")}catch(e){}},findLastActive:function(){var e=this.lastActive;return e&&1===t.grep(this.errorList,function(t){return t.element.name===e.name}).length&&e},elements:function(){var e=this,i={};return t(this.currentForm).find("input, select, textarea").not(":submit, :reset, :image, [disabled]").not(this.settings.ignore).filter(function(){return!this.name&&e.settings.debug&&window.console&&console.error("%o has no name assigned",this),this.name in i||!e.objectLength(t(this).rules())?!1:(i[this.name]=!0,!0)})},clean:function(e){return t(e)[0]},errors:function(){var e=this.settings.errorClass.replace(" ",".");return t(this.settings.errorElement+"."+e,this.errorContext)},reset:function(){this.successList=[],this.errorList=[],this.errorMap={},this.toShow=t([]),this.toHide=t([]),this.currentElements=t([])},prepareForm:function(){this.reset(),this.toHide=this.errors().add(this.containers)},prepareElement:function(t){this.reset(),this.toHide=this.errorsFor(t)},elementValue:function(e){var i=t(e).attr("type"),s=t(e).val();return"radio"===i||"checkbox"===i?t("input[name='"+t(e).attr("name")+"']:checked").val():"string"==typeof s?s.replace(/\r/g,""):s},check:function(e){e=this.validationTargetFor(this.clean(e));var i,s=t(e).rules(),r=!1,n=this.elementValue(e);for(var a in s){var u={method:a,parameters:s[a]};try{if(i=t.validator.methods[a].call(this,n,e,u.parameters),"dependency-mismatch"===i){r=!0;continue}if(r=!1,"pending"===i)return this.toHide=this.toHide.not(this.errorsFor(e)),void 0;if(!i)return this.formatAndAdd(e,u),!1}catch(o){throw this.settings.debug&&window.console&&console.log("Exception occurred when checking element "+e.id+", check the '"+u.method+"' method.",o),o}}return r?void 0:(this.objectLength(s)&&this.successList.push(e),!0)},customDataMessage:function(e,i){return t(e).data("msg-"+i.toLowerCase())||e.attributes&&t(e).attr("data-msg-"+i.toLowerCase())},customMessage:function(t,e){var i=this.settings.messages[t];return i&&(i.constructor===String?i:i[e])},findDefined:function(){for(var t=0;arguments.length>t;t++)if(void 0!==arguments[t])return arguments[t];return void 0},defaultMessage:function(e,i){return this.findDefined(this.customMessage(e.name,i),this.customDataMessage(e,i),!this.settings.ignoreTitle&&e.title||void 0,t.validator.messages[i],"<strong>Warning: No message defined for "+e.name+"</strong>")},formatAndAdd:function(e,i){var s=this.defaultMessage(e,i.method),r=/\$?\{(\d+)\}/g;"function"==typeof s?s=s.call(this,i.parameters,e):r.test(s)&&(s=t.validator.format(s.replace(r,"{$1}"),i.parameters)),this.errorList.push({message:s,element:e}),this.errorMap[e.name]=s,this.submitted[e.name]=s},addWrapper:function(t){return this.settings.wrapper&&(t=t.add(t.parent(this.settings.wrapper))),t},defaultShowErrors:function(){var t,e;for(t=0;this.errorList[t];t++){var i=this.errorList[t];this.settings.highlight&&this.settings.highlight.call(this,i.element,this.settings.errorClass,this.settings.validClass),this.showLabel(i.element,i.message)}if(this.errorList.length&&(this.toShow=this.toShow.add(this.containers)),this.settings.success)for(t=0;this.successList[t];t++)this.showLabel(this.successList[t]);if(this.settings.unhighlight)for(t=0,e=this.validElements();e[t];t++)this.settings.unhighlight.call(this,e[t],this.settings.errorClass,this.settings.validClass);this.toHide=this.toHide.not(this.toShow),this.hideErrors(),this.addWrapper(this.toShow).show()},validElements:function(){return this.currentElements.not(this.invalidElements())},invalidElements:function(){return t(this.errorList).map(function(){return this.element})},showLabel:function(e,i){var s=this.errorsFor(e);s.length?(s.removeClass(this.settings.validClass).addClass(this.settings.errorClass),s.html(i)):(s=t("<"+this.settings.errorElement+">").attr("for",this.idOrName(e)).addClass(this.settings.errorClass).html(i||""),this.settings.wrapper&&(s=s.hide().show().wrap("<"+this.settings.wrapper+"/>").parent()),this.labelContainer.append(s).length||(this.settings.errorPlacement?this.settings.errorPlacement(s,t(e)):s.insertAfter(e))),!i&&this.settings.success&&(s.text(""),"string"==typeof this.settings.success?s.addClass(this.settings.success):this.settings.success(s,e)),this.toShow=this.toShow.add(s)},errorsFor:function(e){var i=this.idOrName(e);return this.errors().filter(function(){return t(this).attr("for")===i})},idOrName:function(t){return this.groups[t.name]||(this.checkable(t)?t.name:t.id||t.name)},validationTargetFor:function(t){return this.checkable(t)&&(t=this.findByName(t.name).not(this.settings.ignore)[0]),t},checkable:function(t){return/radio|checkbox/i.test(t.type)},findByName:function(e){return t(this.currentForm).find("[name='"+e+"']")},getLength:function(e,i){switch(i.nodeName.toLowerCase()){case"select":return t("option:selected",i).length;case"input":if(this.checkable(i))return this.findByName(i.name).filter(":checked").length}return e.length},depend:function(t,e){return this.dependTypes[typeof t]?this.dependTypes[typeof t](t,e):!0},dependTypes:{"boolean":function(t){return t},string:function(e,i){return!!t(e,i.form).length},"function":function(t,e){return t(e)}},optional:function(e){var i=this.elementValue(e);return!t.validator.methods.required.call(this,i,e)&&"dependency-mismatch"},startRequest:function(t){this.pending[t.name]||(this.pendingRequest++,this.pending[t.name]=!0)},stopRequest:function(e,i){this.pendingRequest--,0>this.pendingRequest&&(this.pendingRequest=0),delete this.pending[e.name],i&&0===this.pendingRequest&&this.formSubmitted&&this.form()?(t(this.currentForm).submit(),this.formSubmitted=!1):!i&&0===this.pendingRequest&&this.formSubmitted&&(t(this.currentForm).triggerHandler("invalid-form",[this]),this.formSubmitted=!1)},previousValue:function(e){return t.data(e,"previousValue")||t.data(e,"previousValue",{old:null,valid:!0,message:this.defaultMessage(e,"remote")})}},classRuleSettings:{required:{required:!0},email:{email:!0},url:{url:!0},date:{date:!0},dateISO:{dateISO:!0},number:{number:!0},digits:{digits:!0},creditcard:{creditcard:!0}},addClassRules:function(e,i){e.constructor===String?this.classRuleSettings[e]=i:t.extend(this.classRuleSettings,e)},classRules:function(e){var i={},s=t(e).attr("class");return s&&t.each(s.split(" "),function(){this in t.validator.classRuleSettings&&t.extend(i,t.validator.classRuleSettings[this])}),i},attributeRules:function(e){var i={},s=t(e),r=s[0].getAttribute("type");for(var n in t.validator.methods){var a;"required"===n?(a=s.get(0).getAttribute(n),""===a&&(a=!0),a=!!a):a=s.attr(n),/min|max/.test(n)&&(null===r||/number|range|text/.test(r))&&(a=Number(a)),a?i[n]=a:r===n&&"range"!==r&&(i[n]=!0)}return i.maxlength&&/-1|2147483647|524288/.test(i.maxlength)&&delete i.maxlength,i},dataRules:function(e){var i,s,r={},n=t(e);for(i in t.validator.methods)s=n.data("rule-"+i.toLowerCase()),void 0!==s&&(r[i]=s);return r},staticRules:function(e){var i={},s=t.data(e.form,"validator");return s.settings.rules&&(i=t.validator.normalizeRule(s.settings.rules[e.name])||{}),i},normalizeRules:function(e,i){return t.each(e,function(s,r){if(r===!1)return delete e[s],void 0;if(r.param||r.depends){var n=!0;switch(typeof r.depends){case"string":n=!!t(r.depends,i.form).length;break;case"function":n=r.depends.call(i,i)}n?e[s]=void 0!==r.param?r.param:!0:delete e[s]}}),t.each(e,function(s,r){e[s]=t.isFunction(r)?r(i):r}),t.each(["minlength","maxlength"],function(){e[this]&&(e[this]=Number(e[this]))}),t.each(["rangelength","range"],function(){var i;e[this]&&(t.isArray(e[this])?e[this]=[Number(e[this][0]),Number(e[this][1])]:"string"==typeof e[this]&&(i=e[this].split(/[\s,]+/),e[this]=[Number(i[0]),Number(i[1])]))}),t.validator.autoCreateRanges&&(e.min&&e.max&&(e.range=[e.min,e.max],delete e.min,delete e.max),e.minlength&&e.maxlength&&(e.rangelength=[e.minlength,e.maxlength],delete e.minlength,delete e.maxlength)),e},normalizeRule:function(e){if("string"==typeof e){var i={};t.each(e.split(/\s/),function(){i[this]=!0}),e=i}return e},addMethod:function(e,i,s){t.validator.methods[e]=i,t.validator.messages[e]=void 0!==s?s:t.validator.messages[e],3>i.length&&t.validator.addClassRules(e,t.validator.normalizeRule(e))},methods:{required:function(e,i,s){if(!this.depend(s,i))return"dependency-mismatch";if("select"===i.nodeName.toLowerCase()){var r=t(i).val();return r&&r.length>0}return this.checkable(i)?this.getLength(e,i)>0:t.trim(e).length>0},email:function(t,e){return this.optional(e)||/^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i.test(t)},url:function(t,e){return this.optional(e)||/^(https?|s?ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(t)},date:function(t,e){return this.optional(e)||!/Invalid|NaN/.test(""+new Date(t))},dateISO:function(t,e){return this.optional(e)||/^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/.test(t)},number:function(t,e){return this.optional(e)||/^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(t)},digits:function(t,e){return this.optional(e)||/^\d+$/.test(t)},creditcard:function(t,e){if(this.optional(e))return"dependency-mismatch";if(/[^0-9 \-]+/.test(t))return!1;var i=0,s=0,r=!1;t=t.replace(/\D/g,"");for(var n=t.length-1;n>=0;n--){var a=t.charAt(n);s=parseInt(a,10),r&&(s*=2)>9&&(s-=9),i+=s,r=!r}return 0===i%10},minlength:function(e,i,s){var r=t.isArray(e)?e.length:this.getLength(t.trim(e),i);return this.optional(i)||r>=s},maxlength:function(e,i,s){var r=t.isArray(e)?e.length:this.getLength(t.trim(e),i);return this.optional(i)||s>=r},rangelength:function(e,i,s){var r=t.isArray(e)?e.length:this.getLength(t.trim(e),i);return this.optional(i)||r>=s[0]&&s[1]>=r},min:function(t,e,i){return this.optional(e)||t>=i},max:function(t,e,i){return this.optional(e)||i>=t},range:function(t,e,i){return this.optional(e)||t>=i[0]&&i[1]>=t},equalTo:function(e,i,s){var r=t(s);return this.settings.onfocusout&&r.unbind(".validate-equalTo").bind("blur.validate-equalTo",function(){t(i).valid()}),e===r.val()},remote:function(e,i,s){if(this.optional(i))return"dependency-mismatch";var r=this.previousValue(i);if(this.settings.messages[i.name]||(this.settings.messages[i.name]={}),r.originalMessage=this.settings.messages[i.name].remote,this.settings.messages[i.name].remote=r.message,s="string"==typeof s&&{url:s}||s,r.old===e)return r.valid;r.old=e;var n=this;this.startRequest(i);var a={};return a[i.name]=e,t.ajax(t.extend(!0,{url:s,mode:"abort",port:"validate"+i.name,dataType:"json",data:a,success:function(s){n.settings.messages[i.name].remote=r.originalMessage;var a=s===!0||"true"===s;if(a){var u=n.formSubmitted;n.prepareElement(i),n.formSubmitted=u,n.successList.push(i),delete n.invalid[i.name],n.showErrors()}else{var o={},l=s||n.defaultMessage(i,"remote");o[i.name]=r.message=t.isFunction(l)?l(e):l,n.invalid[i.name]=!0,n.showErrors(o)}r.valid=a,n.stopRequest(i,a)}},s)),"pending"}}}),t.format=t.validator.format})(jQuery),function(t){var e={};if(t.ajaxPrefilter)t.ajaxPrefilter(function(t,i,s){var r=t.port;"abort"===t.mode&&(e[r]&&e[r].abort(),e[r]=s)});else{var i=t.ajax;t.ajax=function(s){var r=("mode"in s?s:t.ajaxSettings).mode,n=("port"in s?s:t.ajaxSettings).port;return"abort"===r?(e[n]&&e[n].abort(),e[n]=i.apply(this,arguments),e[n]):i.apply(this,arguments)}}}(jQuery),function(t){t.extend(t.fn,{validateDelegate:function(e,i,s){return this.bind(i,function(i){var r=t(i.target);return r.is(e)?s.apply(r,arguments):void 0})}})}(jQuery);
/*
** Unobtrusive validation support library for jQuery and jQuery Validate
** Copyright (C) Microsoft Corporation. All rights reserved.
*/
(function(a){var d=a.validator,b,e="unobtrusiveValidation";function c(a,b,c){a.rules[b]=c;if(a.message)a.messages[b]=a.message}function j(a){return a.replace(/^\s+|\s+$/g,"").split(/\s*,\s*/g)}function f(a){return a.replace(/([!"#$%&'()*+,./:;<=>?@\[\\\]^`{|}~])/g,"\\$1")}function h(a){return a.substr(0,a.lastIndexOf(".")+1)}function g(a,b){if(a.indexOf("*.")===0)a=a.replace("*.",b);return a}function m(c,e){var b=a(this).find("[data-valmsg-for='"+f(e[0].name)+"']"),d=b.attr("data-valmsg-replace"),g=d?a.parseJSON(d)!==false:null;b.removeClass("field-validation-valid").addClass("field-validation-error");c.data("unobtrusiveContainer",b);if(g){b.empty();c.removeClass("input-validation-error").appendTo(b)}else c.hide()}function l(e,d){var c=a(this).find("[data-valmsg-summary=true]"),b=c.find("ul");if(b&&b.length&&d.errorList.length){b.empty();c.addClass("validation-summary-errors").removeClass("validation-summary-valid");a.each(d.errorList,function(){a("<li />").html(this.message).appendTo(b)})}}function k(d){var b=d.data("unobtrusiveContainer"),c=b.attr("data-valmsg-replace"),e=c?a.parseJSON(c):null;if(b){b.addClass("field-validation-valid").removeClass("field-validation-error");d.removeData("unobtrusiveContainer");e&&b.empty()}}function n(){var b=a(this);b.data("validator").resetForm();b.find(".validation-summary-errors").addClass("validation-summary-valid").removeClass("validation-summary-errors");b.find(".field-validation-error").addClass("field-validation-valid").removeClass("field-validation-error").removeData("unobtrusiveContainer").find(">*").removeData("unobtrusiveContainer")}function i(c){var b=a(c),d=b.data(e),f=a.proxy(n,c);if(!d){d={options:{errorClass:"input-validation-error",errorElement:"span",errorPlacement:a.proxy(m,c),invalidHandler:a.proxy(l,c),messages:{},rules:{},success:a.proxy(k,c)},attachValidation:function(){b.unbind("reset."+e,f).bind("reset."+e,f).validate(this.options)},validate:function(){b.validate();return b.valid()}};b.data(e,d)}return d}d.unobtrusive={adapters:[],parseElement:function(b,h){var d=a(b),f=d.parents("form")[0],c,e,g;if(!f)return;c=i(f);c.options.rules[b.name]=e={};c.options.messages[b.name]=g={};a.each(this.adapters,function(){var c="data-val-"+this.name,i=d.attr(c),h={};if(i!==undefined){c+="-";a.each(this.params,function(){h[this]=d.attr(c+this)});this.adapt({element:b,form:f,message:i,params:h,rules:e,messages:g})}});a.extend(e,{__dummy__:true});!h&&c.attachValidation()},parse:function(b){var c=a(b).parents("form").andSelf().add(a(b).find("form")).filter("form");a(b).find(":input[data-val=true]").each(function(){d.unobtrusive.parseElement(this,true)});c.each(function(){var a=i(this);a&&a.attachValidation()})}};b=d.unobtrusive.adapters;b.add=function(c,a,b){if(!b){b=a;a=[]}this.push({name:c,params:a,adapt:b});return this};b.addBool=function(a,b){return this.add(a,function(d){c(d,b||a,true)})};b.addMinMax=function(e,g,f,a,d,b){return this.add(e,[d||"min",b||"max"],function(b){var e=b.params.min,d=b.params.max;if(e&&d)c(b,a,[e,d]);else if(e)c(b,g,e);else d&&c(b,f,d)})};b.addSingleVal=function(a,b,d){return this.add(a,[b||"val"],function(e){c(e,d||a,e.params[b])})};d.addMethod("__dummy__",function(){return true});d.addMethod("regex",function(b,c,d){var a;if(this.optional(c))return true;a=(new RegExp(d)).exec(b);return a&&a.index===0&&a[0].length===b.length});d.addMethod("nonalphamin",function(c,d,b){var a;if(b){a=c.match(/\W/g);a=a&&a.length>=b}return a});b.addSingleVal("accept","exts").addSingleVal("regex","pattern");b.addBool("creditcard").addBool("date").addBool("digits").addBool("email").addBool("number").addBool("url");b.addMinMax("length","minlength","maxlength","rangelength").addMinMax("range","min","max","range");b.add("equalto",["other"],function(b){var i=h(b.element.name),j=b.params.other,d=g(j,i),e=a(b.form).find(":input[name='"+f(d)+"']")[0];c(b,"equalTo",e)});b.add("required",function(a){(a.element.tagName.toUpperCase()!=="INPUT"||a.element.type.toUpperCase()!=="CHECKBOX")&&c(a,"required",true)});b.add("remote",["url","type","additionalfields"],function(b){var d={url:b.params.url,type:b.params.type||"GET",data:{}},e=h(b.element.name);a.each(j(b.params.additionalfields||b.element.name),function(i,h){var c=g(h,e);d.data[c]=function(){return a(b.form).find(":input[name='"+f(c)+"']").val()}});c(b,"remote",d)});b.add("password",["min","nonalphamin","regex"],function(a){a.params.min&&c(a,"minlength",a.params.min);a.params.nonalphamin&&c(a,"nonalphamin",a.params.nonalphamin);a.params.regex&&c(a,"regex",a.params.regex)});a(function(){d.unobtrusive.parse(document)})})(jQuery);
(function () {
    Kontur = window.Kontur || {};
    var module = Kontur.Validators = Kontur.Validators || {};

    module.checkEmail = function (value) {
        return /^([a-zA-Z0-9]+[-._+\\&]+)*[a-zA-Z0-9_]+@([0-9a-zA-Z]+([-][0-9a-zA-Z]+)*[.])+[a-zA-Z]{2,}$/.test(value);
    }

    module.checkDate = function (value) {
        var bits = value.match(/([0-9]+)/gi);
        if (!bits) {
            return false;
        }
        var str = bits[1] + '/' + bits[0] + '/' + bits[2];
        return !/Invalid|NaN/.test(new Date(str));
    }

    module.checkKpp = function (value) {
        return /^\d{9}$/.test(value);
    }

    module.checkPhone = function (value) {
        var clearValue = value.replace(/[()+\-\s]/g, '');
        return /^(7|8)?\d{10}$/.test(clearValue);
    }

    module.checkInternationalPhone = function (value) {
        if (value) {
            var clearValue = value.replace(/[()\-]|\s+/, '');
            if (clearValue.indexOf('+') === 0) {
                return /^\+\d{5,13}$/.test(clearValue);
            } else {
                return /^8\d{10}$/.test(clearValue);
            }
        }

        return false;
    }

    module.checkInnSum = function (value) {
        return module.checkInnIp(value) || module.checkInnOrg(value);
    };

    module.checkInnOrg = function (value) {
        if (10 == value.length && /^\d{10}$/.test(value)) {
            var checkSum = 0;

            checkSum += parseInt(value.substring(0, 1)) * 2;
            checkSum += parseInt(value.substring(1, 2)) * 4;
            checkSum += parseInt(value.substring(2, 3)) * 10;
            checkSum += parseInt(value.substring(3, 4)) * 3;
            checkSum += parseInt(value.substring(4, 5)) * 5;
            checkSum += parseInt(value.substring(5, 6)) * 9;
            checkSum += parseInt(value.substring(6, 7)) * 4;
            checkSum += parseInt(value.substring(7, 8)) * 6;
            checkSum += parseInt(value.substring(8, 9)) * 8;
            checkSum = (checkSum % 11) % 10;

            return parseInt(value.substring(9, 10)) === checkSum;
        }

        return false;
    };

    module.checkInnIp = function (value) {
        if (12 == value.length && /^\d{12}$/.test(value)) {
            var checkSum1 = 0,
                checkSum2 = 0;

            checkSum1 += parseInt(value.substring(0, 1)) * 7; //1 цифра ИННФЛ
            checkSum1 += parseInt(value.substring(1, 2)) * 2; //2 цифра ИННФЛ
            checkSum1 += parseInt(value.substring(2, 3)) * 4; // и т.д.
            checkSum1 += parseInt(value.substring(3, 4)) * 10;
            checkSum1 += parseInt(value.substring(4, 5)) * 3;
            checkSum1 += parseInt(value.substring(5, 6)) * 5;
            checkSum1 += parseInt(value.substring(6, 7)) * 9;
            checkSum1 += parseInt(value.substring(7, 8)) * 4;
            checkSum1 += parseInt(value.substring(8, 9)) * 6;
            checkSum1 += parseInt(value.substring(9, 10)) * 8;
            //первая контрольная цифра
            checkSum1 = (checkSum1 % 11) % 10;
            //расчет второй контрольной цифры
            checkSum2 += parseInt(value.substring(0, 1)) * 3; //1 цифра ИННФЛ
            checkSum2 += parseInt(value.substring(1, 2)) * 7; //2 цифра ИННФЛ
            checkSum2 += parseInt(value.substring(2, 3)) * 2; // и т.д.
            checkSum2 += parseInt(value.substring(3, 4)) * 4;
            checkSum2 += parseInt(value.substring(4, 5)) * 10;
            checkSum2 += parseInt(value.substring(5, 6)) * 3;
            checkSum2 += parseInt(value.substring(6, 7)) * 5;
            checkSum2 += parseInt(value.substring(7, 8)) * 9;
            checkSum2 += parseInt(value.substring(8, 9)) * 4;
            checkSum2 += parseInt(value.substring(9, 10)) * 6;
            checkSum2 += checkSum1 * 8;
            //вторая контрольная цифра
            checkSum2 = (checkSum2 % 11) % 10;

            return (checkSum1 === parseInt(value.substring(10, 11)) && checkSum2 === parseInt(value.substring(11, 12)));
        }

        return false;
    };

    module.checkBik = function (value) {
        return /^\d{9}$/.test(value);
    };

    module.checkRs = function (value) {
        return /^\d{20}$/.test(value);
    };

    module.checkRsBik = function(rs, bik) {
        return module.checkRs(rs) && (!module.checkBik(bik) || validateRsByBik(rs, bik));
    };

    var validateRsControlDigits = [7, 1, 3, 7, 1, 3, 7, 1, 3, 7, 1, 3, 7, 1, 3, 7, 1, 3, 7, 1, 3, 7, 1];

    function validateRsByBik(validRs, validBik) {
        var controlSum = 0;
        var s = getDigitsFromBik(validBik) + validRs;

        for (var i = 0; i < s.length; i++) {
            controlSum += s[i] * validateRsControlDigits[i];
        }

        var rsIsValid = controlSum % 10 === 0;
        return rsIsValid || isExceptionalCase(validRs, validBik);
    }

    function getDigitsFromBik(validBik) {
        var last3Digits = validBik.substring(validBik.length - 3);
        if (last3Digits === '000' || last3Digits === '001') {
            return '0' + validBik[4] + validBik[5];
        }
        return last3Digits;
    }

    function isExceptionalCase(validRs, validBik) {
        return validRs === '40702810702650242256' && validBik === '044552272';
    }
})();
(function () {
    $.extend($.validator.messages, {
        required: 'Заполните поле',
        email: 'Некорректный электронный адрес',
        phone: 'Телефон должен состоять из 10 цифр',
        maxlength: jQuery.validator.format('Длина не должна превышать {0} символов'),
        minlength: jQuery.validator.format('Длина не должна быть меньше {0} символов'),
        unknown: 'Неверное значение поля'
    });

    $.validator.addMethod('requiredlocalized', function (value, element, params) {
        return $.validator.methods.required.apply(this, arguments);
    });

    $.validator.addMethod("emaillocalized", function (value, element) {
        if (value == '') {
            return true;
        }
        return Kontur.Validators.checkEmail(value);
    }, $.validator.messages['email']);

    $.validator.addMethod('canonicalphone', function (value, element, params) {
        if (value == '') {
            return true;
        }
        return Kontur.Validators.checkPhone(value);
    }, $.validator.messages.phone);

    $.validator.addMethod('internationalphone', function (value, element, params) {
        return Kontur.Validators.checkInternationalPhone(value);
    });

    $.validator.addMethod('date', function (value, element) {
        if (value == '') {
            return true;
        }
        return Kontur.Validators.checkDate(value);
    }, $.validator.messages.unknown);

    $.validator.addMethod('kpp', function (value, element, params) {
        if (params.suppressValidation != undefined && params.suppressValidation(value, element)) {
            return true;
        }

        var elementName = element.name,
            errors = {},
            innValue = $(element)
                .closest('form')
                .find('[name="' + params.innFieldName + '"]')
                .val();

        if (innValue && innValue.length > 0 && 12 !== innValue.length) {
            if (value == '') {
                errors[elementName] = $.validator.messages.required;
            } else if (!Kontur.Validators.checkKpp(value)) {
                errors[elementName] = $.validator.messages.unknown;
            }

            if (errors[elementName]) {
                params.errors = errors;
                return false;
            }
        }

        return true;
    }, function (params, element) {
        return params.errors[element.name];
    });

    $.validator.addMethod('inn', function (value, element, params) {
        if ('' == value) {
            return true;
        }

        if ($(element).data('for-physical') && value.length != 12) {
            return false;
        }

        return Kontur.Validators.checkInnSum(value);
    }, $.validator.messages.unknown);

    $.validator.addMethod('innorg', function (value) {
        return Kontur.Validators.checkInnOrg(value);
    }, $.validator.messages.unknown);

    $.validator.addMethod('innip', function (value) {
        return Kontur.Validators.checkInnIp(value);
    }, $.validator.messages.unknown);

    $.validator.addMethod('bik', function (value) {
        return Kontur.Validators.checkBik(value);
    }, $.validator.messages.unknown);

    $.validator.addMethod('rs', function (value) {
        return Kontur.Validators.checkRs(value);
    }, $.validator.messages.unknown);

    $.validator.addMethod('rsbik', function (value, element, params) {
        var bikPropertyName = $(element).attr('data-val-rsbik-bikpropertyname');
        var bikElementName = getFieldName($(element).attr('name'), bikPropertyName)

        var bikValue = $(element)
            .closest('form')
            .find('[name="' + bikElementName + '"]')
            .val();

        return Kontur.Validators.checkRsBik(value, bikValue);
    }, $.validator.messages.unknown);

    function getFieldName(fieldNameExample, propertyName) {
        return fieldNameExample.replace(/(([^\.]+\.)*)[^\.]+/, '$1' + propertyName);
    }
})();
(function () {
    $.validator.setDefaults({
        onfocusout: function (element) {
            if (!this.checkable(element) && !isDatePickerActive(element)) {
                this.element(element);
            }
        },
        ignore: ':hidden',
        onkeyup: null
    });

    $.validator.unobtrusive.adapters.addBool('requiredlocalized');
    $.validator.unobtrusive.adapters.addBool('emaillocalized');
    $.validator.unobtrusive.adapters.addBool('canonicalphone');
    $.validator.unobtrusive.adapters.addBool('internationalphone');
    $.validator.unobtrusive.adapters.addBool('inn');
    $.validator.unobtrusive.adapters.addBool('innorg');
    $.validator.unobtrusive.adapters.addBool('innip');
    $.validator.unobtrusive.adapters.add('kpp', function (options) {
        options.rules['kpp'] = {
            innFieldName: $(options.form).find('[data-val-inn]').attr('name')
        };
    });
    $.validator.unobtrusive.adapters.addBool('bik');
    $.validator.unobtrusive.adapters.addBool('rs');
    $.validator.unobtrusive.adapters.addBool('rsbik');
    $.validator.unobtrusive.adapters.add('stringminimumlengthlocalized', function (options) {
        options.rules['minlength'] = $(options.element).attr('data-val-stringminimumlengthlocalized-min');
    });

    $(function () {
        var origMaskFn = $.fn.mask;
        if (origMaskFn) {
            $.fn.mask = function (mask, settings) {
                origMaskFn.call(this, mask, settings)
                    .bind('blur', function () {
                        if (!isDatePickerActive(this)) {
                            $(this).valid();
                        }
                    });
            }
        }

        $('.js-datepicker-input').on('changeDate', function (ev) {
            $(this).valid();
        });
    });

    function isDatePickerActive(element) {
        return $(element).hasClass('js-datepicker-input') && $('.datepicker:visible').length !== 0;
    }
})();
var InnKppControl = (function ($) {
    'use strict';
    var defaultOptions = {
        innSelector: '',
        kppSelector: ''
    },
        init,
        bindEvents,
        module = function () {
            init.apply(this, arguments);
        };

    init = function (params) {
        var options = this.options = $.extend({}, defaultOptions, params);

        this.innField = $(options.innSelector);
        this.kppField = $(options.kppSelector);
        
        if (this.innField.length && this.kppField.length) {
            bindEvents.call(this);
        }
    };

    bindEvents = function () {
        var $innField = this.innField;
        var $kppField = this.kppField;
        $innField.on('change keyup input propertychange', function(e) {
            updateState($(e.currentTarget), $kppField);
        });
        updateState($innField, $kppField);
    };

    function updateState($innField, $kppField) {
        var inn = $innField.val();

        if (inn.length > 10) {
            $kppField.attr('disabled', 'disabled');
            removeValidationErrors($kppField);
        } else {
            $kppField.removeAttr('disabled');
        }
    }

    function removeValidationErrors($field) {
        $field.removeClass('input-validation-error');

        var fieldName = $field.attr('name');
        if (fieldName) {
            $('[data-valmsg-for="' + fieldName + '"]').remove();
        }
    }

    return module;
})(jQuery);
;
/*!
 * jQuery postMessage - v0.5 - 9/11/2009
 * http://benalman.com/projects/jquery-postmessage-plugin/
 * 
 * Copyright (c) 2009 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery postMessage: Cross-domain scripting goodness
//
// *Version: 0.5, Last updated: 9/11/2009*
// 
// Project Home - http://benalman.com/projects/jquery-postmessage-plugin/
// GitHub       - http://github.com/cowboy/jquery-postmessage/
// Source       - http://github.com/cowboy/jquery-postmessage/raw/master/jquery.ba-postmessage.js
// (Minified)   - http://github.com/cowboy/jquery-postmessage/raw/master/jquery.ba-postmessage.min.js (0.9kb)
// 
// About: License
// 
// Copyright (c) 2009 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// This working example, complete with fully commented code, illustrates one
// way in which this plugin can be used.
// 
// Iframe resizing - http://benalman.com/code/projects/jquery-postmessage/examples/iframe/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with and what browsers it has been tested in.
// 
// jQuery Versions - 1.3.2
// Browsers Tested - Internet Explorer 6-8, Firefox 3, Safari 3-4, Chrome, Opera 9.
// 
// About: Release History
// 
// 0.5 - (9/11/2009) Improved cache-busting
// 0.4 - (8/25/2009) Initial release

(function($){
  '$:nomunge'; // Used by YUI compressor.
  
  // A few vars used in non-awesome browsers.
  var interval_id,
    last_hash,
    cache_bust = 1,
    
    // A var used in awesome browsers.
    rm_callback,
    
    // A few convenient shortcuts.
    window = this,
    FALSE = !1,
    
    // Reused internal strings.
    postMessage = 'postMessage',
    addEventListener = 'addEventListener',
    
    p_receiveMessage,
    
    // I couldn't get window.postMessage to actually work in Opera 9.64!
    has_postMessage = window[postMessage];
  
  // Method: jQuery.postMessage
  // 
  // This method will call window.postMessage if available, setting the
  // targetOrigin parameter to the base of the target_url parameter for maximum
  // security in browsers that support it. If window.postMessage is not available,
  // the target window's location.hash will be used to pass the message. If an
  // object is passed as the message param, it will be serialized into a string
  // using the jQuery.param method.
  // 
  // Usage:
  // 
  // > jQuery.postMessage( message, target_url [, target ] );
  // 
  // Arguments:
  // 
  //  message - (String) A message to be passed to the other frame.
  //  message - (Object) An object to be serialized into a params string, using
  //    the jQuery.param method.
  //  target_url - (String) The URL of the other frame this window is
  //    attempting to communicate with. This must be the exact URL (including
  //    any query string) of the other window for this script to work in
  //    browsers that don't support window.postMessage.
  //  target - (Object) A reference to the other frame this window is
  //    attempting to communicate with. If omitted, defaults to `parent`.
  // 
  // Returns:
  // 
  //  Nothing.
  
  $[postMessage] = function( message, target_url, target ) {
    if ( !target_url ) { return; }
    
    // Serialize the message if not a string. Note that this is the only real
    // jQuery dependency for this script. If removed, this script could be
    // written as very basic JavaScript.
    message = typeof message === 'string' ? message : $.param( message );
    
    // Default to parent if unspecified.
    target = target || parent;
    
    if ( has_postMessage ) {
      // The browser supports window.postMessage, so call it with a targetOrigin
      // set appropriately, based on the target_url parameter.
      target[postMessage]( message, target_url.replace( /([^:]+:\/\/[^\/]+).*/, '$1' ) );
      
    } else if ( target_url ) {
      // The browser does not support window.postMessage, so set the location
      // of the target to target_url#message. A bit ugly, but it works! A cache
      // bust parameter is added to ensure that repeat messages trigger the
      // callback.
      target.location = target_url.replace( /#.*$/, '' ) + '#' + (+new Date) + (cache_bust++) + '&' + message;
    }
  };
  
  // Method: jQuery.receiveMessage
  // 
  // Register a single callback for either a window.postMessage call, if
  // supported, or if unsupported, for any change in the current window
  // location.hash. If window.postMessage is supported and source_origin is
  // specified, the source window will be checked against this for maximum
  // security. If window.postMessage is unsupported, a polling loop will be
  // started to watch for changes to the location.hash.
  // 
  // Note that for simplicity's sake, only a single callback can be registered
  // at one time. Passing no params will unbind this event (or stop the polling
  // loop), and calling this method a second time with another callback will
  // unbind the event (or stop the polling loop) first, before binding the new
  // callback.
  // 
  // Also note that if window.postMessage is available, the optional
  // source_origin param will be used to test the event.origin property. From
  // the MDC window.postMessage docs: This string is the concatenation of the
  // protocol and "://", the host name if one exists, and ":" followed by a port
  // number if a port is present and differs from the default port for the given
  // protocol. Examples of typical origins are https://example.org (implying
  // port 443), http://example.net (implying port 80), and http://example.com:8080.
  // 
  // Usage:
  // 
  // > jQuery.receiveMessage( callback [, source_origin ] [, delay ] );
  // 
  // Arguments:
  // 
  //  callback - (Function) This callback will execute whenever a <jQuery.postMessage>
  //    message is received, provided the source_origin matches. If callback is
  //    omitted, any existing receiveMessage event bind or polling loop will be
  //    canceled.
  //  source_origin - (String) If window.postMessage is available and this value
  //    is not equal to the event.origin property, the callback will not be
  //    called.
  //  source_origin - (Function) If window.postMessage is available and this
  //    function returns false when passed the event.origin property, the
  //    callback will not be called.
  //  delay - (Number) An optional zero-or-greater delay in milliseconds at
  //    which the polling loop will execute (for browser that don't support
  //    window.postMessage). If omitted, defaults to 100.
  // 
  // Returns:
  // 
  //  Nothing!
  
  $.receiveMessage = p_receiveMessage = function( callback, source_origin, delay ) {
    if ( has_postMessage ) {
      // Since the browser supports window.postMessage, the callback will be
      // bound to the actual event associated with window.postMessage.
      
      if ( callback ) {
        // Unbind an existing callback if it exists.
        rm_callback && p_receiveMessage();
        
        // Bind the callback. A reference to the callback is stored for ease of
        // unbinding.
        rm_callback = function(e) {
          if ( ( typeof source_origin === 'string' && e.origin !== source_origin )
            || ( $.isFunction( source_origin ) && source_origin( e.origin ) === FALSE ) ) {
            return FALSE;
          }
          callback( e );
        };
      }
      
      if ( window[addEventListener] ) {
        window[ callback ? addEventListener : 'removeEventListener' ]( 'message', rm_callback, FALSE );
      } else {
        window[ callback ? 'attachEvent' : 'detachEvent' ]( 'onmessage', rm_callback );
      }
      
    } else {
      // Since the browser sucks, a polling loop will be started, and the
      // callback will be called whenever the location.hash changes.
      
      interval_id && clearInterval( interval_id );
      interval_id = null;
      
      if ( callback ) {
        delay = typeof source_origin === 'number'
          ? source_origin
          : typeof delay === 'number'
            ? delay
            : 100;
        
        interval_id = setInterval(function(){
          var hash = document.location.hash,
            re = /^#?\d+&/;
          if ( hash !== last_hash && re.test( hash ) ) {
            last_hash = hash;
            callback({ data: hash.replace( re, '' ) });
          }
        }, delay );
      }
    }
  };
  
})(jQuery);
function CustomSelect(options) {
    this.__init(options);
}

CustomSelect.prototype.__init = function (options) {
    this.options = options;
    this.$rootCustomSelect = $(this.options.selector);
    this.$select = this.$rootCustomSelect.find('.js-nativeSelect');
    this.$selectText = this.$rootCustomSelect.find('.js-customSelectText');
    this.__bindEvents();
};

CustomSelect.prototype.__bindEvents = function () {
    this.$select.change($.proxy(function () {
        this.__setText();
    }, this));
};

CustomSelect.prototype.__setText = function () {
    this.$selectText.text(this.$select.val());
};
/*! jQuery UI - v1.9.0 - 2012-10-21
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.position.js
* Copyright (c) 2012 jQuery Foundation and other contributors Licensed MIT */

(function( $, undefined ) {

var uuid = 0,
    runiqueId = /^ui-id-\d+$/;

// prevent duplicate loading
// this is only a problem because we proxy existing functions
// and we don't want to double proxy them
$.ui = $.ui || {};
if ( $.ui.version ) {
    return;
}

$.extend( $.ui, {
    version: "1.9.0",

    keyCode: {
        BACKSPACE: 8,
        COMMA: 188,
        DELETE: 46,
        DOWN: 40,
        END: 35,
        ENTER: 13,
        ESCAPE: 27,
        HOME: 36,
        LEFT: 37,
        NUMPAD_ADD: 107,
        NUMPAD_DECIMAL: 110,
        NUMPAD_DIVIDE: 111,
        NUMPAD_ENTER: 108,
        NUMPAD_MULTIPLY: 106,
        NUMPAD_SUBTRACT: 109,
        PAGE_DOWN: 34,
        PAGE_UP: 33,
        PERIOD: 190,
        RIGHT: 39,
        SPACE: 32,
        TAB: 9,
        UP: 38
    }
});

// plugins
$.fn.extend({
    _focus: $.fn.focus,
    focus: function( delay, fn ) {
        return typeof delay === "number" ?
            this.each(function() {
                var elem = this;
                setTimeout(function() {
                    $( elem ).focus();
                    if ( fn ) {
                        fn.call( elem );
                    }
                }, delay );
            }) :
            this._focus.apply( this, arguments );
    },

    scrollParent: function() {
        var scrollParent;
        if (($.browser.msie && (/(static|relative)/).test(this.css('position'))) || (/absolute/).test(this.css('position'))) {
            scrollParent = this.parents().filter(function() {
                return (/(relative|absolute|fixed)/).test($.css(this,'position')) && (/(auto|scroll)/).test($.css(this,'overflow')+$.css(this,'overflow-y')+$.css(this,'overflow-x'));
            }).eq(0);
        } else {
            scrollParent = this.parents().filter(function() {
                return (/(auto|scroll)/).test($.css(this,'overflow')+$.css(this,'overflow-y')+$.css(this,'overflow-x'));
            }).eq(0);
        }

        return (/fixed/).test(this.css('position')) || !scrollParent.length ? $(document) : scrollParent;
    },

    zIndex: function( zIndex ) {
        if ( zIndex !== undefined ) {
            return this.css( "zIndex", zIndex );
        }

        if ( this.length ) {
            var elem = $( this[ 0 ] ), position, value;
            while ( elem.length && elem[ 0 ] !== document ) {
                // Ignore z-index if position is set to a value where z-index is ignored by the browser
                // This makes behavior of this function consistent across browsers
                // WebKit always returns auto if the element is positioned
                position = elem.css( "position" );
                if ( position === "absolute" || position === "relative" || position === "fixed" ) {
                    // IE returns 0 when zIndex is not specified
                    // other browsers return a string
                    // we ignore the case of nested elements with an explicit value of 0
                    // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                    value = parseInt( elem.css( "zIndex" ), 10 );
                    if ( !isNaN( value ) && value !== 0 ) {
                        return value;
                    }
                }
                elem = elem.parent();
            }
        }

        return 0;
    },

    uniqueId: function() {
        return this.each(function() {
            if ( !this.id ) {
                this.id = "ui-id-" + (++uuid);
            }
        });
    },

    removeUniqueId: function() {
        return this.each(function() {
            if ( runiqueId.test( this.id ) ) {
                $( this ).removeAttr( "id" );
            }
        });
    }
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
    $.each( [ "Width", "Height" ], function( i, name ) {
        var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
            type = name.toLowerCase(),
            orig = {
                innerWidth: $.fn.innerWidth,
                innerHeight: $.fn.innerHeight,
                outerWidth: $.fn.outerWidth,
                outerHeight: $.fn.outerHeight
            };

        function reduce( elem, size, border, margin ) {
            $.each( side, function() {
                size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
                if ( border ) {
                    size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
                }
                if ( margin ) {
                    size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
                }
            });
            return size;
        }

        $.fn[ "inner" + name ] = function( size ) {
            if ( size === undefined ) {
                return orig[ "inner" + name ].call( this );
            }

            return this.each(function() {
                $( this ).css( type, reduce( this, size ) + "px" );
            });
        };

        $.fn[ "outer" + name] = function( size, margin ) {
            if ( typeof size !== "number" ) {
                return orig[ "outer" + name ].call( this, size );
            }

            return this.each(function() {
                $( this).css( type, reduce( this, size, true, margin ) + "px" );
            });
        };
    });
}

// selectors
function focusable( element, isTabIndexNotNaN ) {
    var map, mapName, img,
        nodeName = element.nodeName.toLowerCase();
    if ( "area" === nodeName ) {
        map = element.parentNode;
        mapName = map.name;
        if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
            return false;
        }
        img = $( "img[usemap=#" + mapName + "]" )[0];
        return !!img && visible( img );
    }
    return ( /input|select|textarea|button|object/.test( nodeName ) ?
        !element.disabled :
        "a" === nodeName ?
            element.href || isTabIndexNotNaN :
            isTabIndexNotNaN) &&
        // the element and all of its ancestors must be visible
        visible( element );
}

function visible( element ) {
    return !$( element ).parents().andSelf().filter(function() {
        return $.css( this, "visibility" ) === "hidden" ||
            $.expr.filters.hidden( this );
    }).length;
}

$.extend( $.expr[ ":" ], {
    data: $.expr.createPseudo ?
        $.expr.createPseudo(function( dataName ) {
            return function( elem ) {
                return !!$.data( elem, dataName );
            };
        }) :
        // support: jQuery <1.8
        function( elem, i, match ) {
            return !!$.data( elem, match[ 3 ] );
        },

    focusable: function( element ) {
        return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
    },

    tabbable: function( element ) {
        var tabIndex = $.attr( element, "tabindex" ),
            isTabIndexNaN = isNaN( tabIndex );
        return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
    }
});

// support
$(function() {
    var body = document.body,
        div = body.appendChild( div = document.createElement( "div" ) );

    // access offsetHeight before setting the style to prevent a layout bug
    // in IE 9 which causes the element to continue to take up space even
    // after it is removed from the DOM (#8026)
    div.offsetHeight;

    $.extend( div.style, {
        minHeight: "100px",
        height: "auto",
        padding: 0,
        borderWidth: 0
    });

    $.support.minHeight = div.offsetHeight === 100;
    $.support.selectstart = "onselectstart" in div;

    // set display to none to avoid a layout bug in IE
    // http://dev.jquery.com/ticket/4014
    body.removeChild( div ).style.display = "none";
});





// deprecated

$.fn.extend({
    disableSelection: function() {
        return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
            ".ui-disableSelection", function( event ) {
                event.preventDefault();
            });
    },

    enableSelection: function() {
        return this.unbind( ".ui-disableSelection" );
    }
});

$.extend( $.ui, {
    // $.ui.plugin is deprecated.  Use the proxy pattern instead.
    plugin: {
        add: function( module, option, set ) {
            var i,
                proto = $.ui[ module ].prototype;
            for ( i in set ) {
                proto.plugins[ i ] = proto.plugins[ i ] || [];
                proto.plugins[ i ].push( [ option, set[ i ] ] );
            }
        },
        call: function( instance, name, args ) {
            var i,
                set = instance.plugins[ name ];
            if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
                return;
            }

            for ( i = 0; i < set.length; i++ ) {
                if ( instance.options[ set[ i ][ 0 ] ] ) {
                    set[ i ][ 1 ].apply( instance.element, args );
                }
            }
        }
    },

    contains: $.contains,

    // only used by resizable
    hasScroll: function( el, a ) {

        //If overflow is hidden, the element might have extra content, but the user wants to hide it
        if ( $( el ).css( "overflow" ) === "hidden") {
            return false;
        }

        var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
            has = false;

        if ( el[ scroll ] > 0 ) {
            return true;
        }

        // TODO: determine which cases actually cause this to happen
        // if the element doesn't have the scroll set, see if it's possible to
        // set the scroll
        el[ scroll ] = 1;
        has = ( el[ scroll ] > 0 );
        el[ scroll ] = 0;
        return has;
    },

    // these are odd functions, fix the API or move into individual plugins
    isOverAxis: function( x, reference, size ) {
        //Determines when x coordinate is over "b" element axis
        return ( x > reference ) && ( x < ( reference + size ) );
    },
    isOver: function( y, x, top, left, height, width ) {
        //Determines when x, y coordinates is over "b" element
        return $.ui.isOverAxis( y, top, height ) && $.ui.isOverAxis( x, left, width );
    }
});

})( jQuery );
(function( $, undefined ) {

var uuid = 0,
    slice = Array.prototype.slice,
    _cleanData = $.cleanData;
$.cleanData = function( elems ) {
    for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
        try {
            $( elem ).triggerHandler( "remove" );
        // http://bugs.jquery.com/ticket/8235
        } catch( e ) {}
    }
    _cleanData( elems );
};

$.widget = function( name, base, prototype ) {
    var fullName, existingConstructor, constructor, basePrototype,
        namespace = name.split( "." )[ 0 ];

    name = name.split( "." )[ 1 ];
    fullName = namespace + "-" + name;

    if ( !prototype ) {
        prototype = base;
        base = $.Widget;
    }

    // create selector for plugin
    $.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
        return !!$.data( elem, fullName );
    };

    $[ namespace ] = $[ namespace ] || {};
    existingConstructor = $[ namespace ][ name ];
    constructor = $[ namespace ][ name ] = function( options, element ) {
        // allow instantiation without "new" keyword
        if ( !this._createWidget ) {
            return new constructor( options, element );
        }

        // allow instantiation without initializing for simple inheritance
        // must use "new" keyword (the code above always passes args)
        if ( arguments.length ) {
            this._createWidget( options, element );
        }
    };
    // extend with the existing constructor to carry over any static properties
    $.extend( constructor, existingConstructor, {
        version: prototype.version,
        // copy the object used to create the prototype in case we need to
        // redefine the widget later
        _proto: $.extend( {}, prototype ),
        // track widgets that inherit from this widget in case this widget is
        // redefined after a widget inherits from it
        _childConstructors: []
    });

    basePrototype = new base();
    // we need to make the options hash a property directly on the new instance
    // otherwise we'll modify the options hash on the prototype that we're
    // inheriting from
    basePrototype.options = $.widget.extend( {}, basePrototype.options );
    $.each( prototype, function( prop, value ) {
        if ( $.isFunction( value ) ) {
            prototype[ prop ] = (function() {
                var _super = function() {
                        return base.prototype[ prop ].apply( this, arguments );
                    },
                    _superApply = function( args ) {
                        return base.prototype[ prop ].apply( this, args );
                    };
                return function() {
                    var __super = this._super,
                        __superApply = this._superApply,
                        returnValue;

                    this._super = _super;
                    this._superApply = _superApply;

                    returnValue = value.apply( this, arguments );

                    this._super = __super;
                    this._superApply = __superApply;

                    return returnValue;
                };
            })();
        }
    });
    constructor.prototype = $.widget.extend( basePrototype, {
        // TODO: remove support for widgetEventPrefix
        // always use the name + a colon as the prefix, e.g., draggable:start
        // don't prefix for widgets that aren't DOM-based
        widgetEventPrefix: name
    }, prototype, {
        constructor: constructor,
        namespace: namespace,
        widgetName: name,
        // TODO remove widgetBaseClass, see #8155
        widgetBaseClass: fullName,
        widgetFullName: fullName
    });

    // If this widget is being redefined then we need to find all widgets that
    // are inheriting from it and redefine all of them so that they inherit from
    // the new version of this widget. We're essentially trying to replace one
    // level in the prototype chain.
    if ( existingConstructor ) {
        $.each( existingConstructor._childConstructors, function( i, child ) {
            var childPrototype = child.prototype;

            // redefine the child widget using the same prototype that was
            // originally used, but inherit from the new version of the base
            $.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
        });
        // remove the list of existing child constructors from the old constructor
        // so the old child constructors can be garbage collected
        delete existingConstructor._childConstructors;
    } else {
        base._childConstructors.push( constructor );
    }

    $.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
    var input = slice.call( arguments, 1 ),
        inputIndex = 0,
        inputLength = input.length,
        key,
        value;
    for ( ; inputIndex < inputLength; inputIndex++ ) {
        for ( key in input[ inputIndex ] ) {
            value = input[ inputIndex ][ key ];
            if (input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
                target[ key ] = $.isPlainObject( value ) ? $.widget.extend( {}, target[ key ], value ) : value;
            }
        }
    }
    return target;
};

$.widget.bridge = function( name, object ) {
    var fullName = object.prototype.widgetFullName;
    $.fn[ name ] = function( options ) {
        var isMethodCall = typeof options === "string",
            args = slice.call( arguments, 1 ),
            returnValue = this;

        // allow multiple hashes to be passed on init
        options = !isMethodCall && args.length ?
            $.widget.extend.apply( null, [ options ].concat(args) ) :
            options;

        if ( isMethodCall ) {
            this.each(function() {
                var methodValue,
                    instance = $.data( this, fullName );
                if ( !instance ) {
                    return $.error( "cannot call methods on " + name + " prior to initialization; " +
                        "attempted to call method '" + options + "'" );
                }
                if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
                    return $.error( "no such method '" + options + "' for " + name + " widget instance" );
                }
                methodValue = instance[ options ].apply( instance, args );
                if ( methodValue !== instance && methodValue !== undefined ) {
                    returnValue = methodValue && methodValue.jquery ?
                        returnValue.pushStack( methodValue.get() ) :
                        methodValue;
                    return false;
                }
            });
        } else {
            this.each(function() {
                var instance = $.data( this, fullName );
                if ( instance ) {
                    instance.option( options || {} )._init();
                } else {
                    new object( options, this );
                }
            });
        }

        return returnValue;
    };
};

$.Widget = function( options, element ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
    widgetName: "widget",
    widgetEventPrefix: "",
    defaultElement: "<div>",
    options: {
        disabled: false,

        // callbacks
        create: null
    },
    _createWidget: function( options, element ) {
        element = $( element || this.defaultElement || this )[ 0 ];
        this.element = $( element );
        this.uuid = uuid++;
        this.eventNamespace = "." + this.widgetName + this.uuid;
        this.options = $.widget.extend( {},
            this.options,
            this._getCreateOptions(),
            options );

        this.bindings = $();
        this.hoverable = $();
        this.focusable = $();

        if ( element !== this ) {
            // 1.9 BC for #7810
            // TODO remove dual storage
            $.data( element, this.widgetName, this );
            $.data( element, this.widgetFullName, this );
            this._on({ remove: "destroy" });
            this.document = $( element.style ?
                // element within the document
                element.ownerDocument :
                // element is window or document
                element.document || element );
            this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
        }

        this._create();
        this._trigger( "create", null, this._getCreateEventData() );
        this._init();
    },
    _getCreateOptions: $.noop,
    _getCreateEventData: $.noop,
    _create: $.noop,
    _init: $.noop,

    destroy: function() {
        this._destroy();
        // we can probably remove the unbind calls in 2.0
        // all event bindings should go through this._on()
        this.element
            .unbind( this.eventNamespace )
            // 1.9 BC for #7810
            // TODO remove dual storage
            .removeData( this.widgetName )
            .removeData( this.widgetFullName )
            // support: jquery <1.6.3
            // http://bugs.jquery.com/ticket/9413
            .removeData( $.camelCase( this.widgetFullName ) );
        this.widget()
            .unbind( this.eventNamespace )
            .removeAttr( "aria-disabled" )
            .removeClass(
                this.widgetFullName + "-disabled " +
                "ui-state-disabled" );

        // clean up events and states
        this.bindings.unbind( this.eventNamespace );
        this.hoverable.removeClass( "ui-state-hover" );
        this.focusable.removeClass( "ui-state-focus" );
    },
    _destroy: $.noop,

    widget: function() {
        return this.element;
    },

    option: function( key, value ) {
        var options = key,
            parts,
            curOption,
            i;

        if ( arguments.length === 0 ) {
            // don't return a reference to the internal hash
            return $.widget.extend( {}, this.options );
        }

        if ( typeof key === "string" ) {
            // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
            options = {};
            parts = key.split( "." );
            key = parts.shift();
            if ( parts.length ) {
                curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
                for ( i = 0; i < parts.length - 1; i++ ) {
                    curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
                    curOption = curOption[ parts[ i ] ];
                }
                key = parts.pop();
                if ( value === undefined ) {
                    return curOption[ key ] === undefined ? null : curOption[ key ];
                }
                curOption[ key ] = value;
            } else {
                if ( value === undefined ) {
                    return this.options[ key ] === undefined ? null : this.options[ key ];
                }
                options[ key ] = value;
            }
        }

        this._setOptions( options );

        return this;
    },
    _setOptions: function( options ) {
        var key;

        for ( key in options ) {
            this._setOption( key, options[ key ] );
        }

        return this;
    },
    _setOption: function( key, value ) {
        this.options[ key ] = value;

        if ( key === "disabled" ) {
            this.widget()
                .toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
                .attr( "aria-disabled", value );
            this.hoverable.removeClass( "ui-state-hover" );
            this.focusable.removeClass( "ui-state-focus" );
        }

        return this;
    },

    enable: function() {
        return this._setOption( "disabled", false );
    },
    disable: function() {
        return this._setOption( "disabled", true );
    },

    _on: function( element, handlers ) {
        // no element argument, shuffle and use this.element
        if ( !handlers ) {
            handlers = element;
            element = this.element;
        } else {
            // accept selectors, DOM elements
            element = $( element );
            this.bindings = this.bindings.add( element );
        }

        var instance = this;
        $.each( handlers, function( event, handler ) {
            function handlerProxy() {
                // allow widgets to customize the disabled handling
                // - disabled as an array instead of boolean
                // - disabled class as method for disabling individual parts
                if ( instance.options.disabled === true ||
                        $( this ).hasClass( "ui-state-disabled" ) ) {
                    return;
                }
                return ( typeof handler === "string" ? instance[ handler ] : handler )
                    .apply( instance, arguments );
            }

            // copy the guid so direct unbinding works
            if ( typeof handler !== "string" ) {
                handlerProxy.guid = handler.guid =
                    handler.guid || handlerProxy.guid || $.guid++;
            }

            var match = event.match( /^(\w+)\s*(.*)$/ ),
                eventName = match[1] + instance.eventNamespace,
                selector = match[2];
            if ( selector ) {
                instance.widget().delegate( selector, eventName, handlerProxy );
            } else {
                element.bind( eventName, handlerProxy );
            }
        });
    },

    _off: function( element, eventName ) {
        eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
        element.unbind( eventName ).undelegate( eventName );
    },

    _delay: function( handler, delay ) {
        function handlerProxy() {
            return ( typeof handler === "string" ? instance[ handler ] : handler )
                .apply( instance, arguments );
        }
        var instance = this;
        return setTimeout( handlerProxy, delay || 0 );
    },

    _hoverable: function( element ) {
        this.hoverable = this.hoverable.add( element );
        this._on( element, {
            mouseenter: function( event ) {
                $( event.currentTarget ).addClass( "ui-state-hover" );
            },
            mouseleave: function( event ) {
                $( event.currentTarget ).removeClass( "ui-state-hover" );
            }
        });
    },

    _focusable: function( element ) {
        this.focusable = this.focusable.add( element );
        this._on( element, {
            focusin: function( event ) {
                $( event.currentTarget ).addClass( "ui-state-focus" );
            },
            focusout: function( event ) {
                $( event.currentTarget ).removeClass( "ui-state-focus" );
            }
        });
    },

    _trigger: function( type, event, data ) {
        var prop, orig,
            callback = this.options[ type ];

        data = data || {};
        event = $.Event( event );
        event.type = ( type === this.widgetEventPrefix ?
            type :
            this.widgetEventPrefix + type ).toLowerCase();
        // the original event may come from any element
        // so we need to reset the target on the new event
        event.target = this.element[ 0 ];

        // copy original event properties over to the new event
        orig = event.originalEvent;
        if ( orig ) {
            for ( prop in orig ) {
                if ( !( prop in event ) ) {
                    event[ prop ] = orig[ prop ];
                }
            }
        }

        this.element.trigger( event, data );
        return !( $.isFunction( callback ) &&
            callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
            event.isDefaultPrevented() );
    }
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
    $.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
        if ( typeof options === "string" ) {
            options = { effect: options };
        }
        var hasOptions,
            effectName = !options ?
                method :
                options === true || typeof options === "number" ?
                    defaultEffect :
                    options.effect || defaultEffect;
        options = options || {};
        if ( typeof options === "number" ) {
            options = { duration: options };
        }
        hasOptions = !$.isEmptyObject( options );
        options.complete = callback;
        if ( options.delay ) {
            element.delay( options.delay );
        }
        if ( hasOptions && $.effects && ( $.effects.effect[ effectName ] || $.uiBackCompat !== false && $.effects[ effectName ] ) ) {
            element[ method ]( options );
        } else if ( effectName !== method && element[ effectName ] ) {
            element[ effectName ]( options.duration, options.easing, callback );
        } else {
            element.queue(function( next ) {
                $( this )[ method ]();
                if ( callback ) {
                    callback.call( element[ 0 ] );
                }
                next();
            });
        }
    };
});

// DEPRECATED
if ( $.uiBackCompat !== false ) {
    $.Widget.prototype._getCreateOptions = function() {
        return $.metadata && $.metadata.get( this.element[0] )[ this.widgetName ];
    };
}

})( jQuery );
(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function( e ) {
    mouseHandled = false;
});

$.widget("ui.mouse", {
    version: "1.9.0",
    options: {
        cancel: 'input,textarea,button,select,option',
        distance: 1,
        delay: 0
    },
    _mouseInit: function() {
        var that = this;

        this.element
            .bind('mousedown.'+this.widgetName, function(event) {
                return that._mouseDown(event);
            })
            .bind('click.'+this.widgetName, function(event) {
                if (true === $.data(event.target, that.widgetName + '.preventClickEvent')) {
                    $.removeData(event.target, that.widgetName + '.preventClickEvent');
                    event.stopImmediatePropagation();
                    return false;
                }
            });

        this.started = false;
    },

    // TODO: make sure destroying one instance of mouse doesn't mess with
    // other instances of mouse
    _mouseDestroy: function() {
        this.element.unbind('.'+this.widgetName);
        if ( this._mouseMoveDelegate ) {
            $(document)
                .unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
                .unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);
        }
    },

    _mouseDown: function(event) {
        // don't let more than one widget handle mouseStart
        if( mouseHandled ) { return; }

        // we may have missed mouseup (out of window)
        (this._mouseStarted && this._mouseUp(event));

        this._mouseDownEvent = event;

        var that = this,
            btnIsLeft = (event.which === 1),
            // event.target.nodeName works around a bug in IE 8 with
            // disabled inputs (#7620)
            elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
        if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
            return true;
        }

        this.mouseDelayMet = !this.options.delay;
        if (!this.mouseDelayMet) {
            this._mouseDelayTimer = setTimeout(function() {
                that.mouseDelayMet = true;
            }, this.options.delay);
        }

        if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
            this._mouseStarted = (this._mouseStart(event) !== false);
            if (!this._mouseStarted) {
                event.preventDefault();
                return true;
            }
        }

        // Click event may never have fired (Gecko & Opera)
        if (true === $.data(event.target, this.widgetName + '.preventClickEvent')) {
            $.removeData(event.target, this.widgetName + '.preventClickEvent');
        }

        // these delegates are required to keep context
        this._mouseMoveDelegate = function(event) {
            return that._mouseMove(event);
        };
        this._mouseUpDelegate = function(event) {
            return that._mouseUp(event);
        };
        $(document)
            .bind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
            .bind('mouseup.'+this.widgetName, this._mouseUpDelegate);

        event.preventDefault();
        
        mouseHandled = true;
        return true;
    },

    _mouseMove: function(event) {
        // IE mouseup check - mouseup happened when mouse was out of window
        if ($.browser.msie && !(document.documentMode >= 9) && !event.button) {
            return this._mouseUp(event);
        }

        if (this._mouseStarted) {
            this._mouseDrag(event);
            return event.preventDefault();
        }

        if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
            this._mouseStarted =
                (this._mouseStart(this._mouseDownEvent, event) !== false);
            (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
        }

        return !this._mouseStarted;
    },

    _mouseUp: function(event) {
        $(document)
            .unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
            .unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);

        if (this._mouseStarted) {
            this._mouseStarted = false;

            if (event.target === this._mouseDownEvent.target) {
                $.data(event.target, this.widgetName + '.preventClickEvent', true);
            }

            this._mouseStop(event);
        }

        return false;
    },

    _mouseDistanceMet: function(event) {
        return (Math.max(
                Math.abs(this._mouseDownEvent.pageX - event.pageX),
                Math.abs(this._mouseDownEvent.pageY - event.pageY)
            ) >= this.options.distance
        );
    },

    _mouseDelayMet: function(event) {
        return this.mouseDelayMet;
    },

    // These are placeholder methods, to be overriden by extending plugin
    _mouseStart: function(event) {},
    _mouseDrag: function(event) {},
    _mouseStop: function(event) {},
    _mouseCapture: function(event) { return true; }
});

})(jQuery);
(function( $, undefined ) {

$.ui = $.ui || {};

var cachedScrollbarWidth,
    max = Math.max,
    abs = Math.abs,
    round = Math.round,
    rhorizontal = /left|center|right/,
    rvertical = /top|center|bottom/,
    roffset = /[\+\-]\d+%?/,
    rposition = /^\w+/,
    rpercent = /%$/,
    _position = $.fn.position;

function getOffsets( offsets, width, height ) {
    return [
        parseInt( offsets[ 0 ], 10 ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
        parseInt( offsets[ 1 ], 10 ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
    ];
}
function parseCss( element, property ) {
    return parseInt( $.css( element, property ), 10 ) || 0;
}

$.position = {
    scrollbarWidth: function() {
        if ( cachedScrollbarWidth !== undefined ) {
            return cachedScrollbarWidth;
        }
        var w1, w2,
            div = $( "<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
            innerDiv = div.children()[0];

        $( "body" ).append( div );
        w1 = innerDiv.offsetWidth;
        div.css( "overflow", "scroll" );

        w2 = innerDiv.offsetWidth;

        if ( w1 === w2 ) {
            w2 = div[0].clientWidth;
        }

        div.remove();

        return (cachedScrollbarWidth = w1 - w2);
    },
    getScrollInfo: function( within ) {
        var overflowX = within.isWindow ? "" : within.element.css( "overflow-x" ),
            overflowY = within.isWindow ? "" : within.element.css( "overflow-y" ),
            hasOverflowX = overflowX === "scroll" ||
                ( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
            hasOverflowY = overflowY === "scroll" ||
                ( overflowY === "auto" && within.height < within.element[0].scrollHeight );
        return {
            width: hasOverflowX ? $.position.scrollbarWidth() : 0,
            height: hasOverflowY ? $.position.scrollbarWidth() : 0
        };
    },
    getWithinInfo: function( element ) {
        var withinElement = $( element || window ),
            isWindow = $.isWindow( withinElement[0] );
        return {
            element: withinElement,
            isWindow: isWindow,
            offset: withinElement.offset() || { left: 0, top: 0 },
            scrollLeft: withinElement.scrollLeft(),
            scrollTop: withinElement.scrollTop(),
            width: isWindow ? withinElement.width() : withinElement.outerWidth(),
            height: isWindow ? withinElement.height() : withinElement.outerHeight()
        };
    }
};

$.fn.position = function( options ) {
    if ( !options || !options.of ) {
        return _position.apply( this, arguments );
    }

    // make a copy, we don't want to modify arguments
    options = $.extend( {}, options );

    var atOffset, targetWidth, targetHeight, targetOffset, basePosition,
        target = $( options.of ),
        within = $.position.getWithinInfo( options.within ),
        scrollInfo = $.position.getScrollInfo( within ),
        targetElem = target[0],
        collision = ( options.collision || "flip" ).split( " " ),
        offsets = {};

    if ( targetElem.nodeType === 9 ) {
        targetWidth = target.width();
        targetHeight = target.height();
        targetOffset = { top: 0, left: 0 };
    } else if ( $.isWindow( targetElem ) ) {
        targetWidth = target.width();
        targetHeight = target.height();
        targetOffset = { top: target.scrollTop(), left: target.scrollLeft() };
    } else if ( targetElem.preventDefault ) {
        // force left top to allow flipping
        options.at = "left top";
        targetWidth = targetHeight = 0;
        targetOffset = { top: targetElem.pageY, left: targetElem.pageX };
    } else {
        targetWidth = target.outerWidth();
        targetHeight = target.outerHeight();
        targetOffset = target.offset();
    }
    // clone to reuse original targetOffset later
    basePosition = $.extend( {}, targetOffset );

    // force my and at to have valid horizontal and vertical positions
    // if a value is missing or invalid, it will be converted to center
    $.each( [ "my", "at" ], function() {
        var pos = ( options[ this ] || "" ).split( " " ),
            horizontalOffset,
            verticalOffset;

        if ( pos.length === 1) {
            pos = rhorizontal.test( pos[ 0 ] ) ?
                pos.concat( [ "center" ] ) :
                rvertical.test( pos[ 0 ] ) ?
                    [ "center" ].concat( pos ) :
                    [ "center", "center" ];
        }
        pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
        pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

        // calculate offsets
        horizontalOffset = roffset.exec( pos[ 0 ] );
        verticalOffset = roffset.exec( pos[ 1 ] );
        offsets[ this ] = [
            horizontalOffset ? horizontalOffset[ 0 ] : 0,
            verticalOffset ? verticalOffset[ 0 ] : 0
        ];

        // reduce to just the positions without the offsets
        options[ this ] = [
            rposition.exec( pos[ 0 ] )[ 0 ],
            rposition.exec( pos[ 1 ] )[ 0 ]
        ];
    });

    // normalize collision option
    if ( collision.length === 1 ) {
        collision[ 1 ] = collision[ 0 ];
    }

    if ( options.at[ 0 ] === "right" ) {
        basePosition.left += targetWidth;
    } else if ( options.at[ 0 ] === "center" ) {
        basePosition.left += targetWidth / 2;
    }

    if ( options.at[ 1 ] === "bottom" ) {
        basePosition.top += targetHeight;
    } else if ( options.at[ 1 ] === "center" ) {
        basePosition.top += targetHeight / 2;
    }

    atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
    basePosition.left += atOffset[ 0 ];
    basePosition.top += atOffset[ 1 ];

    return this.each(function() {
        var collisionPosition, using,
            elem = $( this ),
            elemWidth = elem.outerWidth(),
            elemHeight = elem.outerHeight(),
            marginLeft = parseCss( this, "marginLeft" ),
            marginTop = parseCss( this, "marginTop" ),
            collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
            collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
            position = $.extend( {}, basePosition ),
            myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

        if ( options.my[ 0 ] === "right" ) {
            position.left -= elemWidth;
        } else if ( options.my[ 0 ] === "center" ) {
            position.left -= elemWidth / 2;
        }

        if ( options.my[ 1 ] === "bottom" ) {
            position.top -= elemHeight;
        } else if ( options.my[ 1 ] === "center" ) {
            position.top -= elemHeight / 2;
        }

        position.left += myOffset[ 0 ];
        position.top += myOffset[ 1 ];

        // if the browser doesn't support fractions, then round for consistent results
        if ( !$.support.offsetFractions ) {
            position.left = round( position.left );
            position.top = round( position.top );
        }

        collisionPosition = {
            marginLeft: marginLeft,
            marginTop: marginTop
        };

        $.each( [ "left", "top" ], function( i, dir ) {
            if ( $.ui.position[ collision[ i ] ] ) {
                $.ui.position[ collision[ i ] ][ dir ]( position, {
                    targetWidth: targetWidth,
                    targetHeight: targetHeight,
                    elemWidth: elemWidth,
                    elemHeight: elemHeight,
                    collisionPosition: collisionPosition,
                    collisionWidth: collisionWidth,
                    collisionHeight: collisionHeight,
                    offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
                    my: options.my,
                    at: options.at,
                    within: within,
                    elem : elem
                });
            }
        });

        if ( $.fn.bgiframe ) {
            elem.bgiframe();
        }

        if ( options.using ) {
            // adds feedback as second argument to using callback, if present
            using = function( props ) {
                var left = targetOffset.left - position.left,
                    right = left + targetWidth - elemWidth,
                    top = targetOffset.top - position.top,
                    bottom = top + targetHeight - elemHeight,
                    feedback = {
                        target: {
                            element: target,
                            left: targetOffset.left,
                            top: targetOffset.top,
                            width: targetWidth,
                            height: targetHeight
                        },
                        element: {
                            element: elem,
                            left: position.left,
                            top: position.top,
                            width: elemWidth,
                            height: elemHeight
                        },
                        horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                        vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                    };
                if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
                    feedback.horizontal = "center";
                }
                if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
                    feedback.vertical = "middle";
                }
                if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
                    feedback.important = "horizontal";
                } else {
                    feedback.important = "vertical";
                }
                options.using.call( this, props, feedback );
            };
        }

        elem.offset( $.extend( position, { using: using } ) );
    });
};

$.ui.position = {
    fit: {
        left: function( position, data ) {
            var within = data.within,
                withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
                outerWidth = within.width,
                collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                overLeft = withinOffset - collisionPosLeft,
                overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
                newOverRight;

            // element is wider than within
            if ( data.collisionWidth > outerWidth ) {
                // element is initially over the left side of within
                if ( overLeft > 0 && overRight <= 0 ) {
                    newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
                    position.left += overLeft - newOverRight;
                // element is initially over right side of within
                } else if ( overRight > 0 && overLeft <= 0 ) {
                    position.left = withinOffset;
                // element is initially over both left and right sides of within
                } else {
                    if ( overLeft > overRight ) {
                        position.left = withinOffset + outerWidth - data.collisionWidth;
                    } else {
                        position.left = withinOffset;
                    }
                }
            // too far left -> align with left edge
            } else if ( overLeft > 0 ) {
                position.left += overLeft;
            // too far right -> align with right edge
            } else if ( overRight > 0 ) {
                position.left -= overRight;
            // adjust based on position and margin
            } else {
                position.left = max( position.left - collisionPosLeft, position.left );
            }
        },
        top: function( position, data ) {
            var within = data.within,
                withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
                outerHeight = data.within.height,
                collisionPosTop = position.top - data.collisionPosition.marginTop,
                overTop = withinOffset - collisionPosTop,
                overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
                newOverBottom;

            // element is taller than within
            if ( data.collisionHeight > outerHeight ) {
                // element is initially over the top of within
                if ( overTop > 0 && overBottom <= 0 ) {
                    newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
                    position.top += overTop - newOverBottom;
                // element is initially over bottom of within
                } else if ( overBottom > 0 && overTop <= 0 ) {
                    position.top = withinOffset;
                // element is initially over both top and bottom of within
                } else {
                    if ( overTop > overBottom ) {
                        position.top = withinOffset + outerHeight - data.collisionHeight;
                    } else {
                        position.top = withinOffset;
                    }
                }
            // too far up -> align with top
            } else if ( overTop > 0 ) {
                position.top += overTop;
            // too far down -> align with bottom edge
            } else if ( overBottom > 0 ) {
                position.top -= overBottom;
            // adjust based on position and margin
            } else {
                position.top = max( position.top - collisionPosTop, position.top );
            }
        }
    },
    flip: {
        left: function( position, data ) {
            var within = data.within,
                withinOffset = within.offset.left + within.scrollLeft,
                outerWidth = within.width,
                offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
                collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                overLeft = collisionPosLeft - offsetLeft,
                overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
                myOffset = data.my[ 0 ] === "left" ?
                    -data.elemWidth :
                    data.my[ 0 ] === "right" ?
                        data.elemWidth :
                        0,
                atOffset = data.at[ 0 ] === "left" ?
                    data.targetWidth :
                    data.at[ 0 ] === "right" ?
                        -data.targetWidth :
                        0,
                offset = -2 * data.offset[ 0 ],
                newOverRight,
                newOverLeft;

            if ( overLeft < 0 ) {
                newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
                if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
                    position.left += myOffset + atOffset + offset;
                }
            }
            else if ( overRight > 0 ) {
                newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
                if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
                    position.left += myOffset + atOffset + offset;
                }
            }
        },
        top: function( position, data ) {
            var within = data.within,
                withinOffset = within.offset.top + within.scrollTop,
                outerHeight = within.height,
                offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
                collisionPosTop = position.top - data.collisionPosition.marginTop,
                overTop = collisionPosTop - offsetTop,
                overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
                top = data.my[ 1 ] === "top",
                myOffset = top ?
                    -data.elemHeight :
                    data.my[ 1 ] === "bottom" ?
                        data.elemHeight :
                        0,
                atOffset = data.at[ 1 ] === "top" ?
                    data.targetHeight :
                    data.at[ 1 ] === "bottom" ?
                        -data.targetHeight :
                        0,
                offset = -2 * data.offset[ 1 ],
                newOverTop,
                newOverBottom;
            if ( overTop < 0 ) {
                newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
                if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {
                    position.top += myOffset + atOffset + offset;
                }
            }
            else if ( overBottom > 0 ) {
                newOverTop = position.top -  data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
                if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
                    position.top += myOffset + atOffset + offset;
                }
            }
        }
    },
    flipfit: {
        left: function() {
            $.ui.position.flip.left.apply( this, arguments );
            $.ui.position.fit.left.apply( this, arguments );
        },
        top: function() {
            $.ui.position.flip.top.apply( this, arguments );
            $.ui.position.fit.top.apply( this, arguments );
        }
    }
};

// fraction support test
(function () {
    var testElement, testElementParent, testElementStyle, offsetLeft, i,
        body = document.getElementsByTagName( "body" )[ 0 ],
        div = document.createElement( "div" );

    //Create a "fake body" for testing based on method used in jQuery.support
    testElement = document.createElement( body ? "div" : "body" );
    testElementStyle = {
        visibility: "hidden",
        width: 0,
        height: 0,
        border: 0,
        margin: 0,
        background: "none"
    };
    if ( body ) {
        $.extend( testElementStyle, {
            position: "absolute",
            left: "-1000px",
            top: "-1000px"
        });
    }
    for ( i in testElementStyle ) {
        testElement.style[ i ] = testElementStyle[ i ];
    }
    testElement.appendChild( div );
    testElementParent = body || document.documentElement;
    testElementParent.insertBefore( testElement, testElementParent.firstChild );

    div.style.cssText = "position: absolute; left: 10.7432222px;";

    offsetLeft = $( div ).offset().left;
    $.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;

    testElement.innerHTML = "";
    testElementParent.removeChild( testElement );
})();

// DEPRECATED
if ( $.uiBackCompat !== false ) {
    // offset option
    (function( $ ) {
        var _position = $.fn.position;
        $.fn.position = function( options ) {
            if ( !options || !options.offset ) {
                return _position.call( this, options );
            }
            var offset = options.offset.split( " " ),
                at = options.at.split( " " );
            if ( offset.length === 1 ) {
                offset[ 1 ] = offset[ 0 ];
            }
            if ( /^\d/.test( offset[ 0 ] ) ) {
                offset[ 0 ] = "+" + offset[ 0 ];
            }
            if ( /^\d/.test( offset[ 1 ] ) ) {
                offset[ 1 ] = "+" + offset[ 1 ];
            }
            if ( at.length === 1 ) {
                if ( /left|center|right/.test( at[ 0 ] ) ) {
                    at[ 1 ] = "center";
                } else {
                    at[ 1 ] = at[ 0 ];
                    at[ 0 ] = "center";
                }
            }
            return _position.call( this, $.extend( options, {
                at: at[ 0 ] + offset[ 0 ] + " " + at[ 1 ] + offset[ 1 ],
                offset: undefined
            } ) );
        };
    }( jQuery ) );
}

}( jQuery ) );
/*!
 * jQuery UI Autocomplete 1.9.0
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/autocomplete/
 *
 * Depends:
 *    jquery.ui.core.js
 *    jquery.ui.widget.js
 *    jquery.ui.position.js
 *    jquery.ui.menu.js
 */
(function( $, undefined ) {

// used to prevent race conditions with remote data sources
var requestIndex = 0;

$.widget( "ui.autocomplete", {
    version: "1.9.0",
    defaultElement: "<input>",
    options: {
        appendTo: "body",
        autoFocus: false,
        delay: 300,
        minLength: 1,
        position: {
            my: "left top",
            at: "left bottom",
            collision: "none"
        },
        source: null,

        // callbacks
        change: null,
        close: null,
        focus: null,
        open: null,
        response: null,
        search: null,
        select: null
    },

    pending: 0,

    _create: function() {
        // Some browsers only repeat keydown events, not keypress events,
        // so we use the suppressKeyPress flag to determine if we've already
        // handled the keydown event. #7269
        // Unfortunately the code for & in keypress is the same as the up arrow,
        // so we use the suppressKeyPressRepeat flag to avoid handling keypress
        // events when we know the keydown event was used to modify the
        // search term. #7799
        var suppressKeyPress, suppressKeyPressRepeat, suppressInput;

        this.isMultiLine = this._isMultiLine();
        this.valueMethod = this.element[ this.element.is( "input,textarea" ) ? "val" : "text" ];
        this.isNewMenu = true;

        this.element
            .addClass( "ui-autocomplete-input" )
            .attr( "autocomplete", "off" );

        this._on({
            keydown: function( event ) {
                if ( this.element.prop( "readOnly" ) ) {
                    suppressKeyPress = true;
                    suppressInput = true;
                    suppressKeyPressRepeat = true;
                    return;
                }

                suppressKeyPress = false;
                suppressInput = false;
                suppressKeyPressRepeat = false;
                var keyCode = $.ui.keyCode;
                switch( event.keyCode ) {
                case keyCode.PAGE_UP:
                    suppressKeyPress = true;
                    this._move( "previousPage", event );
                    break;
                case keyCode.PAGE_DOWN:
                    suppressKeyPress = true;
                    this._move( "nextPage", event );
                    break;
                case keyCode.UP:
                    suppressKeyPress = true;
                    this._keyEvent( "previous", event );
                    break;
                case keyCode.DOWN:
                    suppressKeyPress = true;
                    this._keyEvent( "next", event );
                    break;
                case keyCode.ENTER:
                case keyCode.NUMPAD_ENTER:
                    // when menu is open and has focus
                    if ( this.menu.active ) {
                        // #6055 - Opera still allows the keypress to occur
                        // which causes forms to submit
                        suppressKeyPress = true;
                        event.preventDefault();
                        this.menu.select( event );
                    }
                    break;
                case keyCode.TAB:
                    if ( this.menu.active ) {
                        this.menu.select( event );
                    }
                    break;
                case keyCode.ESCAPE:
                    if ( this.menu.element.is( ":visible" ) ) {
                        this._value( this.term );
                        this.close( event );
                        // Different browsers have different default behavior for escape
                        // Single press can mean undo or clear
                        // Double press in IE means clear the whole form
                        event.preventDefault();
                    }
                    break;
                default:
                    suppressKeyPressRepeat = true;
                    // search timeout should be triggered before the input value is changed
                    this._searchTimeout( event );
                    break;
                }
            },
            keypress: function( event ) {
                if ( suppressKeyPress ) {
                    suppressKeyPress = false;
                    event.preventDefault();
                    return;
                }
                if ( suppressKeyPressRepeat ) {
                    return;
                }

                // replicate some key handlers to allow them to repeat in Firefox and Opera
                var keyCode = $.ui.keyCode;
                switch( event.keyCode ) {
                case keyCode.PAGE_UP:
                    this._move( "previousPage", event );
                    break;
                case keyCode.PAGE_DOWN:
                    this._move( "nextPage", event );
                    break;
                case keyCode.UP:
                    this._keyEvent( "previous", event );
                    break;
                case keyCode.DOWN:
                    this._keyEvent( "next", event );
                    break;
                }
            },
            input: function( event ) {
                if ( suppressInput ) {
                    suppressInput = false;
                    event.preventDefault();
                    return;
                }
                this._searchTimeout( event );
            },
            focus: function() {
                this.selectedItem = null;
                this.previous = this._value();
            },
            blur: function( event ) {
                if ( this.cancelBlur ) {
                    delete this.cancelBlur;
                    return;
                }

                clearTimeout( this.searching );
                this.close( event );
                this._change( event );
            }
        });

        this._initSource();
        this.menu = $( "<ul>" )
            .addClass( "ui-autocomplete" )
            .appendTo( this.document.find( this.options.appendTo || "body" )[ 0 ] )
            .menu({
                // custom key handling for now
                input: $(),
                // disable ARIA support, the live region takes care of that
                role: null
            })
            .zIndex( this.element.zIndex() + 1 )
            .hide()
            .data( "menu" );
        this._on( this.menu.element, {
            mousedown: function( event ) {
                // prevent moving focus out of the text field
                event.preventDefault();

                // IE doesn't prevent moving focus even with event.preventDefault()
                // so we set a flag to know when we should ignore the blur event
                this.cancelBlur = true;
                this._delay(function() {
                    delete this.cancelBlur;
                });

                // clicking on the scrollbar causes focus to shift to the body
                // but we can't detect a mouseup or a click immediately afterward
                // so we have to track the next mousedown and close the menu if
                // the user clicks somewhere outside of the autocomplete
                var menuElement = this.menu.element[ 0 ];
                if ( !$( event.target ).closest( ".ui-menu-item" ).length ) {
                    this._delay(function() {
                        var that = this;
                        this.document.one( "mousedown", function( event ) {
                            if ( event.target !== that.element[ 0 ] &&
                                    event.target !== menuElement &&
                                    !$.contains( menuElement, event.target ) ) {
                                that.close();
                            }
                        });
                    });
                }
            },
            menufocus: function( event, ui ) {
                // #7024 - Prevent accidental activation of menu items in Firefox
                if ( this.isNewMenu ) {
                    this.isNewMenu = false;
                    if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {
                        this.menu.blur();

                        this.document.one( "mousemove", function() {
                            $( event.target ).trigger( event.originalEvent );
                        });

                        return;
                    }
                }

                // back compat for _renderItem using item.autocomplete, via #7810
                // TODO remove the fallback, see #8156
                var item = ui.item.data( "ui-autocomplete-item" ) || ui.item.data( "item.autocomplete" );
                if ( false !== this._trigger( "focus", event, { item: item } ) ) {
                    // use value to match what will end up in the input, if it was a key event
                    if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {
                        this._value( item.value );
                    }
                } else {
                    // Normally the input is populated with the item's value as the
                    // menu is navigated, causing screen readers to notice a change and
                    // announce the item. Since the focus event was canceled, this doesn't
                    // happen, so we update the live region so that screen readers can
                    // still notice the change and announce it.
                    this.liveRegion.text( item.value );
                }
            },
            menuselect: function( event, ui ) {
                // back compat for _renderItem using item.autocomplete, via #7810
                // TODO remove the fallback, see #8156
                var item = ui.item.data( "ui-autocomplete-item" ) || ui.item.data( "item.autocomplete" ),
                    previous = this.previous;

                // only trigger when focus was lost (click on menu)
                if ( this.element[0] !== this.document[0].activeElement ) {
                    this.element.focus();
                    this.previous = previous;
                    // #6109 - IE triggers two focus events and the second
                    // is asynchronous, so we need to reset the previous
                    // term synchronously and asynchronously :-(
                    this._delay(function() {
                        this.previous = previous;
                        this.selectedItem = item;
                    });
                }

                if ( false !== this._trigger( "select", event, { item: item } ) ) {
                    this._value( item.value );
                }
                // reset the term after the select event
                // this allows custom select handling to work properly
                this.term = this._value();

                this.close( event );
                this.selectedItem = item;
            }
        });

        this.liveRegion = $( "<span>", {
                role: "status",
                "aria-live": "polite"
            })
            .addClass( "ui-helper-hidden-accessible" )
            .insertAfter( this.element );

        if ( $.fn.bgiframe ) {
             this.menu.element.bgiframe();
        }

        // turning off autocomplete prevents the browser from remembering the
        // value when navigating through history, so we re-enable autocomplete
        // if the page is unloaded before the widget is destroyed. #7790
        this._on( this.window, {
            beforeunload: function() {
                this.element.removeAttr( "autocomplete" );
            }
        });
    },

    _destroy: function() {
        clearTimeout( this.searching );
        this.element
            .removeClass( "ui-autocomplete-input" )
            .removeAttr( "autocomplete" );
        this.menu.element.remove();
        this.liveRegion.remove();
    },

    _setOption: function( key, value ) {
        this._super( key, value );
        if ( key === "source" ) {
            this._initSource();
        }
        if ( key === "appendTo" ) {
            this.menu.element.appendTo( this.document.find( value || "body" )[0] );
        }
        if ( key === "disabled" && value && this.xhr ) {
            this.xhr.abort();
        }
    },

    _isMultiLine: function() {
        // Textareas are always multi-line
        if ( this.element.is( "textarea" ) ) {
            return true;
        }
        // Inputs are always single-line, even if inside a contentEditable element
        // IE also treats inputs as contentEditable
        if ( this.element.is( "input" ) ) {
            return false;
        }
        // All other element types are determined by whether or not they're contentEditable
        return this.element.prop( "isContentEditable" );
    },

    _initSource: function() {
        var array, url,
            that = this;
        if ( $.isArray(this.options.source) ) {
            array = this.options.source;
            this.source = function( request, response ) {
                response( $.ui.autocomplete.filter( array, request.term ) );
            };
        } else if ( typeof this.options.source === "string" ) {
            url = this.options.source;
            this.source = function( request, response ) {
                if ( that.xhr ) {
                    that.xhr.abort();
                }
                that.xhr = $.ajax({
                    url: url,
                    data: request,
                    dataType: "json",
                    success: function( data, status ) {
                        response( data );
                    },
                    error: function() {
                        response( [] );
                    }
                });
            };
        } else {
            this.source = this.options.source;
        }
    },

    _searchTimeout: function( event ) {
        clearTimeout( this.searching );
        this.searching = this._delay(function() {
            // only search if the value has changed
            if ( this.term !== this._value() ) {
                this.selectedItem = null;
                this.search( null, event );
            }
        }, this.options.delay );
    },

    search: function( value, event ) {
        value = value != null ? value : this._value();

        // always save the actual value, not the one passed as an argument
        this.term = this._value();

        if ( value.length < this.options.minLength ) {
            return this.close( event );
        }

        if ( this._trigger( "search", event ) === false ) {
            return;
        }

        return this._search( value );
    },

    _search: function( value ) {
        this.pending++;
        this.element.addClass( "ui-autocomplete-loading" );
        this.cancelSearch = false;

        this.source( { term: value }, this._response() );
    },

    _response: function() {
        var that = this,
            index = ++requestIndex;

        return function( content ) {
            if ( index === requestIndex ) {
                that.__response( content );
            }

            that.pending--;
            if ( !that.pending ) {
                that.element.removeClass( "ui-autocomplete-loading" );
            }
        };
    },

    __response: function( content ) {
        if ( content ) {
            content = this._normalize( content );
        }
        this._trigger( "response", null, { content: content } );
        if ( !this.options.disabled && content && content.length && !this.cancelSearch ) {
            this._suggest( content );
            this._trigger( "open" );
        } else {
            // use ._close() instead of .close() so we don't cancel future searches
            this._close();
        }
    },

    close: function( event ) {
        this.cancelSearch = true;
        this._close( event );
    },

    _close: function( event ) {
        if ( this.menu.element.is( ":visible" ) ) {
            this.menu.element.hide();
            this.menu.blur();
            this.isNewMenu = true;
            this._trigger( "close", event );
        }
    },

    _change: function( event ) {
        if ( this.previous !== this._value() ) {
            this._trigger( "change", event, { item: this.selectedItem } );
        }
    },

    _normalize: function( items ) {
        // assume all items have the right format when the first item is complete
        if ( items.length && items[0].label && items[0].value ) {
            return items;
        }
        return $.map( items, function( item ) {
            if ( typeof item === "string" ) {
                return {
                    label: item,
                    value: item
                };
            }
            return $.extend({
                label: item.label || item.value,
                value: item.value || item.label
            }, item );
        });
    },

    _suggest: function( items ) {
        var ul = this.menu.element
            .empty()
            .zIndex( this.element.zIndex() + 1 );
        this._renderMenu( ul, items );
        this.menu.refresh();

        // size and position menu
        ul.show();
        this._resizeMenu();
        ul.position( $.extend({
            of: this.element
        }, this.options.position ));

        if ( this.options.autoFocus ) {
            this.menu.next();
        }
    },

    _resizeMenu: function() {
        var ul = this.menu.element;
        ul.outerWidth( Math.max(
            // Firefox wraps long text (possibly a rounding bug)
            // so we add 1px to avoid the wrapping (#7513)
            ul.width( "" ).outerWidth() + 1,
            this.element.outerWidth()
        ) );
    },

    _renderMenu: function( ul, items ) {
        var that = this;
        $.each( items, function( index, item ) {
            that._renderItemData( ul, item );
        });
    },

    _renderItemData: function( ul, item ) {
        return this._renderItem( ul, item ).data( "ui-autocomplete-item", item );
    },

    _renderItem: function( ul, item ) {
        return $( "<li>" )
            .append( $( "<a>" ).text( item.label ) )
            .appendTo( ul );
    },

    _move: function( direction, event ) {
        if ( !this.menu.element.is( ":visible" ) ) {
            this.search( null, event );
            return;
        }
        if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||
                this.menu.isLastItem() && /^next/.test( direction ) ) {
            this._value( this.term );
            this.menu.blur();
            return;
        }
        this.menu[ direction ]( event );
    },

    widget: function() {
        return this.menu.element;
    },

    _value: function( value ) {
        return this.valueMethod.apply( this.element, arguments );
    },

    _keyEvent: function( keyEvent, event ) {
        if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
            this._move( keyEvent, event );

            // prevents moving cursor to beginning/end of the text field in some browsers
            event.preventDefault();
        }
    }
});

$.extend( $.ui.autocomplete, {
    escapeRegex: function( value ) {
        return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    },
    filter: function(array, term) {
        var matcher = new RegExp( $.ui.autocomplete.escapeRegex(term), "i" );
        return $.grep( array, function(value) {
            return matcher.test( value.label || value.value || value );
        });
    }
});


// live region extension, adding a `messages` option
// NOTE: This is an experimental API. We are still investigating
// a full solution for string manipulation and internationalization.
$.widget( "ui.autocomplete", $.ui.autocomplete, {
    options: {
        messages: {
            noResults: "No search results.",
            results: function( amount ) {
                return amount + ( amount > 1 ? " results are" : " result is" ) +
                    " available, use up and down arrow keys to navigate.";
            }
        }
    },

    __response: function( content ) {
        var message;
        this._superApply( arguments );
        if ( this.options.disabled || this.cancelSearch ) {
            return;
        }
        if ( content && content.length ) {
            message = this.options.messages.results( content.length );
        } else {
            message = this.options.messages.noResults;
        }
        this.liveRegion.text( message );
    }
});


}( jQuery ));
/*!
 * jQuery UI Menu 1.9.0
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/menu/
 *
 * Depends:
 *    jquery.ui.core.js
 *    jquery.ui.widget.js
 *    jquery.ui.position.js
 */
(function( $, undefined ) {

var mouseHandled = false;

$.widget( "ui.menu", {
    version: "1.9.0",
    defaultElement: "<ul>",
    delay: 300,
    options: {
        icons: {
            submenu: "ui-icon-carat-1-e"
        },
        menus: "ul",
        position: {
            my: "left top",
            at: "right top"
        },
        role: "menu",

        // callbacks
        blur: null,
        focus: null,
        select: null
    },

    _create: function() {
        this.activeMenu = this.element;
        this.element
            .uniqueId()
            .addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
            .toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length )
            .attr({
                role: this.options.role,
                tabIndex: 0
            })
            // need to catch all clicks on disabled menu
            // not possible through _on
            .bind( "click" + this.eventNamespace, $.proxy(function( event ) {
                if ( this.options.disabled ) {
                    event.preventDefault();
                }
            }, this ));

        if ( this.options.disabled ) {
            this.element
                .addClass( "ui-state-disabled" )
                .attr( "aria-disabled", "true" );
        }

        this._on({
            // Prevent focus from sticking to links inside menu after clicking
            // them (focus should always stay on UL during navigation).
            "mousedown .ui-menu-item > a": function( event ) {
                event.preventDefault();
            },
            "click .ui-state-disabled > a": function( event ) {
                event.preventDefault();
            },
            "click .ui-menu-item:has(a)": function( event ) {
                var target = $( event.target ).closest( ".ui-menu-item" );
                if ( !mouseHandled && target.not( ".ui-state-disabled" ).length ) {
                    mouseHandled = true;

                    this.select( event );
                    // Open submenu on click
                    if ( target.has( ".ui-menu" ).length ) {
                        this.expand( event );
                    } else if ( !this.element.is( ":focus" ) ) {
                        // Redirect focus to the menu
                        this.element.trigger( "focus", [ true ] );

                        // If the active item is on the top level, let it stay active.
                        // Otherwise, blur the active item since it is no longer visible.
                        if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {
                            clearTimeout( this.timer );
                        }
                    }
                }
            },
            "mouseenter .ui-menu-item": function( event ) {
                var target = $( event.currentTarget );
                // Remove ui-state-active class from siblings of the newly focused menu item
                // to avoid a jump caused by adjacent elements both having a class with a border
                target.siblings().children( ".ui-state-active" ).removeClass( "ui-state-active" );
                this.focus( event, target );
            },
            mouseleave: "collapseAll",
            "mouseleave .ui-menu": "collapseAll",
            focus: function( event, keepActiveItem ) {
                // If there's already an active item, keep it active
                // If not, activate the first item
                var item = this.active || this.element.children( ".ui-menu-item" ).eq( 0 );

                if ( !keepActiveItem ) {
                    this.focus( event, item );
                }
            },
            blur: function( event ) {
                this._delay(function() {
                    if ( !$.contains( this.element[0], this.document[0].activeElement ) ) {
                        this.collapseAll( event );
                    }
                });
            },
            keydown: "_keydown"
        });

        this.refresh();

        // Clicks outside of a menu collapse any open menus
        this._on( this.document, {
            click: function( event ) {
                if ( !$( event.target ).closest( ".ui-menu" ).length ) {
                    this.collapseAll( event );
                }

                // Reset the mouseHandled flag
                mouseHandled = false;
            }
        });
    },

    _destroy: function() {
        // Destroy (sub)menus
        this.element
            .removeAttr( "aria-activedescendant" )
            .find( ".ui-menu" ).andSelf()
                .removeClass( "ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons" )
                .removeAttr( "role" )
                .removeAttr( "tabIndex" )
                .removeAttr( "aria-labelledby" )
                .removeAttr( "aria-expanded" )
                .removeAttr( "aria-hidden" )
                .removeAttr( "aria-disabled" )
                .removeUniqueId()
                .show();

        // Destroy menu items
        this.element.find( ".ui-menu-item" )
            .removeClass( "ui-menu-item" )
            .removeAttr( "role" )
            .removeAttr( "aria-disabled" )
            .children( "a" )
                .removeUniqueId()
                .removeClass( "ui-corner-all ui-state-hover" )
                .removeAttr( "tabIndex" )
                .removeAttr( "role" )
                .removeAttr( "aria-haspopup" )
                .children().each( function() {
                    var elem = $( this );
                    if ( elem.data( "ui-menu-submenu-carat" ) ) {
                        elem.remove();
                    }
                });

        // Destroy menu dividers
        this.element.find( ".ui-menu-divider" ).removeClass( "ui-menu-divider ui-widget-content" );
    },

    _keydown: function( event ) {
        var match, prev, character, skip, regex,
            preventDefault = true;

        function escape( value ) {
            return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
        }

        switch ( event.keyCode ) {
        case $.ui.keyCode.PAGE_UP:
            this.previousPage( event );
            break;
        case $.ui.keyCode.PAGE_DOWN:
            this.nextPage( event );
            break;
        case $.ui.keyCode.HOME:
            this._move( "first", "first", event );
            break;
        case $.ui.keyCode.END:
            this._move( "last", "last", event );
            break;
        case $.ui.keyCode.UP:
            this.previous( event );
            break;
        case $.ui.keyCode.DOWN:
            this.next( event );
            break;
        case $.ui.keyCode.LEFT:
            this.collapse( event );
            break;
        case $.ui.keyCode.RIGHT:
            if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
                this.expand( event );
            }
            break;
        case $.ui.keyCode.ENTER:
        case $.ui.keyCode.SPACE:
            this._activate( event );
            break;
        case $.ui.keyCode.ESCAPE:
            this.collapse( event );
            break;
        default:
            preventDefault = false;
            prev = this.previousFilter || "";
            character = String.fromCharCode( event.keyCode );
            skip = false;

            clearTimeout( this.filterTimer );

            if ( character === prev ) {
                skip = true;
            } else {
                character = prev + character;
            }

            regex = new RegExp( "^" + escape( character ), "i" );
            match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
                return regex.test( $( this ).children( "a" ).text() );
            });
            match = skip && match.index( this.active.next() ) !== -1 ?
                this.active.nextAll( ".ui-menu-item" ) :
                match;

            // If no matches on the current filter, reset to the last character pressed
            // to move down the menu to the first item that starts with that character
            if ( !match.length ) {
                character = String.fromCharCode( event.keyCode );
                regex = new RegExp( "^" + escape( character ), "i" );
                match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
                    return regex.test( $( this ).children( "a" ).text() );
                });
            }

            if ( match.length ) {
                this.focus( event, match );
                if ( match.length > 1 ) {
                    this.previousFilter = character;
                    this.filterTimer = this._delay(function() {
                        delete this.previousFilter;
                    }, 1000 );
                } else {
                    delete this.previousFilter;
                }
            } else {
                delete this.previousFilter;
            }
        }

        if ( preventDefault ) {
            event.preventDefault();
        }
    },

    _activate: function( event ) {
        if ( !this.active.is( ".ui-state-disabled" ) ) {
            if ( this.active.children( "a[aria-haspopup='true']" ).length ) {
                this.expand( event );
            } else {
                this.select( event );
            }
        }
    },

    refresh: function() {
        // Initialize nested menus
        var menus,
            icon = this.options.icons.submenu,
            submenus = this.element.find( this.options.menus + ":not(.ui-menu)" )
                .addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
                .hide()
                .attr({
                    role: this.options.role,
                    "aria-hidden": "true",
                    "aria-expanded": "false"
                });

        // Don't refresh list items that are already adapted
        menus = submenus.add( this.element );

        menus.children( ":not(.ui-menu-item):has(a)" )
            .addClass( "ui-menu-item" )
            .attr( "role", "presentation" )
            .children( "a" )
                .uniqueId()
                .addClass( "ui-corner-all" )
                .attr({
                    tabIndex: -1,
                    role: this._itemRole()
                });

        // Initialize unlinked menu-items containing spaces and/or dashes only as dividers
        menus.children( ":not(.ui-menu-item)" ).each(function() {
            var item = $( this );
            // hyphen, em dash, en dash
            if ( !/[^\-вЂ”вЂ“\s]/.test( item.text() ) ) {
                item.addClass( "ui-widget-content ui-menu-divider" );
            }
        });

        // Add aria-disabled attribute to any disabled menu item
        menus.children( ".ui-state-disabled" ).attr( "aria-disabled", "true" );

        submenus.each(function() {
            var menu = $( this ),
                item = menu.prev( "a" ),
                submenuCarat = $( "<span>" )
                    .addClass( "ui-menu-icon ui-icon " + icon )
                    .data( "ui-menu-submenu-carat", true );

            item
                .attr( "aria-haspopup", "true" )
                .prepend( submenuCarat );
            menu.attr( "aria-labelledby", item.attr( "id" ) );
        });

        // If the active item has been removed, blur the menu
        if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
            this.blur();
        }
    },

    _itemRole: function() {
        return {
            menu: "menuitem",
            listbox: "option"
        }[ this.options.role ];
    },

    focus: function( event, item ) {
        var nested, focused;
        this.blur( event, event && event.type === "focus" );

        this._scrollIntoView( item );

        this.active = item.first();
        focused = this.active.children( "a" ).addClass( "ui-state-focus" );
        // Only update aria-activedescendant if there's a role
        // otherwise we assume focus is managed elsewhere
        if ( this.options.role ) {
            this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
        }

        // Highlight active parent menu item, if any
        this.active
            .parent()
            .closest( ".ui-menu-item" )
            .children( "a:first" )
            .addClass( "ui-state-active" );

        if ( event && event.type === "keydown" ) {
            this._close();
        } else {
            this.timer = this._delay(function() {
                this._close();
            }, this.delay );
        }

        nested = item.children( ".ui-menu" );
        if ( nested.length && ( /^mouse/.test( event.type ) ) ) {
            this._startOpening(nested);
        }
        this.activeMenu = item.parent();

        this._trigger( "focus", event, { item: item } );
    },

    _scrollIntoView: function( item ) {
        var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
        if ( this._hasScroll() ) {
            borderTop = parseFloat( $.css( this.activeMenu[0], "borderTopWidth" ) ) || 0;
            paddingTop = parseFloat( $.css( this.activeMenu[0], "paddingTop" ) ) || 0;
            offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
            scroll = this.activeMenu.scrollTop();
            elementHeight = this.activeMenu.height();
            itemHeight = item.height();

            if ( offset < 0 ) {
                this.activeMenu.scrollTop( scroll + offset );
            } else if ( offset + itemHeight > elementHeight ) {
                this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
            }
        }
    },

    blur: function( event, fromFocus ) {
        if ( !fromFocus ) {
            clearTimeout( this.timer );
        }

        if ( !this.active ) {
            return;
        }

        this.active.children( "a" ).removeClass( "ui-state-focus" );
        this.active = null;

        this._trigger( "blur", event, { item: this.active } );
    },

    _startOpening: function( submenu ) {
        clearTimeout( this.timer );

        // Don't open if already open fixes a Firefox bug that caused a .5 pixel
        // shift in the submenu position when mousing over the carat icon
        if ( submenu.attr( "aria-hidden" ) !== "true" ) {
            return;
        }

        this.timer = this._delay(function() {
            this._close();
            this._open( submenu );
        }, this.delay );
    },

    _open: function( submenu ) {
        var position = $.extend({
            of: this.active
        }, this.options.position );

        clearTimeout( this.timer );
        this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )
            .hide()
            .attr( "aria-hidden", "true" );

        submenu
            .show()
            .removeAttr( "aria-hidden" )
            .attr( "aria-expanded", "true" )
            .position( position );
    },

    collapseAll: function( event, all ) {
        clearTimeout( this.timer );
        this.timer = this._delay(function() {
            // If we were passed an event, look for the submenu that contains the event
            var currentMenu = all ? this.element :
                $( event && event.target ).closest( this.element.find( ".ui-menu" ) );

            // If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
            if ( !currentMenu.length ) {
                currentMenu = this.element;
            }

            this._close( currentMenu );

            this.blur( event );
            this.activeMenu = currentMenu;
        }, this.delay );
    },

    // With no arguments, closes the currently active menu - if nothing is active
    // it closes all menus.  If passed an argument, it will search for menus BELOW
    _close: function( startMenu ) {
        if ( !startMenu ) {
            startMenu = this.active ? this.active.parent() : this.element;
        }

        startMenu
            .find( ".ui-menu" )
                .hide()
                .attr( "aria-hidden", "true" )
                .attr( "aria-expanded", "false" )
            .end()
            .find( "a.ui-state-active" )
                .removeClass( "ui-state-active" );
    },

    collapse: function( event ) {
        var newItem = this.active &&
            this.active.parent().closest( ".ui-menu-item", this.element );
        if ( newItem && newItem.length ) {
            this._close();
            this.focus( event, newItem );
        }
    },

    expand: function( event ) {
        var newItem = this.active &&
            this.active
                .children( ".ui-menu " )
                .children( ".ui-menu-item" )
                .first();

        if ( newItem && newItem.length ) {
            this._open( newItem.parent() );

            // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
            this._delay(function() {
                this.focus( event, newItem );
            });
        }
    },

    next: function( event ) {
        this._move( "next", "first", event );
    },

    previous: function( event ) {
        this._move( "prev", "last", event );
    },

    isFirstItem: function() {
        return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
    },

    isLastItem: function() {
        return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
    },

    _move: function( direction, filter, event ) {
        var next;
        if ( this.active ) {
            if ( direction === "first" || direction === "last" ) {
                next = this.active
                    [ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
                    .eq( -1 );
            } else {
                next = this.active
                    [ direction + "All" ]( ".ui-menu-item" )
                    .eq( 0 );
            }
        }
        if ( !next || !next.length || !this.active ) {
            next = this.activeMenu.children( ".ui-menu-item" )[ filter ]();
        }

        this.focus( event, next );
    },

    nextPage: function( event ) {
        var item, base, height;

        if ( !this.active ) {
            this.next( event );
            return;
        }
        if ( this.isLastItem() ) {
            return;
        }
        if ( this._hasScroll() ) {
            base = this.active.offset().top;
            height = this.element.height();
            this.active.nextAll( ".ui-menu-item" ).each(function() {
                item = $( this );
                return item.offset().top - base - height < 0;
            });

            this.focus( event, item );
        } else {
            this.focus( event, this.activeMenu.children( ".ui-menu-item" )
                [ !this.active ? "first" : "last" ]() );
        }
    },

    previousPage: function( event ) {
        var item, base, height;
        if ( !this.active ) {
            this.next( event );
            return;
        }
        if ( this.isFirstItem() ) {
            return;
        }
        if ( this._hasScroll() ) {
            base = this.active.offset().top;
            height = this.element.height();
            this.active.prevAll( ".ui-menu-item" ).each(function() {
                item = $( this );
                return item.offset().top - base + height > 0;
            });

            this.focus( event, item );
        } else {
            this.focus( event, this.activeMenu.children( ".ui-menu-item" ).first() );
        }
    },

    _hasScroll: function() {
        return this.element.outerHeight() < this.element.prop( "scrollHeight" );
    },

    select: function( event ) {
        // TODO: It should never be possible to not have an active item at this
        // point, but the tests don't trigger mouseenter before click.
        this.active = this.active || $( event.target ).closest( ".ui-menu-item" );
        var ui = { item: this.active };
        if ( !this.active.has( ".ui-menu" ).length ) {
            this.collapseAll( event, true );
        }
        this._trigger( "select", event, ui );
    }
});

}( jQuery ));
Kontur.Module("Kontur.Tracker", function ($, global, storage) {
    var self = this,
        window = global.get(),
        TRAKER_SESSION_COOKIE_NAME = 'ktr_sid',
        REFERER_KEY_NAME = 'referer',
        START_PAGE_KEY_NAME = 'start_page',
        referer = window.document.referrer,
        pageUrl = window.location.href;

    $(function () {
        if (hostName(pageUrl) != hostName(referer)) {
            $.cookie(TRAKER_SESSION_COOKIE_NAME, 1, { path: '/' });
            var refererStoreValue = referer ? referer : " ";//IE8 Crash if set empty value in local storage

            setIfChanged(REFERER_KEY_NAME, refererStoreValue, 'tracker-set-referer');
            setIfChanged(START_PAGE_KEY_NAME, pageUrl, 'tracker-set-startPage');
        }
    });

    function setIfChanged(cookieName, cookieValue, successSetEventName) {
        if (getValidSessionStorageItem(cookieName) !== cookieValue) {
            storage.setItem(cookieName, cookieValue);
            $(window).trigger(successSetEventName, cookieValue);
        }
    }

    self.getReferer = function () {
        return getValidSessionStorageItem(REFERER_KEY_NAME);
    }

    self.getStartPage = function () {
        return getValidSessionStorageItem(START_PAGE_KEY_NAME);
    }

    function getValidSessionStorageItem(key) {
        if (!sessionDataIsValid()) {
            return "";
        }
        return storage.getItem(key);
    }

    function sessionDataIsValid() {
        return $.cookie(TRAKER_SESSION_COOKIE_NAME) != null;
    }

    function hostName(url) {
        if (!url) {
            return "";
        }
        var a = document.createElement('a');
        a.href = url;
        return a.hostname;
    }

}, [jQuery, Kontur.Global, Kontur.Storage]);
Kontur.Module('Kontur.Partnership.ReferalLinksStatistics', function ($) {
    var currentUrl = document.location.href,
        referer = document.referrer,
        userAgent = navigator.userAgent,
        siteUrl,
        statisticsUrl,
        statisticsWereTryingToSend = false;

    this.initialize = function(options) {
        siteUrl = options.siteUrl;
        statisticsUrl = options.statisticsUrl;

        $(window).on('tracker-set-referer', trySendStatistics);
        $(window).on('tracker-set-startPage', trySendStatistics);
    };

    function trySendStatistics() {
        if (!statisticsWereTryingToSend) {
            if (isReferalLinkValid() && isRefererValid() && !isCrawler()) {
                $.post(statisticsUrl, { partnerLink: currentUrl });
            };
            statisticsWereTryingToSend = true;
        }
    };

    function isReferalLinkValid() {
        var validatReferalLinkRegex = /(\?|&)p=[z|f]{0,1}\d+/i;
        return validatReferalLinkRegex.test(currentUrl);
    };

    function isRefererValid() {
        return referer.substring(0, siteUrl.length) !== siteUrl;
    };

    function isCrawler() {
        var crawlersRegex = /bot|crawl|spider|yandex|google|Rambler|Yahoo|MSN|YaDirect|slurp/i;
        return crawlersRegex.test(userAgent);
    };
},[jQuery]);
Kontur.Module('Kontur.Framework.InputPassword', function ($) {
    this.initialize = function (options) {
        var options = options || {};

        var $container = $('.form-input-password-wrap'),
            viewPassClass = 'view';

        $.each($container, function (i, $block) {
            var $btn = $('.form-input-password-btn', $block),
                $input = $('.form-input', $block);

            $btn.on('click', function (e) {
                var $el = $input.get(0),
                    type = $el.type;

                try {
                    if (type === 'text') {
                        $el.type = 'password';
                        $btn.removeClass(viewPassClass);
                    } else {
                        $el.type = 'text';
                        $btn.addClass(viewPassClass);
                    }
                } catch (e) { //IE 8 and other trash

                    var value = $input.val(),
                        newtype = (type === 'text') ? "password" : "text",
                        $new = $('<input/>', {
                            id: $input.attr("id"),
                            'class': $input.attr("class"),
                            name: $input.attr("name"),
                            type: newtype
                        });
                    
                    $new.val(value);
                    $input.replaceWith($new);

                    if (type === 'text') {
                        $btn.removeClass(viewPassClass);
                    } else {
                        $btn.addClass(viewPassClass);
                    }

                    $input = $new;
                }

                if (options.onChangeType && typeof (options.onChangeType) === "function") {
                    options.onChangeType($el.type);
                }

                return false;
            });
        });
    };
}, [jQuery]);

/*
options {
    onChangeType: function(type) {} //type - new type of input text/password
}
*/;
var Kontur = Kontur || {};
Kontur.GroupHover = (function ($) {
    return {
        init: function () {
            $(document)
                .on('mouseenter', '[data-group-hover]', function() {
                    var val = $(this).data('group-hover');
                    $('[data-group-hover=' + val + ']').addClass('hover');
                })
                .on('mouseout', '[data-group-hover]', function() {
                    var val = $(this).data('group-hover');
                    $('[data-group-hover=' + val + ']').removeClass('hover');
                });
        }
    };
}(jQuery));
var msie_browser = $.browser.msie;
/* IE6 and before ? */
var lteIE6 = function () {
    if (msie_browser && $.browser.version <= 6) {
        return true;
    } else {
        return false;
    }
} ();
/* IE7 and before ? */
var lteIE7 = function () {
    if (msie_browser && $.browser.version <= 7) {
        return true;
    } else {
        return false;
    }
} ();
/* IE8 and before ? */
var lteIE8 = function () {
    if (msie_browser && $.browser.version <= 8) {
        return true;
    } else {
        return false;
    }
} ();
/* IE9 and before ? */
var lteIE9 = function () {
    if (msie_browser && $.browser.version <= 9) {
        return true;
    } else {
        return false;
    }
} ();

$('html').addClass('js_on');
new WOW().init();
Kontur.GroupHover.init();

//Список делегирования
$(document)
    .on('click', '.js-submit', function () {
        $(this).parents('form').submit();
        return false;
    })
    .on('click', '.js-tab', function() {
        var self = $(this);

        if (!self.hasClass('simpleTabs-tab_current')) {
            var idx = self.index();
            var tab = self.data('id');

            $('html, body').animate({
                scrollTop: self.offset().top + 3
            }, 'middle');

            self.addClass('simpleTabs-tab_current').siblings('.simpleTabs-tab_current').removeClass('simpleTabs-tab_current')
                .parents('.simpleTabs-tabs').next('.simpleTabs-tabs-arrow').find('td:eq(' + idx + ')').addClass('simpleTabs-tab_current_arrow').siblings('td').removeClass('simpleTabs-tab_current_arrow');
            $('#' + tab).show().siblings('.simpleTabs-content-item').hide();
        }
    })
    .on('click', '.js-showMoreLink', function() {
        var id = $(this).data('id');
        $(this).hide();
        $('#' + id).slideDown('fast');

        return false;
    });

function fixIE8announce() {
    if ($.browser.msie && $.browser.version == 8) {
        var container = $('.article-announce');
        var articleImage = $('.article-mainImage');
        var articleText = $('.article-announce-text');
        
        if (articleImage.size() > 0 && articleText.size() > 0) {
            if (articleImage.width() > (container.width() / 2)) {
                articleText.width('100%');
            }
        }
    }
}

function InitContentTables() {
    var textTable = $('.text table');
    textTable.each(function () {
        var self = $(this);

        if (self.attr('border') * 1 == 1 > 0) {
            self.removeAttr("border").addClass('style-');
            self.find('tr').first().addClass('first');
        }
    });
}

$(function () {
    //!lteIE7 ? $('select:visible').selectBox() : null;
    
    if (lteIE7) {
        $('.afterBefore').prepend('<span class="before"/>').append('<span class="after"/>');
        $('.visibilityGroupChangeLink .icon_visibilityState').append('<span class="after"/>');
        $('.productButton').append('<span class="productButton-right"></span>');
        $('.button_orange').append('<span class="button_orange-right"></span>');
        $('.button_orange_rounded').append('<span class="after"></span>');
        $('.text ul > li').prepend('<span class="marker">—</span>');
        $('.text blockquote').prepend('<span class="quote">«</span>');
        $('.button-login').append('<span class="after"></span>');
        $('.simpleList-item').prepend('<span class="marker">—</span>');
        $('.sliderOnMain .simpleList-item .marker').html('&#xF00C;');

        $('.sectionBorderHeader-title').append('<span class="sectionBorderHeader-before"></span><span class="sectionBorderHeader-after"></span>');
        $('.community-topMenu-item_current, .question-statistics, .question-state').each(function () {
            $(this)
                .prepend('<span class="before"/>')
                .append('<span class="after"/>');
        });
    }
    if (lteIE8) {
        $('.videoBlock-preview').append('<div class="controlPlay"></div>');

        //ie8. fix. selectbox cut long options
        var el,
            maxWidth;

        $("select").each(function () {
            el = $(this),
                maxWidth = el.css('max-width') !== 'none' ? el.css('max-width') : 'none';
            el.data("origWidth", el.outerWidth())
                .data("maxWidth", maxWidth);
            if (el.is(':visible')) {
                el.css("min-width", el.width());
            }
        }).mouseenter(function () {
            el = $(this);
            //check select in ajax
            if (el.data("origWidth") != el.outerWidth()) {
                el.data("origWidth", el.outerWidth())
                    .css("min-width", el.width());
            }
            el.css({
                'width': 'auto',
                'max-width': 'none'
            });
        }).mouseout(function (e) {
            e = e || event;
            var target = e.relatedTarget || e.toElement;
            if (target != null) {
                revertSelectBoxWidth($(this));
            }
        }).bind("blur change", function () {
            revertSelectBoxWidth($(this));
        });
        function revertSelectBoxWidth(elem) {
            el = elem,
                maxWidth = el.data('maxWidth') !== 'none' ? el.data('maxWidth') : 'none';
            el.css({
                'width': el.data("origWidth"),
                'max-width': maxWidth
            });
        }

    }
    if (lteIE6) {
        $(function() {
            InitContentTables();
            $(window).load(function() {
                $('body').toggleClass('test');
            });
        });
    }

    if (lteIE9) {
        $('.js-quickSearchButtonSubmit').mouseenter(function() {
            $(this).addClass('quick-search-button_hovered');
        }).mouseleave(function() {
            $(this).removeClass('quick-search-button_hovered');
        });
    }
    
    $('.js-anchor').each(function () {
        var self = $(this);

        self.click(function (e) {
            e.preventDefault();

            var destination = $(self.attr('href'));
            $('html, body').animate({ scrollTop: destination.offset().top - 30 }, 'middle');
        });
    });
});
function initArticleFloatingBlock() {
    var $floatedBlock = $('#articleFloatBlock'),
        $bottomBlock = function() {
            if ($('#articlesRelated').size() > 0) {
                return $('#articlesRelated');
            } else
            if ($('.communityQuestion-questionExtras-bottomShadow').size()) {
                return $('.communityQuestion-questionExtras-bottomShadow').first();
            } else {
                return $('.footer');
            }
        }(),
        $content = $('.js-contentBlock'),
        $myWindow = $(window),
        elemLeftCord;

    if ($content.outerHeight() < $floatedBlock.outerHeight()) return;

    checkFloatedBlockState();

    $myWindow
        .scroll(checkFloatedBlockState)
        .resize(checkFloatedBlockState);

    function checkFloatedBlockState() {
        elemLeftCord = $floatedBlock.offset().left;

        if ($myWindow.scrollTop() >= $content.offset().top - 60 && !$floatedBlock.hasClass('article-advertising_fixed')) {
            var w = $floatedBlock.width();
            $floatedBlock
                .removeClass('article-advertising_bottom')
                .addClass('article-advertising_fixed')
                .css({
                    top: 60,
                    width: w,
                    left: elemLeftCord - $(document).scrollLeft()
                });

            $myWindow.bind('resize.fixed scroll.fixed', function () {
                $floatedBlock.css({ left: elemLeftCord - $(document).scrollLeft() });
            });
            
        } else if ($myWindow.scrollTop() <= $content.offset().top - 60) {
            $floatedBlock
                .removeClass('article-advertising_fixed')
                .css({
                    'left': elemLeftCord,
                    width: "auto"
                });
            
        }
        if ($myWindow.scrollTop() + $floatedBlock.outerHeight() + 75 >= $bottomBlock.offset().top && !$floatedBlock.hasClass('article-advertising_bottom')) {

            $myWindow.unbind('resize.fixed');
            $myWindow.unbind('scroll.fixed');

            $floatedBlock
                .removeClass('article-advertising_fixed')
                .addClass('article-advertising_bottom')
                .css({
                    top: $bottomBlock.offset().top - $content.offset().top - $floatedBlock.outerHeight() - 20,
                    left: 'auto'
                });
        }
    }
};

var UpdateStatisticControl = Class.extend({
    defaultOptions: {
        id: '',
        type: '',
        updateStatisticUrl: '',
        sendImmediately: true
    },
    init: function(params) {
        var options = this.options = $.extend({}, this.defaultOptions, params);
        if (false !== options.sendImmediately) {
            this.send();
        }
    },
    send: function (id, type) {
        id = id || this.options.id;
        type = type || this.options.type;
        $.ajax({
            type: 'POST',
            url: this.options.updateStatisticUrl,
            data: { id: id, type: type },
            dataType: 'json'
        });
    }
});

var ArticleLikeControl = Class.extend({
    defaultOptions: {
        context: '#ArticleItem',
        welcomeText: 'Чтобы отметить статью, необходимо войти на сайт'
    },
    init: function (options) {
        var opts = $.extend({}, this.defaultOptions, options);
        this.likesControl = new LikesControl(opts);
    }
});

var ArticleItemController = Class.extend({
    init: function (options) {
        this.commentsLikeControl = new CommentsLikeControl(options);
        this.updateStatisticControl = new UpdateStatisticControl(options);
        this.bookmarkControl = new BookmarkControl();
        $('.articleHeaderLong').insertAfter('.articleHeader');
        Kontur.Widget.QuickSearchBlock.init();
    }
});

var ArticleNewsListController = {
    init: function () {
        var newsList = $('.newsPreviewList-wrap'),
            newsListWrap = $('.tile-inner_news');
        newsList.mouseenter(function() {
            newsListWrap.addClass('active_js');
        });
        newsListWrap.mouseleave(function () {
            $(this).removeClass('active_js');
        });
    }
};
Kontur.Module('Kontur.SubscriptionControl', function($) {
    var options,
        forms,
        emailInputs,
        defaultOptions = {
            blockSelector: '.js-subscription-control-form'
        }

    this.init = function (params) {
        options = $.extend({}, defaultOptions, params);
        forms = $('form', $(options.blockSelector));
        emailInputs = $('[data-bind="subscriptionEmailInput"]');

        initForms();
        bindEvents();
    }

    function initForms() {
        if (forms.length) {
            forms.each(function() {
                var formItem = $(this);
                InitPostSimpleFormAsync(formItem,
                {
                    url: formItem.data('action'),
                    beforeSendCallback: function (form) {
                        var rubricsRaw = getRubricsRaw(form);
                        $('[data-rubrics-raw]', form).val(rubricsRaw);
                    },
                    errorPlacement: function (lastInput, message) {
                        lastInput.closest(".form-input-wrap").append(message);
                    },
                    formErrorPlacement: function(form, errorHtml) {
                        $('.form_subscribe', form).append(errorHtml);
                    },
                    successCallback: function(data, form) {
                        form.trigger('subscribeSuccess');
                        $('[data-bind=hideOnSubmit]:visible').hide();
                    },
                    focusFirstErrorInput: false
                });
            });
        }
    }

    function bindEvents() {
        emailInputs.on('focus', function () {
            var emailInput = $(this);
            var subscriptionBlock = emailInput.parents('.js-subscription-control');

            subscriptionBlock.find($('[data-bind="showOnFocus"]'))
                .removeClass('hide')
                .trigger("subscribeHiddenFieldsShow");

            var defaultValue = emailInput.data('default-value');
            emailInput.val(defaultValue);

            emailInput.off('focus');
        });
    }

    function getRubricsRaw(form) {
        var result = [];
        $('[data-rubric-id]:checked', form).each(function () {
            result.push($(this).data('rubric-id'));
        });
        return result.join();
    }
}, [jQuery]);
var LikesControl = Class.extend({
    defaultOptions: {
        isAuthenticated: false,
        context: 'body',
        onChangeSum: function (counter, likeSum) {
            var text = likeSum;
            if (likeSum > 0) {
                text = '+ ' + likeSum;
                counter.removeClass('likesCount_negative').removeClass('likesCount_null');
                counter.addClass('likesCount_positive');
            } else if (likeSum < 0) {
                text = '&minus; ' + Math.abs(likeSum);
                counter.removeClass('likesCount_positive').removeClass('likesCount_null');
                counter.addClass('likesCount_negative');
            } else {
                counter.removeClass('likesCount_negative').removeClass('likesCount_positive');
                counter.addClass('likesCount_null');
            }
            counter.html(text);
        },
        buildReturnUrl: function(data) {
            return null;
        }
    },
    init: function(options) {
        this.options = $.extend({}, this.defaultOptions, options);
        this.element = $(this.options.context);
        this.proxy = new ObjectLikeProxy();

        this.__bindEvents();
    },
    __bindEvents: function() {
        this.element.on('click', '[data-like-action="like"]', $.proxy(this.__onLiking, this));
        this.element.on('click', '[data-like-action="unlike"]', $.proxy(this.__onUnliking, this));
        $(this.proxy).on('likeSavedEvent', $.proxy(this.__onLikeSaved, this));
    },
    __onLiking: function (e) {
        if (!Kontur.User.isAuthenticated()) return;
        var button = $(e.currentTarget);
        if (button.hasClass('comment-doLike_disabled')) {
            e.preventDefault();
            return;
        }
        
        var data = this.__getObjectData(button);
        this.proxy.like(data);
    },
    __onUnliking: function (e) {
        if (!Kontur.User.isAuthenticated()) return;
        var button = $(e.currentTarget);
        if (button.hasClass('comment-doDislike_disabled')) {
            e.preventDefault();
            return;
        }
        
        var data = this.__getObjectData(button);
        this.proxy.unlike(data);
    },
    __getObjectData: function(button) {
        var likeControl = button.closest('.js-likeControl');

        var objectId = likeControl.data('object-id');
        var objectType = likeControl.data('object-type');

        return { objectType: objectType, objectId: objectId };
    },
    __onLikeSaved: function(e, result) {
        var objectId = result.ObjectId;
        var objectType = result.ObjectType;
        var likeControl = $('.js-likeControl[data-object-id=' + objectId + '][data-object-type="' + objectType + '"]', this.element);
        
        likeControl.each($.proxy(function (idx, elem) {
            if (this.options.executedCallback) {
                this.options.executedCallback.call(this, elem, result);
            } else {
                this.__defaultExecutedCallback(elem, result);
            }
        }, this));

        $(this).trigger('likeEvent', [result]);
    },
    __defaultExecutedCallback: function (elem, result) {
        var self = $(elem);
        var buttons = $('[data-like-section="buttons"]', self),
            likeElement = $('[data-like-action="like"]', self),
            unlikeElement = $('[data-like-action="unlike"]', self);

        likeElement.addClass('comment-doLike_disabled');
        unlikeElement.addClass('comment-doDislike_disabled');
        likeElement.attr('title', 'За ' + result.LikesCount);
        unlikeElement.attr('title', 'Против ' + result.UnlikesCount);

        $('button', buttons).attr({ disabled: true });
        var counter = $('[data-like-section="sum"]', self);
        this.options.onChangeSum(counter, result.LikeSum);
    }
});

var ObjectLikeProxy = Class.extend({
    defaultOptions: {
        likeUrl: '/ajax/like/up', //todo infoman урлики захардкодил
        unlikeUrl: '/ajax/like/down'
    },
    init: function(options) {
        this.options = $.extend({}, this.defaultOptions, options);
    },
    like: function(params) {
        this.__sendAction(params, this.options.likeUrl);
    },
    unlike: function(params) {
        this.__sendAction(params, this.options.unlikeUrl);
    },
    __sendAction: function(params, url) {
        $.ajax({
            type: 'POST',
            url: url,
            data: { objectType: params.objectType, objectId: params.objectId },
            dataType: 'json',
            timeout: 10000,
            success: $.proxy(this.__likeSaved, this)
        });
    },
    __likeSaved: function(data) {
        var obj = data.Result;
        if (obj) {
            $(this).trigger('likeSavedEvent', [obj]);
        }
    }
});

var QuestionLikeControl = Class.extend({
    defaultOptions: {
        context: '#CommunityQuestion'
    },
    init: function(options) {
        var opts = $.extend({}, this.defaultOptions, options);
        this.likesControl = new LikesControl(opts);
    }
});

var CommentsLikeControl = Class.extend({
    defaultOptions: {
        context: '#comments',
        welcomeText: 'Чтобы лайкнуть комментарий, необходимо войти на сайт'
    },
    init: function(options) {
        var opts = $.extend({}, this.defaultOptions, options);
        this.likesControl = new LikesControl(opts);

        this.__bindEvents();
    },
    __bindEvents: function() {
        $(this.likesControl).on('likeEvent', $.proxy(this.__onLike, this));
    },
    __onLike: function(e, data) {
        var commentId = data.ObjectId,
            commentItem = $('#comment_' + commentId),
            opacity= 1,
            textContent = $('.js-comment-text', commentItem);

        var likeSum = data.LikeSum;
        if (likeSum < 0) {
            var x = 1 - likeSum / 5;
            opacity = x < 0.1 ? 0.1 : x;
        }
        textContent.css({ opacity: opacity });
    }
});

var CommentMarkProxy = Class.extend({
    init: function (options) {
        this.options = options;
    },
    setMark: function (params) {
        this.__sendAction(params, this.options.setMarkUrl, 'markSet');
    },
    removeMark: function (params) {
        this.__sendAction(params, this.options.removeMarkUrl, 'markRemoved');
    },
    __sendAction: function (params, url, eventName) {
        $.ajax({
            type: 'POST',
            url: url,
            data: { id: params.id },
            dataType: 'json',
            timeout: 10000,
            success: $.proxy(this.__markSetRemoveCompleted, this, eventName)
        });
    },
    __markSetRemoveCompleted: function (eventName, data) {
        if (data.Result) {
            $(this).trigger(eventName, data.Result);
        }
    }
});

var SetRemoveMarkControl = Class.extend({
    __getObjectData: function (button) {
        var setRemoveMarkControl = button.closest('.js-setRemoveMarkControl');
        var commentId = setRemoveMarkControl.data('comment-id');
        return { id: commentId };
    },
    __bindEvents: function () {
        var self = this;
        this.element.on('click', '[data-mark-action="setMark"]', $.proxy(this.__onSetting, this));
        this.element.on('click', '[data-mark-action="removeMark"]', $.proxy(this.__onRemoving, this));
        $(this.proxy).on('markSet', $.proxy(this.__onMarkSet, this));
        $(this.proxy).on('markRemoved', $.proxy(this.__onMarkRemoved, this));
    },
    __onSetting: function (e) {
        var button = $(e.currentTarget);
        var element = button.closest(this.options.context);
        element.find('.js-mark-progress').removeClass('none');
        this.proxy.setMark(this.__getObjectData(button));
    },
    __onRemoving: function (e) {
        var button = $(e.currentTarget);
        var element = button.closest(this.options.context);
        element.find('.js-mark-progress').removeClass('none');
        this.proxy.removeMark(this.__getObjectData(button));
    },
    __onMarkSet: function (e, result) {
        var id = result.CommentId,
            context = $(e.currentTarget.options.context),
            options = e.currentTarget.options;
        
        context.data('mark-state', 'notset');
        $('[data-mark-action="setMark"]', context).removeClass('none');
        context.find('[data-mark-action="removeMark"]').addClass('none');
        $(options.commentItemSelector).find(options.solvedMarkSelector).addClass('none');
        
        var element = $(options.context + '[data-comment-id="' + id + '"]');
        element.find('.js-mark-progress').addClass('none');
        element.find('[data-mark-action="setMark"]').addClass('none');
        element.find('[data-mark-action="removeMark"]').removeClass('none');
        element.data('mark-state', 'set');

        element.closest(options.commentItemSelector).find(options.solvedMarkSelector).removeClass('none');

        if (result.MarkedAnswersHtml) {
            $(options.markedAnswersSelector).replaceWith(result.MarkedAnswersHtml);
        }
    },
    __onMarkRemoved: function (e, result) {
        var id = result.CommentId,
            options = e.currentTarget.options,
            context = options.context;
        
        var element = $(context + '[data-comment-id="'+id+'"]');
        element.find('.js-mark-progress').addClass('none');
        element.find('[data-mark-action="setMark"]').removeClass('none');
        element.find('[data-mark-action="removeMark"]').addClass('none');
        element.data('mark-state', 'notset');
        
        $(options.commentItemSelector).find(options.solvedMarkSelector).addClass('none');
        
        if (result.MarkedAnswersHtml != undefined) {
            $(options.markedAnswersSelector).replaceWith(result.MarkedAnswersHtml);
        }
    },
    init: function (options) {
        this.options = $.extend({}, this.defaultOptions, options);
        this.element = $(this.options.context);
        this.commentItemSelector = options.commentItemSelector;
        this.proxy = new CommentMarkProxy(options);

        this.__bindEvents();
    }
});

var AddQuestionProxy = Class.extend({
    defaultOptions: {
        alikeQuestionsAndArticlesUrl: '/ajax/qa/alike',
        moreAlikeQuestionsUrl: '/ajax/qa/morealike'
    },
    init: function () {
        this.options = $.extend({}, this.defaultOptions);
    },
    getAlike: function (query) {
        $.ajax({
            type: 'POST',
            url: this.options.alikeQuestionsAndArticlesUrl,
            data: { query: query },
            dataType: 'json',
            timeout: 10000,
            success: $.proxy(this.__onAlikeLoading, this)
        });
    },
    getMoreAlikeQuestions: function (query, page) {
        $.ajax({
            type: 'POST',
            url: this.options.moreAlikeQuestionsUrl,
            data: { query: query, page: page },
            dataType: 'json',
            timeout: 10000,
            success: $.proxy(this.__onMoreAlikeLoaded, this)
        });
    },
    __onAlikeLoading: function (data) {
        if (data) {
            $(this).trigger('AlikeLoadedEvent', [data]);
        }
    },
    __onMoreAlikeLoaded: function (data) {
        if (data) {
            $(this).trigger('MoreAlikeLoadedEvent', [data]);
        }
    }
});

var AddQuestionView = Class.extend({
    defaultOptions: {
        addQuestionSelector: '#AddQuestionBlock'
    },
    init: function (options) {
        this.options = $.extend({}, this.defaultOptions, options);
        this.element = $(this.options.addQuestionSelector);
        this.__bindEvents();
    },
    __bindEvents: function() {
        this.element.on('keyup input propertychange paste', 'input[data-element="query"]', $.proxy(this.__onKeyPressing, this));
        this.element.on('submit', 'form', $.proxy(this.__onButtonClicking, this));
        this.element.on('click', '[data-bind="back"]', $.proxy(this.__onBackClicking, this));
    },
    __onKeyPressing: function (e) {
        var query = $(e.currentTarget).val();

        if (query.length > 0)
            this.showCancelButton();
        else {
            this.hideCancelButton();
        }
    },
    __onButtonClicking: function (e) {
        e.preventDefault();
        $(this).trigger('ButtonClickEvent');
    },
    __onBackClicking: function () {
        $(this).trigger('CancelAskEvent');
    },
    reset: function () {
        $('[data-bind="back"]', this.element).fadeIn(300);
        $('input[data-element="query"]', this.element).focus();
        return $('input[data-element="query"]', this.element).val('');
    },
    getQuery: function() {
        return $('input[data-element="query"]', this.element).val();
    },
    submit: function() {
        $('form', this.element)[0].submit();
    },
    getActionUrl: function() {
        return $('form', this.element).attr('action');
    },
    showCancelButton: function() {
        $('[data-bind="back"]', this.element).fadeIn(300);
    },
    hideCancelButton: function() {
        $('[data-bind="back"]', this.element).hide();
    },
    focus: function() {
        $('input[data-element="query"]', this.element).focus();
    }
});

var ExtendAddQuestionView = Class.extend({
    defaultOptions: {
        addQuestionSelector: '#AddQuestionBlock'
    },
    init: function(options) {
        this.options = $.extend({}, this.defaultOptions, options);
        this.element = $(this.options.addQuestionSelector);

        this.queryElement = $('input[data-element="query"]', this.element);
        this.extendQueryElement = $('textarea[data-element="extendQuery"]', this.element);

        this.__bindEvents();
    },
    __bindEvents: function () {
        this.element.on('keyup', 'input[data-element="query"]', $.proxy(this.__onKeyPressing, this));
        this.element.on('keyup', 'textarea[data-element="extendQuery"]', $.proxy(this.__onKeyPressing, this));
    },
    __onKeyPressing: function () {
        var query = this.getQuery();
        $(this).trigger('TopicQueryEvent', query);
    },
    getQuery: function () {
        var queryValue = this.queryElement.val(),
            extendQueryValue = this.extendQueryElement.val();
        if (queryValue == '' && extendQueryValue == '') return '';
        
        return queryValue + ' ' + extendQueryValue;
    },
    getActionUrl: function () { return '/'; },
    focus: function() {
        if (this.queryElement.val() == '') {
            this.queryElement.focus();
        } else {
            this.extendQueryElement.focus();
        }
    },
    showCancelButton: function () {},
    hideCancelButton: function () {}
});

var AlikeQuestionsView = Class.extend({
    defaultOptions: {
        alikeQuestionsSelector: '#AlikeQuestionBlock',
        allowNoAlike: true
    },
    init: function (options) {
        this.options = $.extend({}, this.defaultOptions, options);
        this.element = $(this.options.alikeQuestionsSelector);
        this.alikeContentElement = $('[data-bind="content"]', this.element);
        this.noQuestionsElement = $('[data-bind="noQuestions"]', this.element);
        this.__setDefaults(this.options);
        this.__bindEvents();
    },
    __setDefaults: function (options) {
        if (options.allowNoAlike === false) {
            $('[data-bind="noAlike"]', this.element).hide();
        }
    },
    __bindEvents: function() {
        this.element.on('click', '[data-bind="more"]', $.proxy(this.__onMoreClicking, this));
        this.element.on('click', '[data-bind="askOwn"]', $.proxy(this.__onAskOwnClicking, this));
    },
    __onMoreClicking: function (e) {
        var nextPage = $(e.currentTarget).data('next-page');
        $(this).trigger('MoreClickingEvent', nextPage);
    },
    __onAskOwnClicking: function() {
        $(this).trigger('ForceAskEvent');
    },
    hide: function () {
        this.element.addClass('none');
    },
    show: function() {
        this.element.removeClass('none');
    },
    setQuestionsContent: function (html) {
        var questionsElement = $('[data-bind="questions"]', this.element),
            questionListElement = $('[data-bind="questionList"]', this.element);
        
        if (html) {
            questionListElement.html(html);
            questionsElement.show();
        } else {
            questionListElement.html('');
            questionsElement.hide();
        }
    },
    addQuestionsContent: function(html) {
        $('[data-bind="questionList"]', this.element).append(html);
    },
    setArticlesContent: function(html) {
        var articlesElement = $('[data-bind="articles"]', this.element),
            articleListElement = $('[data-bind="articleList"]', this.element);
        
        if (html) {
            articleListElement.html(html);
            articlesElement.show();
        } else {
            articleListElement.html('');
            articlesElement.hide();
        }
    },
    setHasMore: function(obj) {
        var moreElement = $('[data-bind="more"]', this.element);
        if (obj.hasMore) {
            moreElement.show();
            moreElement.data('next-page', obj.nextPage);
        } else {
            moreElement.hide();
        }
    },
    showNotFound: function() {
        this.noQuestionsElement.removeClass('none');
    },
    hideNotFound: function () {
        this.noQuestionsElement.addClass('none');
    }
});

var CommunityContentView = Class.extend({
    options: {
        contentSelector: '#CommunityQuestionWrapper',
        rightColumnSelector: '.contentFrame-right'
    },
    init: function(params) {
        this.options = $.extend({}, this.options, params);
        
        this.contentElement = $(this.options.contentSelector);
        this.rightColumn = $(this.options.rightColumnSelector);
    },
    hide: function() {
        this.contentElement.hide();
        this.rightColumn.hide();
    },
    show: function() {
        this.contentElement.show();
        this.rightColumn.show();
    }
});

var BackListNavigationView = Class.extend({
    options: {
        elementSelector: '#AlikeQuestionBackListNavigation',
        backLink: {
            show: true,
            url: null,
            text: 'Вернуться к списку тем'
        }
    },
    init: function (params) {
        this.options = $.extend({}, this.options, params);
        this.element = $(this.options.elementSelector);

        this.__bindEvents();
        this.__setDefaults(this.options);
    },
    __bindEvents: function() {
        this.element.on('click', $.proxy(this.__onBackClicking, this));
    },
    __setDefaults: function (options) {
        var backPseudoLink = $('[data-bind="back"]', this.element);
        if (options.backLink.show) {
            if (options.backLink.url) {
                var link = $('<a/>', {
                    text: options.backLink.text,
                    href: options.backLink.url
                });
                backPseudoLink.replaceWith(link);
            } else {
                backPseudoLink.text(options.backText);
            }
        } else {
            this.element.remove();
        }
    },
    __onBackClicking: function () {
        $(this).trigger('CancelAskEvent');
    }
});

var AlikeItemsLoadProgressView = Class.extend({
    options: {
        progressElementSelector: '#AlikeItemsLoadProgress'
    },
    init: function(params) {
        this.options = $.extend({}, this.options, params);
        this.element = $(this.options.progressElementSelector);
    },
    show: function() {
        this.element.fadeIn(300);
    },
    hide: function() {
        this.element.hide();
    }
});

var AddQuestionControl = Class.extend({
    defaultOptions: {
        isAuthenticated: false,
        backLink: {
            show: true,
            url: null,
            text: 'Вернуться к списку тем'
        },
        delay: 200,
        addQuestionViewType: AddQuestionView
    },
    init: function (options) {
        var parameters = Kontur.UrlParameters.getParams();
        if (parameters['query']) {
            $('input[data-element="query"]').val(decodeURI(parameters['query']));
        }
        
        this.options = $.extend({}, this.defaultOptions, options);

        this.addQuestionView = new this.options.addQuestionViewType(this.options);
        this.alikeQuestionsView = new AlikeQuestionsView(this.options);
        this.backListNavigationView = new BackListNavigationView(this.options);
        this.alikeItemsLoadProgressView = new AlikeItemsLoadProgressView(this.options);
        this.communityContentView = new CommunityContentView(this.options);
        this.proxy = new AddQuestionProxy();
        this.__queryTimer = this.options.delay;
        this.__bindEvents();

        var query = this.addQuestionView.getQuery();
        if (query != '') {
            this.__onTopicQuery(this.addQuestionView, query);
        }
    },
    __bindEvents: function () {
        $(this.addQuestionView).on('TopicQueryEvent', $.proxy(this.__onTopicQuery, this));
        $(this.addQuestionView).on('ButtonClickEvent', $.proxy(this.__sendQuery, this));
        $(this.alikeQuestionsView).on('MoreClickingEvent', $.proxy(this.__onMoreClicking, this));
        $(this.backListNavigationView).on('CancelAskEvent', $.proxy(this.__onCancelAsk, this));
        $(this.addQuestionView).on('CancelAskEvent', $.proxy(this.__onCancelAsk, this));
        $(this.alikeQuestionsView).on('ForceAskEvent', $.proxy(this.__onButtonClick, this));

        $(this.proxy).on('AlikeLoadedEvent', $.proxy(this.__onAlikeLoaded, this));
        $(this.proxy).on('MoreAlikeLoadedEvent', $.proxy(this.__onMoreAlikeLoaded, this));
    },
    __onTopicQuery: function () {
        clearTimeout(this.__queryTimer);
        
        this.__queryTimer = setTimeout($.proxy(this.__sendQuery, this), this.options.delay);
    },
    __sendQuery: function () {
        var query = this.addQuestionView.getQuery();
        
        if (!query || query.length < 1) {
            this.alikeQuestionsView.hide();
            this.communityContentView.show();
            this.addQuestionView.hideCancelButton();
            return;
        }
        
        this.alikeQuestionsView.show();
        this.communityContentView.hide();
        this.addQuestionView.hideCancelButton();
        this.alikeItemsLoadProgressView.show();
        this.proxy.getAlike(query);
    },
    __onButtonClick: function () {
        this.addQuestionView.submit();
    },
    __onMoreClicking: function (e, page) {
        var query = this.addQuestionView.getQuery();
        this.proxy.getMoreAlikeQuestions(query, page + 1);
    },
    __onCancelAsk: function () {
        this.addQuestionView.reset();
        this.alikeQuestionsView.hide();
        this.communityContentView.show();
    },
    __onAlikeLoaded: function (e, data) {
        var alikeQuestions = data.AlikeQuestions,
            alikeArticles = data.AlikeArticles;
        
        this.alikeQuestionsView.setQuestionsContent(alikeQuestions.ItemsHtml);
        this.alikeQuestionsView.setHasMore({ hasMore: alikeQuestions.HasMoreItems, nextPage: alikeQuestions.Page });
        this.alikeQuestionsView.setArticlesContent(alikeArticles.ItemsHtml);
        if (!alikeQuestions.ItemsHtml && !alikeArticles.ItemsHtml) {
            this.alikeQuestionsView.showNotFound();
        } else {
            this.alikeQuestionsView.hideNotFound();
        }
        this.alikeItemsLoadProgressView.hide();
        this.addQuestionView.showCancelButton();
        this.alikeQuestionsView.show();
        this.communityContentView.hide();
    },
    __onMoreAlikeLoaded: function (e, data) {
        this.alikeQuestionsView.addQuestionsContent(data.ItemsHtml);
        this.alikeQuestionsView.setHasMore({ hasMore: data.HasMoreItems, nextPage: data.Page });
    },
    focusInput: function () {
        setTimeout($.proxy(function () {
            this.addQuestionView.focus();
        }, this), 500);
    }
});

var CommunityItemController = Class.extend({
    init: function (options) {
        var questionsOptions = $.extend({}, options, {
            onChangeSum: function (counter) {
                counter.find('.communityQuestionLike-incCount, .communityQuestionLike-currentCount').animate({ top: '+=20px' }, 'fast', function () {
                    counter.find('.communityQuestionLike-incCount').css('position', 'static');
                });
                counter.parent().addClass('liked');
            }
        });
        this.questionLikeControl = new QuestionLikeControl(questionsOptions);
        this.commentsLikeControl = new CommentsLikeControl(options);

        var setRemoveSolvedMarkControlOptions = $.extend({}, options, {
            setMarkUrl: options.setSolvedMarkUrl,
            removeMarkUrl: options.removeSolvedMarkUrl,
            context: options.addRemoveSolvedMarkControlSelector,
            solvedMarkSelector: options.addRemoveSolvedMarkSelector
        });

        var setRemoveExpertAnswerMarkControlOptions = $.extend({}, options, {
            setMarkUrl: options.setExpertAnswerMarkUrl,
            removeMarkUrl: options.removeExpertAnswerMarkUrl,
            context: options.addRemoveExpertAnswerControlSelector,
            solvedMarkSelector: options.addRemoveExpertAnswerMarkSelector
        });

        this.setRemoveSolvedMarkControl = new SetRemoveMarkControl(setRemoveSolvedMarkControlOptions);
        this.setRemoveExpertAnswerMarkControl = new SetRemoveMarkControl(setRemoveExpertAnswerMarkControlOptions);
        //this.addQuestionControl = new AddQuestionControl(options);
        this.updateStatisticControl = new UpdateStatisticControl(options);

        this.editQuestionControl = new QuestionEditControl(options.editQuestionControlOptions);
        this.clarifyQuestionControl = new ClarifyQuestionControl(options.clarifyQuestionControlOptions);
        
        this.bookmarkControl = new BookmarkControl();
    }
});

var CommunityListController = Class.extend({
    init: function (options) {
        this.addQuestionControl = new AddQuestionControl(options);
        this.bookmarkControl = new BookmarkControl();
        this.addQuestionControl.focusInput();
    }
});

var CommunityAddController = Class.extend({
    defaultOptions: {
        allowNoAlike: false,
        addQuestionViewType: ExtendAddQuestionView
    },
    init: function (options) {
        var params = $.extend({}, this.defaultOptions, options);
        this.addQuestionControl = new AddQuestionControl(params);
        this.addQuestionControl.focusInput();
    }
});

var AvatarControl = Class.extend({
    _needOpenPhotoEdit: function () {
        var queryParts = window.location.href.split('#');
        return !$.browser.msie && queryParts.length > 1 && queryParts[1] == 'photo';
    },
    _setFileName: function (options) {
        $(options.selectedFileNameContainerSelector).html($(options.fileInputSelector).val());
    },
    init: function (options) {
        this.options = options;

        var self = this;
        
            $(options.fileInputSelector).change(function () {
                self._setFileName(options);
            });
        
        if (this._needOpenPhotoEdit()) {
            $(options.fileInputSelector).click();
        }

        $(options.removeAvatarLinkSelector).click(function () {
            $(options.removeAvatarLinkSelector).addClass('none');
            $(options.avatarImageSelector).attr('src', options.defaultImgUrl);
            $(options.imgDeletedHiddenSelector).val(true);
        });
    }
});

var QuestionEditControl = Class.extend({
    _showForm: function (options) {
        $(options.questionContent.selector).addClass('none');
        $(options.form.selector).removeClass('none');

        $(options.questionBtnsBlockSelector).addClass('none');
        $(options.cancelLinkSelector).removeClass('none');

        $('#' + options.form.topicInputId).val($(options.questionContent.titleSelector).html());
        $('#' + options.form.textInputId).val($(options.questionContent.textSelector).data('original-text'));
        $('#' + options.form.textInputId).elastic().trigger('blur'); //note фикс бага - эластик глючит если тектарию вырезать из дома, а потом вставлять и снова инициализировать плагин на ней.
        $('#' + options.form.rubricSelectId + ' [value="' + $(options.questionContent.rubricLinkSelector).data('id') + '"]').attr('selected', true);

        PostSimpleFormRemoveErrors(this.form);
        this.errorPlace.removeAttr('style').addClass('none');
    },
    _showContent: function (options) {
        $(options.questionContent.selector).removeClass('none');
        $(options.form.selector).addClass('none');

        $(options.questionBtnsBlockSelector).removeClass('none');
        $(options.cancelLinkSelector).addClass('none');
    },
    init: function (options) {
        this.form = $(options.form.selector + ' form');
        this.errorPlace = $('.questionEditForm-formError', this.form);
        
        var self = this;
        
        $(document).on('click', options.editBtnSelector, function () {
            self._showForm(options);
        });

        $(document).on('click', options.cancelLinkSelector, function () {
            self._showContent(options);
        });

        InitPostSimpleFormAsync(self.form, {
            successCallback: function (data) {
                $(options.questionContent.selector).html(data.QuestionHtml);
                self._showContent(options);
            },
            beforeSendCallback: function () {
                self.form.find(options.form.submitBtnSelector).attr("disabled", true);
            },
            completeCallback: function () {
                self.form.find(options.form.submitBtnSelector).removeAttr("disabled");
            },
            errorPlacement: function(lastInput, errorElement) {
                self.errorPlace.prepend(errorElement);
                self.errorPlace.removeClass('none');
            },
            useDefaultSuccessMessageShowing: false,
            clearTextInputsOnSuccess: false
        });
    }
});

var ClarifyQuestionControl = Class.extend({
    _showForm: function (options) {
        if ($(options.clarificationList.itemSelector).size() == 0)
            $(options.clarificationList.headerSelector).html(options.clarificationList.headerText);
        
        $(options.form.selector).removeClass('none');

        $(options.questionBtnsBlockSelector).addClass('none');
        $(options.cancelBtnSelector).removeClass('none');

        PostSimpleFormRemoveErrors(this.form);

        $('#' + options.form.textInputId).focus();
    },
    _hideForm: function (options) {
        if ($(options.clarificationList.itemSelector).size() == 0)
            $(options.clarificationList.headerSelector).html('');
        
        $(options.form.selector).addClass('none');

        $(options.questionBtnsBlockSelector).removeClass('none');
        $(options.cancelBtnSelector).addClass('none');
    },
    
    init: function (options) {
        this.form = $(options.form.selector + ' form');
        
        var self = this;
        $(document).on('click', options.clarifyBtnSelector, function () {
            self._showForm(options);
        });

        $(document).on('click', options.cancelBtnSelector, function () {
            self._hideForm(options);
        });

        InitPostSimpleFormAsync(self.form, {
            successCallback: function (data) {
                $(options.clarificationList.selector).append(data.ClarificationHtml);
                $(options.clarificationList.headerSelector).html(options.clarificationList.headerText);
                self._hideForm(options);
            },
            beforeSendCallback: function () {
                self.form.find(options.form.submitBtnSelector).attr("disabled", "disabled");
            },
            completeCallback: function () {
                self.form.find(options.form.submitBtnSelector).removeAttr("disabled");
            },
            useDefaultSuccessMessageShowing: false,
            clearTextInputsOnSuccess: true
        });
    }
});
var EventItemController = Class.extend({
    init: function (params) {
        var eventsOptions = $.extend({}, params, {
            onChangeSum: function (counter) {
                counter.find('.communityQuestionLike-incCount').animate({ top: '+=20px' }, 'fast', function() {
                    counter.find('.communityQuestionLike-incCount').css('position', 'static');
                });
                counter.parent().addClass('liked');
            }
        });
        this.eventLikeControl = new EventLikeControl(eventsOptions);
        this.commentsLikeControl = new CommentsLikeControl(params);
        this.updateStatisticControl = new UpdateStatisticControl(params);
        this.likedUsersControl = new LikedUsersControl();
        this.yandexMapControl = new SimpleYandexMapControl();
        this.placeYandexMap = new PlaceYandexMap();

        this.__bindEvents();
    },
    __bindEvents: function() {
        $(this.yandexMapControl).on('MapLinkClickEvent', $.proxy(this.__onMapLinkClick, this));
    },
    __onMapLinkClick: function(e, place) {
        this.placeYandexMap.showPlaceOnMap(place);
    }
});

var EventLikeControl = Class.extend({
    defaultOptions: {
        context: '#EventItem'
    },
    init: function (options) {
        var opts = $.extend({}, this.defaultOptions, options);
        this.likesControl = new LikesControl(opts);
    }
});

var LikedUsersControl = Class.extend({
    init: function() {
        this.context = $('#LikedUsersBlock');
        this.__bindEvents();
    },
    __bindEvents: function() {
        this.context.one('click', '[data-bind="moreLink"]', $.proxy(this.__onMoreLinkClicking, this));
    },
    __onMoreLinkClicking: function(e) {
        $('[data-bind="more"]', this.context).addClass('none');
        $('[data-bind="moreUsers"]', this.context).removeClass('none');
    }
});

var SimpleYandexMapControl = Class.extend({
    options: {
        linkSelector: '[data-map-link]'
    },
    init: function(params) {
        var options = this.options = $.extend({}, this.options, params);
        this.link = $(options.linkSelector);
        this.__bindEvents();
    },
    __bindEvents: function() {
        this.link.on('click', $.proxy(this.__onLinkClicking, this));
    },
    __onLinkClicking: function(e) {
        e.preventDefault();
        
        var link = $(e.currentTarget);
        $(this).trigger('MapLinkClickEvent', [{ coordinates: link.data('map-link').split(','), address: link.data('map-address')}]);
    }
});

var PlaceYandexMap = Class.extend({
    options: {
        lightboxContainerId: 'MapLightboxContainer'
    },
    init: function(params) {
        this.options = $.extend({}, this.options, params);
        this.__initLightboxContainer();
        this.lightboxContainer = $('#' + this.options.lightboxContainerId);
    },
    __initLightboxContainer: function() {
        var foo = $('<div/>', {
            id: this.options.lightboxContainerId,
            style: 'width:600px;height:450px'
        });
        var container = $('<div class="none" />');
        container.append(foo);
        $('body').append(container);
    },
    showPlaceOnMap: function (place) {
        this.lightboxContainer.data('place', place);
        var yandexMap = this.__getYandexMap();
        if (this.__placemark) {
            yandexMap.geoObjects.remove(this.__placemark);
        }
        this.__placemark = new ymaps.Placemark(place.coordinates, {
            balloonContent: place.address
        });
        yandexMap.geoObjects.add(this.__placemark);
        this.__placemark.balloon.open();
        
        this.lightboxContainer.lightbox({
            open: function () {
                yandexMap.container.fitToViewport();
                
                yandexMap.setCenter(this.data('place').coordinates, 17, {
                    checkZoomRange: true
                });
            }
        });
    },
    __getYandexMap: function() {
        this.__yandexMap = this.__yandexMap || this.__createYandexMap();
        return this.__yandexMap;
    },
    __createYandexMap: function() {
        return new ymaps.Map(this.lightboxContainer[0], {
            center: this.lightboxContainer.data('place').coordinates,
            zoom: 14
        });
    }
});
var BookmarkView = Class.extend({
    options: {
        contextSelector: document,
        bookmarkItemClass: '.js-addRemoveBookmark',
        welcomeText: 'Для добавления в избранное необходимо войти на сайт.'
    },
    init: function (params) {
        this.options = $.extend({}, this.options, params);
        this.context = $(this.options.contextSelector);
        this.__bindEvents();
    },
    __bindEvents: function () {
        this.context.on('click', '.js-add-bookmark', $.proxy(this.__onAddLinkClicking, this));
        this.context.on('click', '.js-remove-bookmark', $.proxy(this.__onRemoveLinkClicking, this));
    },
    __onAddLinkClicking: function (e) {
        var bookmarkItem = $(e.currentTarget).closest(this.options.bookmarkItemClass),
            itemId = bookmarkItem.attr('data-id'),
            typeId = bookmarkItem.attr('data-type-id'),
            item = new BookmarkItem(itemId, typeId, bookmarkItem, this.options.bookmarkItemClass);

        $(this).trigger('AddClickedEvent', [item]);
    },
    __onRemoveLinkClicking: function (e) {
        var bookmarkItem = $(e.currentTarget).closest(this.options.bookmarkItemClass),
            itemId = bookmarkItem.attr('data-id'),
            typeId = bookmarkItem.attr('data-type-id'),
            item = new BookmarkItem(itemId, typeId, bookmarkItem, this.options.bookmarkItemClass),
            bookmarkId = bookmarkItem.attr('data-bookmark-id');

        $(this).trigger('RemoveClickedEvent', [item, bookmarkId]);
    },
    setLoadingState: function (itemId, typeId) {
        var bookmarkItem = this.__getBookmarkItemByIdAndTypeId(itemId, typeId);
        bookmarkItem.children().addClass('none');
        $('.js-bookmark-progress', bookmarkItem).removeClass('none');

    },
    setBookmarkAsAdded: function (itemId, typeId, bookmarkId) {
        var bookmarkItem = this.__getBookmarkItemByIdAndTypeId(itemId, typeId);
        bookmarkItem.children().addClass('none');
        bookmarkItem.attr('data-bookmark-id', bookmarkId);
        if (bookmarkId) {
            $('.js-remove-bookmark', bookmarkItem).removeClass('none');
        } else {
            $('.js-add-bookmark', bookmarkItem).removeClass('none');
        }
    },
    setBookmarkAsRemoved: function (itemId, typeId, success) {
        var bookmarkItem = this.__getBookmarkItemByIdAndTypeId(itemId, typeId);
        bookmarkItem.children().addClass('none');
        if (success) {
            $('.js-add-bookmark', bookmarkItem).removeClass('none');
        } else {
            $('.js-remove-bookmark', bookmarkItem).removeClass('none');
        }
    },
    __getBookmarkItemByIdAndTypeId: function (itemId, typeId) {
        return $(this.options.bookmarkItemClass + '[data-id=' + itemId + '][data-type-id=' + typeId + ']', this.context);
    }
});

var BookmarkItem = Class.extend({
    init: function (itemId, typeId, item, bookmarkItemClass) {
        this.itemId = itemId;
        this.typeId = typeId;
        this.__item = item;
        this.__bookmarkItemClass = bookmarkItemClass;
        this.__item.tooltip({
            source: '.js-addRemoveTooltip',
            position: 'bottom',
            eventShow: 'showAddRemoveTooltip',
            eventHide: 'hideAddRemoveTooltip',
            yAddition: 10,
            xAddition: 5
        });
    },
    showTooltip: function (text) {
        clearTimeout(BookmarkItem.__timers[this.itemId + ':' + this.typeId]);
        $('.js-addRemoveTooltip').text(text);
        this.__item.trigger('showAddRemoveTooltip');
        
        BookmarkItem.__timers[this.itemId + ':' + this.typeId] = setTimeout($.proxy(function () {
            this.__item.trigger('hideAddRemoveTooltip');
        }, this), 1500);
    },
    setLoadingState: function() {
        this.__item.children().addClass('none');
        $('.js-bookmark-progress', this.__item).removeClass('none');
    },
    setBookmarkAsAdded: function (bookmarkId) {
        var item = $(this.__bookmarkItemClass + '[data-id=' + this.itemId + '][data-type-id=' + this.typeId + ']');
        item.attr('data-bookmark-id', bookmarkId);
        item.children().addClass('none');
        if (bookmarkId) {
            $('.js-remove-bookmark', item).removeClass('none');
        } else {
            $('.js-add-bookmark', item).removeClass('none');
        }
        this.showTooltip('Добавлено в избранное');
    },
    setBookmarkAsRemoved: function(success) {
        var item = $(this.__bookmarkItemClass + '[data-id=' + this.itemId + '][data-type-id=' + this.typeId + ']');
        item.children().addClass('none');
        if (success) {
            $('.js-add-bookmark', item).removeClass('none');
        } else {
            $('.js-remove-bookmark', item).removeClass('none');
        }
        this.showTooltip('Удалено из избранного');
    }
});
BookmarkItem.__timers = {};

var ProfileBookmarkView = BookmarkView.extend({
    setBookmarkAsRemoved: function (itemId, typeId, success) {
        if (success) {
            var bookmarkItem = this.__getBookmarkItemByIdAndTypeId(itemId, typeId);
            bookmarkItem.closest('.js-favoriteItem').remove();
        }
    }
});

var BookmarkProxy = Class.extend({
    options: {
        timeout: 10000
    },
    addBookmark: function (item) {
        $.ajax({
            type: 'POST',
            url: '/ajax/bookmarks/add',
            data: { "Form.ItemId": item.itemId, "Form.TypeId": item.typeId },
            dataType: 'json',
            contentType: 'application/x-www-form-urlencoded; charset=utf-8',
            timeout: this.options.timeout,
            error: $.proxy(function () {
                $(this).trigger('BookmarkAddedEvent', [item, null]);
            }, this),
            success: $.proxy(function (data) {
                $(this).trigger('BookmarkAddedEvent', [item, data.BookmarkId]);
            }, this)
        });
    },
    removeBookmark: function (item, bookmarkId) {
        $.ajax({
            type: 'POST',
            url: '/ajax/bookmarks/delete',
            data: { id: bookmarkId },
            dataType: 'json',
            contentType: 'application/x-www-form-urlencoded; charset=utf-8',
            timeout: this.options.timeout,
            error: $.proxy(function () {
                $(this).trigger('BookmarkRemovedEvent', [item, false]);
            }, this),
            success: $.proxy(function (data) {
                var success = $.isEmptyObject(data.Errors);
                $(this).trigger('BookmarkRemovedEvent', [item, success]);
            }, this)
        });
    }
});

var BookmarkControl = Class.extend({
    options: {
        viewType: BookmarkView
    },
    init: function (params) {
        this.options = $.extend({}, this.options, params);
        this.view = new this.options.viewType(params);
        this.proxy = new BookmarkProxy();

        this.__bindEvents();
    },
    __bindEvents: function () {
        $(this.view).on('AddClickedEvent', $.proxy(this.__onAddClicked, this));
        $(this.view).on('RemoveClickedEvent', $.proxy(this.__onRemoveClicked, this));
        $(this.proxy).on('BookmarkAddedEvent', $.proxy(this.__onBookmarkAdded, this));
        $(this.proxy).on('BookmarkRemovedEvent', $.proxy(this.__onBookmarkRemoved, this));
    },
    __onAddClicked: function (e, item) {
        item.setLoadingState();
        this.proxy.addBookmark(item);
        
/*        this.context.on('showtooltip', '.js-add-bookmark', function() {
            $(this).tooltip({
                source: ''
            })
        });
        this.context.trigger('showtooltip');*/
        //this.context.on('click', '.js-add-bookmark', $.proxy(this.__onAddLinkClicking, this));
    },
    __onRemoveClicked: function (e, item, bookmarkId) {
        item.setLoadingState();
        this.proxy.removeBookmark(item, bookmarkId);
    },
    __onBookmarkAdded: function (e, item, bookmarkId) {
        item.setBookmarkAsAdded(bookmarkId);
    },
    __onBookmarkRemoved: function (e, item, success) {
        item.setBookmarkAsRemoved(success);
    }
});
var HideShowEduFormController = Class.extend({
    _showForm: function (options) {
        if (!this._validateAuthentication()) return;

        $('#' + options.form.id).removeClass(options.form.openFormCssClass);
    },

    _hideForm: function (options) {
        $('#' + options.form.id).addClass(options.form.openFormCssClass);
    },

    _validateAuthentication: function () {
        return Kontur.User.isAuthenticated(); 
    },
    init: function (options) {
        this.options = options;

        var self = this,
            $done = $('.done');
        
        if (!options.form.isValid) {
            window.location.hash = options.form.id;
        }

        $(document).on('click', options.form.openLinkSelector, function () {
            $('#' + options.form.id).toggleClass(options.form.openFormCssClass);
        });

        $(document).on('click', options.form.cancelLinkSelector, function () {
            self._hideForm(options);
            return false;
        });

        if ($done.length > 0) {
            $('html, body').animate({
                scrollTop: $done.offset().top
            }, 0);

            this._hideForm(options);
        } else {
            if (window.location.hash == "#" + options.form.id && options.form.isValid && this._validateAuthentication()) {
                $('#' + options.form.id).trigger('click');
            } else {
                if (options.form.isValid) {
                    this._hideForm(options);
                }
            }
        }
    }
});

var TraineeshipOrderForm = Class.extend({
    init: function (options) {
        var initMovementAbilityToggle = function (mainCity) {
            var movementAbilityField = $('[data-bind="movementAbility"]');

            return function(value) {
                if (value == mainCity) {
                    movementAbilityField.addClass('hide');
                } else {
                    movementAbilityField.removeClass('hide');
                }
            };
        }

        var bindEvents = function () {
            var cityField = $('[data-bind="city"]'),
                cityInput = cityField.find('input'),
                sourceUrl = cityField.data('source-url'),
                mainCity = cityField.data('main-city');

            var movementAbilityToggle = initMovementAbilityToggle(mainCity);

            cityInput.on('keyup', function() {
                movementAbilityToggle(this.value);
            });

            cityInput.autocomplete({
                source: function (request, response) {
                    $.ajax({
                        url: sourceUrl + '/' + request.term,
                        success: function (data) {
                            response($.map(data, function (item) {
                                return {
                                    label: item.value
                                };
                            }));
                        }
                    });
                },
                minLength: 2,
                autoFocus: true,
                select: function (event, ui) {
                    movementAbilityToggle(ui.item.label);
                }
            });
        }

        this.options = options;

        this.hideShowEduFormController = new HideShowEduFormController(options);

        if (options.form.howKnowMeansOtherOptionId) {
            function changeHowKnow() {
                var textBox = $('#' + options.form.howKnowOtherTextBoxId);
                if ($('#' + options.form.howKnowMeansOtherOptionId).prop('checked')) {
                    textBox.removeClass('hide');
                } else {
                    textBox.addClass('hide');
                }
            }

            $(document).on('change', '#' + options.form.howKnowMeansOtherOptionId, function () {
                changeHowKnow();
            });
            changeHowKnow();
        }

        $('#formTooltip').tooltip({
            source: '#formTooltipContent',
            position: 'bottom',
            eventShow: 'hover',
            yAddition: 10,
            xAddition: 7,
            maxWidth: 277
        });

        if (options.form.isValid) {
            $('#' + options.form.id).addClass(options.form.openFormCssClass);
        } else {
            $('#' + options.form.id).removeClass(options.form.openFormCssClass);
        }

        bindEvents();
    }
});

var TraineeshipTestTaskForm = Class.extend({
    init: function (options) {
        this.options = options;

        this.hideShowEduFormController = new HideShowEduFormController(options);
    }
});

$(function() {
    var $done = $('.done');

    if ($done.length > 0) {
        $('html, body').animate({
            scrollTop: $done.offset().top
        }, 0);
    }
});

(function ($, Kontur) {
    'use strict';

    Kontur.Module('Kontur.Education', function () { });

    Kontur.Education.GuruIndex = (function () {
        return {
            init: function () {
                Kontur.Career.Tabs.initialize();
            }
        };
    })();
}(jQuery, Kontur));
/* Modernizr 2.5.3 (Custom Build) | MIT & BSD
 * Build: http://www.modernizr.com/download/#-csstransitions-testprop-testallprops-domprefixes
 */
;window.Modernizr=function(a,b,c){function w(a){i.cssText=a}function x(a,b){return w(prefixes.join(a+";")+(b||""))}function y(a,b){return typeof a===b}function z(a,b){return!!~(""+a).indexOf(b)}function A(a,b){for(var d in a)if(i[a[d]]!==c)return b=="pfx"?a[d]:!0;return!1}function B(a,b,d){for(var e in a){var f=b[a[e]];if(f!==c)return d===!1?a[e]:y(f,"function")?f.bind(d||b):f}return!1}function C(a,b,c){var d=a.charAt(0).toUpperCase()+a.substr(1),e=(a+" "+m.join(d+" ")+d).split(" ");return y(b,"string")||y(b,"undefined")?A(e,b):(e=(a+" "+n.join(d+" ")+d).split(" "),B(e,b,c))}var d="2.5.3",e={},f=b.documentElement,g="modernizr",h=b.createElement(g),i=h.style,j,k={}.toString,l="Webkit Moz O ms",m=l.split(" "),n=l.toLowerCase().split(" "),o={},p={},q={},r=[],s=r.slice,t,u={}.hasOwnProperty,v;!y(u,"undefined")&&!y(u.call,"undefined")?v=function(a,b){return u.call(a,b)}:v=function(a,b){return b in a&&y(a.constructor.prototype[b],"undefined")},Function.prototype.bind||(Function.prototype.bind=function(b){var c=this;if(typeof c!="function")throw new TypeError;var d=s.call(arguments,1),e=function(){if(this instanceof e){var a=function(){};a.prototype=c.prototype;var f=new a,g=c.apply(f,d.concat(s.call(arguments)));return Object(g)===g?g:f}return c.apply(b,d.concat(s.call(arguments)))};return e}),o.csstransitions=function(){return C("transition")};for(var D in o)v(o,D)&&(t=D.toLowerCase(),e[t]=o[D](),r.push((e[t]?"":"no-")+t));return w(""),h=j=null,e._version=d,e._domPrefixes=n,e._cssomPrefixes=m,e.testProp=function(a){return A([a])},e.testAllProps=C,e}(this,this.document);
;
;
// jquery-blockUI.js
; (function ($) {
    if (/1\.(0|1|2)\.(0|1|2)/.test($.fn.jquery) || /^1.1/.test($.fn.jquery)) {
        alert('blockUI requires jQuery v1.2.3 or later! You are using v' + $.fn.jquery);
        return;
    }
    // global $ methods for blocking/unblocking the entire page
    $.blockUI = function (opts) {
        install(window, opts);
        tmpKeyDownFunc = document.body.onkeydown;
        if (document.all)
            document.body.onkeydown = function () { if (event.keyCode == 27) { remove(window, opts); document.body.onkeydown = tmpKeyDownFunc; } }
        else
            document.body.onkeydown = function (event) { if (event.keyCode == 27) { remove(window, opts); document.body.onkeydown = tmpKeyDownFunc; } }
    };
    $.unblockUI = function (opts) { remove(window, opts); document.body.onkeydown = tmpKeyDownFunc; };
    // plugin method for blocking element content
    $.fn.block = function (opts) {
        return this.each(function () {
            if ($.css(this, 'position') == 'static')
                this.style.position = 'relative';
            if ($.browser.msie)
                this.style.zoom = 1; // force 'hasLayout'
            install(this, opts);
        });
    };
    // plugin method for unblocking element content
    $.fn.unblock = function (opts) {
        return this.each(function () {
            remove(this, opts);
        });
    };
    $.blockUI.version = 2.11; // 2nd generation blocking at no extra cost!
    // override these in your code to change the default behavior and style
    $.blockUI.defaults = {
        // message displayed when blocking (use null for no message)
        message: '<h1>Please wait...</h1>',
        // styles for the message when blocking; if you wish to disable
        // these and use an external stylesheet then do this in your code:
        // $.blockUI.defaults.css = {};
        css: {
            padding: 0,
            margin: 0,
            width: '30%',
            top: '40%',
            left: '35%',
            textAlign: 'center',
            color: '#000',
            border: '3px solid #aaa',
            backgroundColor: '#fff',
            cursor: 'wait'
        },
        // styles for the overlay
        overlayCSS: {
            backgroundColor: '#000',
            opacity: '0.6'
        },
        // z-index for the blocking overlay
        baseZ: 1000,
        // set these to true to have the message automatically centered
        centerX: true, // <-- only effects element blocking (page block controlled via css above)
        centerY: true,
        // allow body element to be stetched in ie6; this makes blocking look better
        // on "short" pages. disable if you wish to prevent changes to the body height
        allowBodyStretch: true,
        // be default blockUI will supress tab navigation from leaving blocking content;
        constrainTabKey: true,
        // fadeOut time in millis; set to 0 to disable fadeout on unblock
        fadeOut: 400,
        // if true, focus will be placed in the first available input field when
        // page blocking
        focusInput: true,
        // suppresses the use of overlay styles on FF/Linux (due to performance issues with opacity)
        applyPlatformOpacityRules: true,
        // callback method invoked when unblocking has completed; the callback is
        // passed the element that has been unblocked (which is the window object for page
        // blocks) and the options that were passed to the unblock call:
        // onUnblock(element, options)
        onUnblock: null,
        // don't ask (if you really must know: http://groups.google.com/group/jquery-en/browse_thread/thread/36640a8730503595/2f6a79a77a78e493#2f6a79a77a78e493)
        quirksmodeOffsetHack: 4
    };
    // private data and functions follow...
    var ie6 = $.browser.msie && /MSIE 6.0/.test(navigator.userAgent);
    var pageBlock = null;
    var pageBlockEls = [];
    function install(el, opts) {
        var full = (el == window);
        var msg = opts && opts.message !== undefined ? opts.message : undefined;
        opts = $.extend({}, $.blockUI.defaults, opts || {});
        opts.overlayCSS = $.extend({}, $.blockUI.defaults.overlayCSS, opts.overlayCSS || {});
        var css = $.extend({}, $.blockUI.defaults.css, opts.css || {});
        msg = msg === undefined ? opts.message : msg;
        // remove the current block (if there is one)
        if (full && pageBlock)
            remove(window, { fadeOut: 0 });
        // if an existing element is being used as the blocking content then we capture
        // its current place in the DOM (and current display style) so we can restore
        // it when we unblock
        if (msg && typeof msg != 'string' && (msg.parentNode || msg.jquery)) {
            var node = msg.jquery ? msg[0] : msg;
            var data = {};
            $(el).data('blockUI.history', data);
            data.el = node;
            data.parent = node.parentNode;
            data.display = node.style.display;
            data.position = node.style.position;
            data.parent.removeChild(node);
        }
        var z = opts.baseZ;
        // blockUI uses 3 layers for blocking, for simplicity they are all used on every platform;
        // layer1 is the iframe layer which is used to supress bleed through of underlying content
        // layer2 is the overlay layer which has opacity and a wait cursor
        // layer3 is the message content that is displayed while blocking
        var lyr1 = ($.browser.msie) ? $('<iframe class="blockUI" style="z-index:' + z++ + ';border:none;margin:0;padding:0;position:absolute;width:100%;height:100%;top:0;left:0" src="javascript:false;"></iframe>')
: $('<div class="blockUI" style="display:none"></div>');
        var lyr2 = $('<div class="blockUI blockOverlay" style="z-index:' + z++ + ';cursor:default;border:none;margin:0;padding:0;width:100%;height:100%;top:0;left:0"></div>');
        var lyr3 = full ? $('<div class="blockUI blockMsg blockPage" style="z-index:' + z + ';position:fixed"></div>')
: $('<div class="blockUI blockMsg blockElement" style="z-index:' + z + ';display:none;position:absolute"></div>');
        // if we have a message, style it
        if (msg)
            lyr3.css(css);
        // style the overlay
        if (!opts.applyPlatformOpacityRules || !($.browser.mozilla && /Linux/.test(navigator.platform)))
            lyr2.css(opts.overlayCSS);
        lyr2.css('position', full ? 'fixed' : 'absolute');
        // make iframe layer transparent in IE
        if ($.browser.msie)
            lyr1.css('opacity', '0.0');
        $([lyr1[0], lyr2[0], lyr3[0]]).appendTo(full ? 'body' : el);
        // ie7 must use absolute positioning in quirks mode and to account for activex issues (when scrolling)
        var expr = $.browser.msie && (!$.boxModel || $('object,embed', full ? null : el).length > 0);
        if (ie6 || expr) {
            // give body 100% height
            if (full && opts.allowBodyStretch && $.boxModel)
                $('html,body').css('height', '100%');
            // fix ie6 issue when blocked element has a border width
            if ((ie6 || !$.boxModel) && !full) {
                var t = sz(el, 'borderTopWidth'), l = sz(el, 'borderLeftWidth');
                var fixT = t ? '(0 - ' + t + ')' : 0;
                var fixL = l ? '(0 - ' + l + ')' : 0;
            }
            // simulate fixed position
            $.each([lyr1, lyr2, lyr3], function (i, o) {
                var s = o[0].style;
                s.position = 'absolute';
                if (i < 2) {
                    full ? $(o[0]).height(function () {
                        return eval('Math.max(document.body.scrollHeight, document.body.offsetHeight) - (jQuery.boxModel?0:' + opts.quirksmodeOffsetHack + ') + "px"');
                    })
: $(o[0]).height(function () {
    return eval('this.parentNode.offsetHeight + "px"');
})
                    full ? $(o[0]).width(function () {
                        return eval('jQuery.boxModel && document.documentElement.clientWidth || document.body.clientWidth + "px"');
                    })
: $(o[0]).width(function () {
    return eval('width', 'this.parentNode.offsetWidth + "px"');
});
                    if (fixL) s.setExpression('left', fixL);
                    if (fixT) s.setExpression('top', fixT);
                }
                else if (opts.centerY) {
                    if (full) s.setExpression('top', '(document.documentElement.clientHeight || document.body.clientHeight) / 2 - (this.offsetHeight / 2) + (blah = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + "px"');
                    s.marginTop = 0;
                }
                if (i == 2) {
                    if (s.top.match('%')) var t = (document.documentElement.clientHeight || document.body.clientHeight) * parseFloat(s.top.replace('%', '')) / 100;
                    else var t = parseFloat(s.top.replace('px', ''));
                    $(o[0]).css('top', function () {
                        return eval(t + ' + (blah = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + "px"');
                    });
                }
            });
        }
        // show the message
        lyr3.append(msg).show();
        if (msg && (msg.jquery || msg.nodeType))
            $(msg).show();
        // bind key and mouse events
        bind(1, el, opts);
        if (full) {
            pageBlock = lyr3[0];
            pageBlockEls = $(':input:enabled:visible', pageBlock);
            if (opts.focusInput)
                setTimeout(focus, 20);
        }
        else
            center(lyr3[0], opts.centerX, opts.centerY);
        if (full) lyr2.click(function () { remove(window, opts); });
    };
    // remove the block
    function remove(el, opts) {
        var full = el == window;
        var data = $(el).data('blockUI.history');
        opts = $.extend({}, $.blockUI.defaults, opts || {});
        bind(0, el, opts); // unbind events
        var els = full ? $('body').children().filter('.blockUI') : $('.blockUI', el);
        if (full)
            pageBlock = pageBlockEls = null;
        if (opts.fadeOut) {
            els.fadeOut(opts.fadeOut);
            setTimeout(function () { reset(els, data, opts, el); }, opts.fadeOut);
        }
        else
            reset(els, data, opts, el);
    };
    // move blocking element back into the DOM where it started
    function reset(els, data, opts, el) {
        els.each(function (i, o) {
            // remove via DOM calls so we don't lose event handlers
            if (this.parentNode)
                this.parentNode.removeChild(this);
        });
        if (data && data.el) {
            data.el.style.display = data.display;
            data.el.style.position = data.position;
            data.parent.appendChild(data.el);
            $(data.el).removeData('blockUI.history');
        }
        if (typeof opts.onUnblock == 'function')
            opts.onUnblock(el, opts);
    };
    // bind/unbind the handler
    function bind(b, el, opts) {
        var full = el == window, $el = $(el);
        // don't bother unbinding if there is nothing to unbind
        if (!b && (full && !pageBlock || !full && !$el.data('blockUI.isBlocked')))
            return;
        if (!full)
            $el.data('blockUI.isBlocked', b);
        // bind anchors and inputs for mouse and key events
        var events = 'mousedown mouseup keydown keypress';
        b ? $(document).bind(events, opts, handler) : $(document).unbind(events, handler);
        // former impl...
        // var $e = $('a,:input');
        // b ? $e.bind(events, opts, handler) : $e.unbind(events, handler);
    };
    // event handler to suppress keyboard/mouse events when blocking
    function handler(e) {
        // allow tab navigation (conditionally)
        if (e.keyCode && e.keyCode == 9) {
            if (pageBlock && e.data.constrainTabKey) {
                var els = pageBlockEls;
                var fwd = !e.shiftKey && e.target == els[els.length - 1];
                var back = e.shiftKey && e.target == els[0];
                if (fwd || back) {
                    setTimeout(function () { focus(back) }, 10);
                    return false;
                }
            }
        }
        // allow events within the message content
        if ($(e.target).parents('div.blockMsg').length > 0)
            return true;
        // allow events for content that is not being blocked
        return $(e.target).parents().children().filter('div.blockUI').length == 0;
    };
    function focus(back) {
        if (!pageBlockEls)
            return;
        var e = pageBlockEls[back === true ? pageBlockEls.length - 1 : 0];
        if (e)
            e.focus();
    };
    function center(el, x, y) {
        var p = el.parentNode, s = el.style;
        var l = ((p.offsetWidth - el.offsetWidth) / 2) - sz(p, 'borderLeftWidth');
        var t = ((p.offsetHeight - el.offsetHeight) / 2) - sz(p, 'borderTopWidth');
        if (x) s.left = l > 0 ? (l + 'px') : '0';
        if (y) s.top = t > 0 ? (t + 'px') : '0';
    };
    function sz(el, p) {
        return parseInt($.css(el, p)) || 0;
    };
})(jQuery); ;
var VideoRegisterer = function () {
    var self = this;
    this.events = {
        '-1': 'unstarted',
        '0': 'ended',
        '1': 'playing',
        '2': 'paused'
    };

    this.registerEvent = function (data) {
        if (!this.events[data.event]) {
            return;
        }

        var _gaq = window._gaq = window._gaq || [];
        _gaq.push(['_trackEvent', 'Videos', this.events[data.event], data.videoId, data.time]);
    };

    $(window).on('playerStateChangeEvent', function (e, data) {
        self.registerEvent(data);
    });
};

$(function () {
    var registerer = new VideoRegisterer();
});


$.blockUI.defaults.css = {};
$.blockUI.defaults.centerY = false;
$.blockUI.defaults.centerX = true;
$.blockUI.defaults.overlayCSS = { backgroundColor: '#000', opacity: '0.4' };

Kontur.SelectRegionDropdown = (function ($) {
    'use strict';
    var SelectRegionDropdown = function (options) {
        var dropdown = $(options.linkSelector),
            loader = $('<div class="preloader" style="display:block;height:50px"></div>'),
            loadRegions = function (url) {
                var deferred = $.Deferred();
                if (SelectRegionDropdown.locationRegions.length > 0) {
                    deferred.resolve(SelectRegionDropdown.locationRegions);
                } else {
                    showAjaxLoader();
                    $.ajax({
                            type: 'POST',
                            url: url,
                            success: function (data) {
                                SelectRegionDropdown.locationRegions = data;
                                deferred.resolve(data);
                            }
                        })
                        .done(function () {
                            hideAjaxLoader();
                        });
                }

                return deferred.promise();
            },
            showAjaxLoader = function () {
                $('[role="menu"]', dropdown)
                    .before(loader);
            },
            hideAjaxLoader = function () {
                loader.hide();
            },
            buildRegionSelect = function (locationRegions) {
                var selectOptions = $('[role="menu"] > li', dropdown);
                if (selectOptions.length > 0) {
                    return;
                }
                $('[role="menu"]', options.linkSelector).html($.map(locationRegions, function (item) {
                    return '<li role="presentation"><a data-value="' + item.id + '" href="#">' + item.value + '</a></li>';
                }));
                dropdown.trigger('regionsrendered');
            },
            changeRegion = function (regionId) {
                $('<form />', {
                    action: options.setRegionUrl,
                    method: 'POST'
                })
                .addClass('hide')
                .append('<input type="text" name="returnUrl" value="' + $(options.linkSelector).attr('data-returnUrl') + '" />')
                .append('<input type="text" name="locationRegionId" value="' + regionId + '" />')
                .appendTo('body')
                .submit();

                dropdown.unbind('click');
            };

        dropdown.on('show.bs.dropdown', function () {
            loadRegions(options.url)
                .then(function(data) {
                    buildRegionSelect(data);
                });
        });

        dropdown.on('click', '[data-value]', function (e) {
            e.preventDefault();
            var regionId = $(e.currentTarget).attr('data-value');
            changeRegion(regionId);
        });
    };

    SelectRegionDropdown.locationRegions = [];

    return SelectRegionDropdown;
}(jQuery));

/**
* SWFObject v1.5: Flash Player detection and embed - http://blog.deconcept.com/swfobject/
*
* SWFObject is (c) 2007 Geoff Stearns and is released under the MIT License:
* http://www.opensource.org/licenses/mit-license.php
*
*/
if (typeof deconcept == "undefined") {
    var deconcept = new Object();
}
if (typeof deconcept.util == "undefined") {
    deconcept.util = new Object();
}
if (typeof deconcept.SWFObjectUtil == "undefined") {
    deconcept.SWFObjectUtil = new Object();
}
deconcept.SWFObject = function (_1, id, w, h, _5, c, _7, _8, _9, _a) {
    if (!document.getElementById) {
        return;
    }
    this.DETECT_KEY = _a ? _a : "detectflash";
    this.skipDetect = deconcept.util.getRequestParameter(this.DETECT_KEY);
    this.params = new Object();
    this.variables = new Object();
    this.attributes = new Array();
    if (_1) {
        this.setAttribute("swf", _1);
    }
    if (id) {
        this.setAttribute("id", id);
    }
    if (w) {
        this.setAttribute("width", w);
    }
    if (h) {
        this.setAttribute("height", h);
    }
    if (_5) {
        this.setAttribute("version", new deconcept.PlayerVersion(_5.toString().split(".")));
    }
    this.installedVer = deconcept.SWFObjectUtil.getPlayerVersion();
    if (!window.opera && document.all && this.installedVer.major > 7) {
        deconcept.SWFObject.doPrepUnload = true;
    }
    if (c) {
        this.addParam("bgcolor", c);
    }
    var q = _7 ? _7 : "high";
    this.addParam("quality", q);
    this.setAttribute("useExpressInstall", false);
    this.setAttribute("doExpressInstall", false);
    var _c = (_8) ? _8 : window.location;
    this.setAttribute("xiRedirectUrl", _c);
    this.setAttribute("redirectUrl", "");
    if (_9) {
        this.setAttribute("redirectUrl", _9);
    }
};
deconcept.SWFObject.prototype = {
    useExpressInstall: function (_d) {
        this.xiSWFPath = !_d ? "expressinstall.swf" : _d;
        this.setAttribute("useExpressInstall", true);
    },
    setAttribute: function (_e, _f) { this.attributes[_e] = _f; },
    getAttribute: function (_10) { return this.attributes[_10]; },
    addParam: function (_11, _12) { this.params[_11] = _12; },
    getParams: function () { return this.params; },
    addVariable: function (_13, _14) { this.variables[_13] = _14; },
    getVariable: function (_15) { return this.variables[_15]; },
    getVariables: function () { return this.variables; },
    getVariablePairs: function () {
        var _16 = new Array();
        var key;
        var _18 = this.getVariables();
        for (key in _18) {
            _16[_16.length] = key + "=" + _18[key];
        }
        return _16;
    },
    getSWFHTML: function () {
        var _19 = "";
        if (navigator.plugins && navigator.mimeTypes && navigator.mimeTypes.length) {
            if (this.getAttribute("doExpressInstall")) {
                this.addVariable("MMplayerType", "PlugIn");
                this.setAttribute("swf", this.xiSWFPath);
            }
            _19 = "<embed type=\"application/x-shockwave-flash\" src=\"" + this.getAttribute("swf") + "\" width=\"" + this.getAttribute("width") + "\" height=\"" + this.getAttribute("height") + "\" style=\"" + this.getAttribute("style") + "\"";
            _19 += " id=\"" + this.getAttribute("id") + "\" name=\"" + this.getAttribute("id") + "\" ";
            var _1a = this.getParams();
            for (var key in _1a) {
                _19 += [key] + "=\"" + _1a[key] + "\" ";
            }
            var _1c = this.getVariablePairs().join("&");
            if (_1c.length > 0) {
                _19 += "flashvars=\"" + _1c + "\"";
            }
            _19 += "/>";
        } else {
            if (this.getAttribute("doExpressInstall")) {
                this.addVariable("MMplayerType", "ActiveX");
                this.setAttribute("swf", this.xiSWFPath);
            }
            _19 = "<object id=\"" + this.getAttribute("id") + "\" classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\" width=\"" + this.getAttribute("width") + "\" height=\"" + this.getAttribute("height") + "\" style=\"" + this.getAttribute("style") + "\">";
            _19 += "<param name=\"movie\" value=\"" + this.getAttribute("swf") + "\" />";
            var _1d = this.getParams();
            for (var key in _1d) {
                _19 += "<param name=\"" + key + "\" value=\"" + _1d[key] + "\" />";
            }
            var _1f = this.getVariablePairs().join("&");
            if (_1f.length > 0) {
                _19 += "<param name=\"flashvars\" value=\"" + _1f + "\" />";
            }
            _19 += "</object>";
        }
        return _19;
    },
    write: function (_20) {
        if (this.getAttribute("useExpressInstall")) {
            var _21 = new deconcept.PlayerVersion([6, 0, 65]);
            if (this.installedVer.versionIsValid(_21) && !this.installedVer.versionIsValid(this.getAttribute("version"))) {
                this.setAttribute("doExpressInstall", true);
                this.addVariable("MMredirectURL", escape(this.getAttribute("xiRedirectUrl")));
                document.title = document.title.slice(0, 47) + " - Flash Player Installation";
                this.addVariable("MMdoctitle", document.title);
            }
        }
        if (this.skipDetect || this.getAttribute("doExpressInstall") || this.installedVer.versionIsValid(this.getAttribute("version"))) {
            var n = (typeof _20 == "string") ? document.getElementById(_20) : _20;
            n.innerHTML = this.getSWFHTML();
            return true;
        } else {
            if (this.getAttribute("redirectUrl") != "") {
                document.location.replace(this.getAttribute("redirectUrl"));
            }
        }
        return false;
    }
};
deconcept.SWFObjectUtil.getPlayerVersion = function () {
    var _23 = new deconcept.PlayerVersion([0, 0, 0]);
    if (navigator.plugins && navigator.mimeTypes.length) {
        var x = navigator.plugins["Shockwave Flash"];
        if (x && x.description) {
            _23 = new deconcept.PlayerVersion(x.description.replace(/([a-zA-Z]|\s)+/, "").replace(/(\s+r|\s+b[0-9]+)/, ".").split("."));
        }
    } else {
        if (navigator.userAgent && navigator.userAgent.indexOf("Windows CE") >= 0) {
            var axo = 1;
            var _26 = 3;
            while (axo) {
                try {
                    _26++;
                    axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash." + _26);
                    _23 = new deconcept.PlayerVersion([_26, 0, 0]);
                } catch (e) {
                    axo = null;
                }
            }
        } else {
            try {
                var axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.7");
            } catch (e) {
                try {
                    var axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.6");
                    _23 = new deconcept.PlayerVersion([6, 0, 21]);
                    axo.AllowScriptAccess = "always";
                } catch (e) {
                    if (_23.major == 6) {
                        return _23;
                    }
                }
                try {
                    axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
                } catch (e) {
                }
            }
            if (axo != null) {
                _23 = new deconcept.PlayerVersion(axo.GetVariable("$version").split(" ")[1].split(","));
            }
        }
    }
    return _23;
};
deconcept.PlayerVersion = function (_29) {
    this.major = _29[0] != null ? parseInt(_29[0]) : 0;
    this.minor = _29[1] != null ? parseInt(_29[1]) : 0;
    this.rev = _29[2] != null ? parseInt(_29[2]) : 0;
};
deconcept.PlayerVersion.prototype.versionIsValid = function (fv) {
    if (this.major < fv.major) {
        return false;
    }
    if (this.major > fv.major) {
        return true;
    }
    if (this.minor < fv.minor) {
        return false;
    }
    if (this.minor > fv.minor) {
        return true;
    }
    if (this.rev < fv.rev) {
        return false;
    }
    return true;
};
deconcept.util = {
    getRequestParameter: function (_2b) {
        var q = document.location.search || document.location.hash;
        if (_2b == null) {
            return q;
        }
        if (q) {
            var _2d = q.substring(1).split("&");
            for (var i = 0; i < _2d.length; i++) {
                if (_2d[i].substring(0, _2d[i].indexOf("=")) == _2b) {
                    return _2d[i].substring((_2d[i].indexOf("=") + 1));
                }
            }
        }
        return "";
    }
};
deconcept.SWFObjectUtil.cleanupSWFs = function () {
    var _2f = document.getElementsByTagName("OBJECT");
    for (var i = _2f.length - 1; i >= 0; i--) {
        _2f[i].style.display = "none";
        for (var x in _2f[i]) {
            if (typeof _2f[i][x] == "function") {
                _2f[i][x] = function () {};
            }
        }
    }
};
if (deconcept.SWFObject.doPrepUnload) {
    if (!deconcept.unloadSet) {
        deconcept.SWFObjectUtil.prepUnload = function () {
            __flash_unloadHandler = function () {};
            __flash_savedUnloadHandler = function () {};
            window.attachEvent("onunload", deconcept.SWFObjectUtil.cleanupSWFs);
        };
        window.attachEvent("onbeforeunload", deconcept.SWFObjectUtil.prepUnload);
        deconcept.unloadSet = true;
    }
}
if (!document.getElementById && document.all) {
    document.getElementById = function (id) { return document.all[id]; };
}
var getQueryParamValue = deconcept.util.getRequestParameter;
var FlashObject = deconcept.SWFObject;
var SWFObject = deconcept.SWFObject;

var ExecuteWithDelay = (function () {
    var timer;
    return function (callback, ms) {
        if (timer != null) {
            clearTimeout(timer);
        }
        timer = setTimeout(callback, ms);
    };
})();


lightBox = {
    div: null,
    sx: 0,
    sy: 0,
    show: function (MessageBlock, opts) {
        if (!opts) opts = {};
        opts.centerX = opts.centerX == undefined ? true : opts.centerX;
        opts.centerY = opts.centerY == undefined ? true : opts.centerY;
        div = document.createElement('div');
        div.className = "LightBox";
        if (!(div.msg = document.getElementById(MessageBlock))) return;
        document.body.appendChild(div);
        sx = document.documentElement.scrollLeft;
        sy = document.documentElement.scrollTop;
        /*document.documentElement.style.width = document.documentElement.clientWidth + "px"; ///////////
        document.documentElement.style.overflow = "hidden";
        document.documentElement.style.position = "relative";
        document.documentElement.style.left = (-sx) + "px";
        document.documentElement.style.top = (-sy) + "px";*/

        div.style.cssText = "width:100%;_width:expression(documentElement.clientWidth);\
            height:100%;_height:expression(documentElement.clientHeight);position:fixed;_position:absolute;\
            left:0;_left:expression(documentElement.scrollLeft-document.body.offsetLeft);\
            top:0;_top:expression(documentElement.scrollTop-document.body.offsetTop);";
        div.appendChild(div.bg = document.createElement('div'));
        div.bg.style.cssText = "width:100%;height:100%;_height:expression(this.parentNode.clientHeight);position:absolute;left:0;top:0;\
            background:#000;opacity:0.4;filter:alpha(opacity=40);";
        div.appendChild(div.ifr = document.createElement('iframe'));
        div.ifr.style.cssText = 'width:100%;height:100%;position:absolute;left:0;top:0;filter:alpha(opacity=0);opacity:0';
        div.appendChild(div.scroll = document.createElement('div'));
        div.scroll.style.cssText = "width:100%;height:100%;position:absolute;left:0;top:0;/*overflow:auto;*/overflow:hidden;";
        div.scroll.appendChild(div.rel = document.createElement('div'));
        div.rel.style.cssText = "height:100%;_height:100%;position:relative;";
        div.rel.appendChild(div.table = document.createElement('table'));
        div.td = div.table.insertRow(0).insertCell(0);
        div.table.style.cssText = 'width:100%;_width:expression(documentElement.clientWidth);\
            height:100%;_height:expression(documentElement.clientHeight);position:absolute;left:0;top:0;\
            border-collapse:collapse;border:solid 0;';
        //div.td.style.cssText = "text-align:center;vertical-align:middle;";
        div.td.style.textAlign = opts.centerX ? "center" : "left";
        div.td.style.verticalAlign = opts.centerY ? "middle" : "top";
        div.appendChild(div.over = document.createElement("div"));
        div.over.style.cssText = "width:100%;height:100%;position:absolute;left:0;top:0;display:none;";

        div.msgparent = div.msg.parentNode;
        div.td.appendChild(div.box = div.msgparent.removeChild(div.msg));
        div.box.style.cssText = 'display:table;//display:inline;visibility:visible;';
        div.box.style.margin = opts.centerX ? "0 auto" : "0";

        _window_onkeydown = document.documentElement.onkeydown;

        document.documentElement.onkeydown = function (Event) {
            evt = window.event ? event : Event;
            if (evt.keyCode == 27) {
                lightBox.hide();
            }
        };
        var boxClick = false;
        div.td.onclick = function () {
            if (boxClick) {
                boxClick = false;
            } else {
                lightBox.hide();
            }
        };
        div.box.onclick = function () { boxClick = true; };

        return div;
    },
    hide: function () {
        document.documentElement.onkeydown = _window_onkeydown;

        function tmpHide() {
            if (!div) return;
            div.box.style.display = 'none';
            div.msgparent.appendChild(div.td.removeChild(div.box));
            document.body.removeChild(div);
            div = null;

            /*document.documentElement.style.width = "auto";
            document.documentElement.style.overflow = "";*/
            var sdiv = document.createElement("div");
            document.body.appendChild(sdiv);
            sdiv.style.height = "1px";
            setTimeout(function () {
                document.body.removeChild(sdiv);
                /*document.documentElement.style.left = 0 + "px";
                document.documentElement.style.top = 0 + "px";
                document.documentElement.scrollLeft = sx;
                document.documentElement.scrollTop = sy;*/

            }, 0);
        }

        div.over.style.display = "block";
        $(div.table).fadeOut(400);
        $(div.bg).fadeOut(400, tmpHide);
    }
};

function switchTerm(blockId) {
    var block = $("#" + blockId),
        self = $('[onclick*="' + blockId + '"]');
    block.toggleClass('termOpen');
    block.stop().slideToggle();
    self.toggleClass('termTitleOpen');
};

function showTerm(blockId) {
    $("#" + blockId).show();
    $('[onclick*="' + blockId + '"]').hide();
};

//возвращает абсолютную позицию блока
function getAbsolutePosition(id) {
    id = typeof (id) == 'string' ? ('#' + id) : id;
    var pos = $(id).offset();
    var marg = (document.documentElement.clientWidth - document.body.offsetWidth) / 2;
    marg = marg > 0 ? Math.floor(marg) : 0;
    return { x: (pos.left - marg), y: pos.top };
}

//switch term link
$(function () {
    $('.termTitle').addClass('link link_dotted');
});

function InitFeedbackLightbox(containerId, params) {
    $(document).on("click", params.linkClass, function () {
        var url = $(this).attr('href');
        var specialistGroup = getURLParameter(url, 'specialistGroup');
        $(params.specialistGroupId).val(specialistGroup);

        var buttons = [
            {
                text: 'Отправить',
                click: function () {
                    this.find('form').submit();
                },
                id: 'feedbackLightboxSubmit'
            }
        ];
        $('#' + containerId).lightbox({
            buttons: buttons,
            create: function () {
                var self = this;
                var form = self.find('form');
                InitPostSimpleFormAsync(form, {
                    url: params.url || form.attr("action"),
                    successCallback: function () {
                        //self.lightbox('option', 'bottomPanelVisibility', 'default');
                        $('#feedbackLightboxSubmit').hide();
                    },
                    beforeSendCallback: function () {
                        $('#feedbackLightboxSubmit').attr("disabled", true);
                    },
                    completeCallback: function () {
                        $('#feedbackLightboxSubmit').removeAttr("disabled");
                    }
                });
                $(this).find('textarea').elastic();

                //!lteIE7 ? this.find('select').selectBox() : null;
            },
            beforeOpen: function () {
                var self = this;
                var form = self.find('form');
                PostSimpleFormRemoveErrors(form);
                PostSimpleFormClearTextInputs(form);
                PostSimpleFormShowFormChildren(form);
                $('#feedbackLightboxSubmit').show();
                //self.lightbox('option', 'bottomPanelVisibility', 'default');
                //self.lightbox('option', 'buttons', buttons);
            },
            open: function () {
                $(params.focusFieldId).select();
            }
        });

        return false;
    });

    function getURLParameter(url, name) {
        return decodeURIComponent((RegExp(name + '=' + '(.+?)(&|$)').exec(url) || [, ""])[1]);
    }
}

$(function() {
    if (Kontur.LightBox) {
        Kontur.LightBox.showVideoOnLoad();
    }

    if (Kontur.Mobile) {
        Kontur.Mobile.init();
    }

//    $('[data-toggle="popover"]').popover();
});

if (!String.prototype.trim) {
    (function () {
        // Вырезаем BOM и неразрывный пробел
        String.prototype.trim = function () {
            return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
        };
    })();
};
var Kontur = Kontur || {};
(function (window, $, user, undefined) {
    var onClick,
        loginLightbox;
    
    onClick = function (e) {
        if (!user.isAuthenticated()) {
            var currentTarget = $(e.currentTarget),
                returnUrl = currentTarget.attr('data-href') || currentTarget.attr('href') || null,
                welcomeText = currentTarget.attr('data-welcome') || null,
                registartionDefaultTab = currentTarget.attr('data-auth-default') === 'registration',
                loginRegistrationLightboxContainer = $('#LoginRegistrationLightboxContainer'),
                lightboxUrl = loginRegistrationLightboxContainer.data('lightboxUrl'),
                showLightbox = function () {
                    true === registartionDefaultTab
                        ? loginLightbox.showRegistrationLightbox(returnUrl, welcomeText)
                        : loginLightbox.showLoginLightbox(returnUrl, welcomeText);
                };

            e.preventDefault();
            e.stopPropagation();

            if (undefined === loginLightbox) {
                $.ajax({
                    type: 'POST',
                    url: lightboxUrl,
                    dataType: 'jsonp',
                    success: function(data) {
                        loginRegistrationLightboxContainer.html(data.html);
                        loginLightbox = window.loginRegistrationLightbox;

                        showLightbox();
                    }
                });
            } else {
                showLightbox();
            }
        }
    };

    $(function () {
        $('body').on('click', '[data-auth]', onClick);
    });
}(window, jQuery, Kontur.User));
var OneDayActionControl = Class.extend({
    options: {
        contextSelector: '#OneDayAction'
    },
    init: function(seconds, params) {
        var options = this.options = $.extend({}, this.options, params);
        this.spriteSrc = '/theme/products/images/counter-gif.gif';
        this.restSeconds = seconds;
        this.context = $(options.contextSelector);
        this.days = $('[data-bind="days"]', this.context);
        this.hours = $('[data-bind="hours"]', this.context);
        this.minutes = $('[data-bind="minutes"]', this.context);
        /*this.seconds = $('[data-bind="seconds"]', this.context);*/
        this.secondsUnits = $('[data-bind="secondsUnits"]', this.context);
        this.secondsTens = $('[data-bind="secondsTens"]', this.context);
        this.minutesUnits = $('[data-bind="minutesUnits"]', this.context);
        this.minutesTens = $('[data-bind="minutesTens"]', this.context);
        this.daysUnits = $('[data-bind="daysUnits"]', this.context);
        this.daysTens = $('[data-bind="daysTens"]', this.context);
        this.hoursUnits = $('[data-bind="hoursUnits"]', this.context);
        this.hoursTens = $('[data-bind="hoursTens"]', this.context);
        this.__addCoords();
        this.__bindEvents();
        this.__startShowing();
    },
    __startShowing:function() {
        setTimeout($.proxy(function () {
            this.context.removeClass('prepare');
        }, this), 1000);
    },
    __addCoords: function () {
                // to get 0,  1,    2,   3,     4,     5,    6,   7,    8,   9,  0->5, 0->2, 0->3
        this.coords = [-74, -109, -144, -179, -214, -249, -284, -319, -354, -39, -4, -424, -459 ];
    },
    __bindEvents: function() {
        setTimeout($.proxy(this.__updateTime, this), 1000);
    },
    __updateTime: function () {
        var restSeconds = this.restSeconds = this.restSeconds - 1;
        
        if (restSeconds > 0) {
            setTimeout($.proxy(this.__updateTime, this), 1000);
        }
        
        //seconds units
        var seconds = this.__pad(restSeconds % 60, 2);
        
        //if (!$.browser.webkit) {
        this.secondsUnits.attr('src', "").attr('src', this.spriteSrc + '?secondsUnits').css({
                left: this.coords[parseInt(seconds.toString().charAt(1))] + 'px'
            });
        /*} else {
            var newImg = $(new Image());
            newImg.attr('src', this.spriteSrc).css({ left: this.coords[parseInt(seconds.toString().charAt(1))] + 'px' });
            this.secondsUnits.replaceWith(newImg);
            this.secondsUnits = newImg;
        }*/
        //Seconds Tens
        if (this.secondsTens.data('current') != seconds.toString().charAt(0) || seconds == '59') {
            this.secondsTens.data('current', seconds.toString().charAt(0));
            this.secondsTens.attr('src', "").attr('src', this.spriteSrc + '?secondsTens').css({
                left: $.proxy(function () {
                    if (seconds == '59') {
                        return this.coords[10] + 'px';
                    } else {
                        return this.coords[parseInt(seconds.toString().charAt(0))] + 'px';
                    }
                    
                }, this)
            });
        }
        
        //Minutes units
        var minutes = this.__pad(Math.floor((restSeconds % (60 * 60)) / 60), 2);

        if (this.minutesUnits.data('current') != minutes.toString().charAt(1)) {
            this.minutesUnits.data('current', minutes.toString().charAt(1));
            this.minutesUnits.attr('src', "").attr('src', this.spriteSrc + '?minutesUnits').css({
                left: $.proxy(function () {
                    if (minutes == '59') {
                        return this.coords[9] + 'px';
                    } else {
                        return this.coords[parseInt(minutes.toString().charAt(1))] + 'px';
                    }

                }, this)
            });
        }
        //Minutes tens
        if (this.minutesTens.data('current') != minutes.toString().charAt(0)) {
            this.minutesTens.data('current', minutes.toString().charAt(0));
            this.minutesTens.attr('src', "").attr('src', this.spriteSrc + '?minutesTens').css({
                left: $.proxy(function () {
                    if (minutes == '59') {
                        return this.coords[10] + 'px';
                    } else {
                        return this.coords[parseInt(minutes.toString().charAt(0))] + 'px';
                    }

                }, this)
            });
        }
        
        //days units
        var days = this.__pad(Math.floor(restSeconds / (60 * 60 * 24)), 2);
        if (this.daysUnits.data('current') != days.toString().charAt(1)) {
            this.daysUnits.data('current', days.toString().charAt(1));
            this.daysUnits.attr('src', "").attr('src', this.spriteSrc + '?daysUnits').css({
                left: $.proxy(function () {
                    if (days == '59') {
                        return this.coords[10] + 'px';
                    } else {
                        return this.coords[parseInt(days.toString().charAt(1))] + 'px';
                    }

                }, this)
            });
        }
        //days tens
        if (this.daysTens.data('current') != days.toString().charAt(0)) {
            this.daysTens.data('current', days.toString().charAt(0));
            this.daysTens.attr('src', "").attr('src', this.spriteSrc + '?daysTens').css({
                left: $.proxy(function () {
                    if (days == '59') {
                        return this.coords[10] + 'px';
                    } else {
                        return this.coords[parseInt(days.toString().charAt(0))] + 'px';
                    }

                }, this)
            });
        }


        //Hours units
        var hours = this.__pad(Math.floor((restSeconds % (60 * 60 * 24)) / (60 * 60)), 2);
        if (this.hoursUnits.data('current') != hours.toString().charAt(1)) {
            this.hoursUnits.data('current', hours.toString().charAt(1));
            this.hoursUnits.attr('src', "").attr('src', this.spriteSrc + '?hoursUnits').css({
                left: $.proxy(function () {
                    if (hours == '23') {
                        return this.coords[12] + 'px';
                    } else {
                        return this.coords[parseInt(hours.toString().charAt(1))] + 'px';
                    }

                }, this)
            });
        }
        //Hours tens
        if (this.hoursTens.data('current') != hours.toString().charAt(0)) {
            this.hoursTens.data('current', hours.toString().charAt(0));
            this.hoursTens.attr('src', "").attr('src', this.spriteSrc + '?hoursTens').css({
                left: $.proxy(function () {
                    if (hours == '23') {
                        return this.coords[11] + 'px';
                    } else {
                        return this.coords[parseInt(hours.toString().charAt(0))] + 'px';
                    }

                }, this)
            });
        }

        if (seconds == '00' && minutes == '00' && hours == '00' && days == '00') {
            $('.js-oneDayAction').fadeOut('fast');
        }

        return;
    },
    __pad: function(num, size) {
        var s = num + '';
        while (s.length < size) s = '0' + s;
        return s;
    }
});

var ProductPageController = Class.extend({
    init: function (options) {
        $(options.showAllResponsesLinkSelector).click(function () {
            $(this).closest(options.responseItemSelector).remove();
            $(options.restResponsesBlockSelector).each(function (i, el) {
                setTimeout(function () {
                    $(el).removeClass('hide').addClass("animated fadeInUp");
                }, i * 150);
            });
            
        });

        $(options.readMoreLinkSelector).click(function () {
            var link = $(this);
            var responseId = link.data('id');
            $(options.responseFullTextSelector + '[data-id="' + responseId + '"]').removeClass('none');
            link.remove();
        });
    }
});
var UserMenuBlock = (function ($) {
    'use strict';
    var init,
        module = function () {
            init.apply(this, arguments);
        };

    init = function () {
        $('#userMenudropDownLink').click(function () {
            if ($(this).hasClass('dropDownLink_active')) {
                $(this).removeClass('dropDownLink_active');
                $("#userMenuBlockList").hide();

                $(document).off('click.userMenuClickListener');
            } else {
                var self = $(this);
                self.addClass('dropDownLink_active');
                $("#userMenuBlockList").show();

                $(document).on('click.userMenuClickListener', function (e) {
                    if (!$(e.target).hasClass('userMenuBlock') && $(e.target).parents('.userMenuBlock').size() == 0) {
                        self.removeClass('dropDownLink_active');
                        $("#userMenuBlockList").hide();
                        $(document).off('click.userMenuClickListener');
                    }
                });
            }
        });
    };

    return module;
})(jQuery);

/* [Product menu */
var Kontur = Kontur || {};
Kontur.ProductEntryMenu = (function (document, $) {
    'use strict';
    var defaultOptions = {
        contextId: '',
        entryLinkId: '',
        entriesUrl: ''
    },
        options,
        $document = $(document),
        entriesLoaded = false,
        entryLink,
        context,
        init,
        bindEvents,
        onEntryLinkClick,
        onItemClick,
        hideMenu,
        showMenu,
        loadEntries,
        onEntriesLoaded,
        onEntriesError,
        onEntriesComplete,
        menu = {
            init: function () {
                init.apply(this, arguments);
            },
            close: function () {
                hideMenu();
            }
        };

    init = function (params) {
        options = $.extend({}, defaultOptions, params);
        entryLink = $('#' + options.entryLinkId);
        context = $('#' + options.contextId);

        bindEvents.call(this);
    };

    bindEvents = function () {
        entryLink.on('click', $.proxy(onEntryLinkClick, this));
        context.on('click', '[data-bind="item"]', $.proxy(onItemClick, this));
    };

    onEntryLinkClick = function (e) {
        e.preventDefault();
        if (entryLink.hasClass('button-login_active_js')) {
            hideMenu();
        } else {
            showMenu();
        }
    };

    onItemClick = function () {
        hideMenu();
    };

    hideMenu = function () {
        $document.off('click.loginBlock');
        context.fadeOut('fast');
        entryLink.removeClass('button-login_active_js');
    };

    showMenu = function () {
        if (false === entriesLoaded) {
            loadEntries();
            return;
        }
        context.fadeIn('fast');
        entryLink.addClass('button-login_active_js');
        $document.on('click.loginBlock', function (e) {
            var target = $(e.target);
            // todo антон: грубейшее нарушение ООП, да еще в общем коде
            if (!target.is(context)
                && target.parents('#' + options.contextId).size() == 0
                && !target.is(entryLink)
                && target.parents('.button-login-userNotLogined').size() == 0
                && !target.is('.lightbox2')
                && target.parents('.lightbox2').size() == 0) {
                hideMenu();
            }
        });
    };

    loadEntries = function () {
        $.ajax({
            url: options.entriesUrl,
            dataType: 'jsonp',
            type: 'GET',
            context: this,
            error: onEntriesError,
            success: onEntriesLoaded,
            complete: onEntriesComplete
        });
    };

    onEntriesLoaded = function (data) {
        $('[data-bind="content"]', context).html(data.html);
    };

    onEntriesError = function () {
        $('[data-bind="content"]', context).html('Извините, произошла ошибка при загрузке сервисов. Попробуйте перезагрузить страницу');
    };

    onEntriesComplete = function () {
        entriesLoaded = true;
        showMenu();
    };

    return menu;
}(document, jQuery));
/* Product menu] */

/* [Eye Wink in password input */
Kontur.ShowHidePasswordElement = (function ($) {
    'use strict';
    var defaultOptions = {
        context: 'body',
        selector: 'input[type=password]',
        showElementClass: 'konturIconic konturIcon_E043',
        hideElementClass: 'konturIconic konturIcon_E044'
    },
    bindEvents,
    showHideElement,
    selector,
    context,
    showElementClass,
    hideElementClass,
    toggleShowHidePassword,
    toggleShowHideElementClass,
    uglyHackTogglePassword,
    module = function () { };

    bindEvents = function () {
        context.find(selector).each(function () {
            //ToDo daks EyeWink - не обрабатывается ситуация с несколькими паролями на странице
            $(this).after(showHideElement);
            showHideElement.data('passwordInput', $(this));
        });
        showHideElement.on('click', function (e) {
            e.preventDefault();
            toggleShowHidePassword($(this));
            toggleShowHideElementClass($(this));
        });
    };

    toggleShowHidePassword = function (element) {
        var passwordInput = element.data('passwordInput'),
            type = passwordInput[0].type,
            newType = type === 'password' ? 'text' : 'password';

        try {
            passwordInput[0].setAttribute('type', newType);
        } catch (e) {
        }

        if (passwordInput[0].type !== newType) {
            var newInput = uglyHackTogglePassword(passwordInput, newType, element);
            element.data('passwordInput', newInput);
        }
    }

    toggleShowHideElementClass = function (element) {
        element
            .toggleClass(showElementClass)
            .toggleClass(hideElementClass);
    }

    uglyHackTogglePassword = function (passwordInput, newType) {
        var searchValue = newType === 'password' ? 'type=text' : 'type=password',
            replaceValue = newType === 'password' ? ' type=password' : 'type=text',
            newInput = $(passwordInput[0].outerHTML.replace(searchValue, replaceValue));

        newInput.val(passwordInput.val());
        passwordInput.replaceWith(newInput);

        return newInput;
    }

    module.init = function (options) {
        options = $.extend(defaultOptions, options),
        showHideElement = $("<span />", {
            'class': 'js-passwordBtn passwordBtn ' + options.showElementClass
        }),
        selector = $(options.selector),
        context = $(options.context),
        showElementClass = options.showElementClass,
        hideElementClass = options.hideElementClass;

        bindEvents();
    };

    return module;
}(jQuery));
/* Eye Wink in password input] */

/* [Product main text changing */
function initProductListWork(options) {
    options.area.mouseleave(function () {
        options.textBlocks.hide();
        options.generalText.show();
        $('.product-general-arrow').hide();
    });
    options.links.mouseenter(function () {
        var textId = $(this).attr('data-id');
        options.generalText.hide();
        options.textBlocks.hide().filter('[id=' + textId + ']').show();
        $('.product-general-arrow').hide();
        $(this).find('.product-general-arrow').show();
    });
}
/* Product main text changing] */

/* [LoginForm */
function LoginForm(options) {
    var requiredMessage = 'Заполните поле';
    var form = $(options.selector);

    form.validate({
        rules: {
            'LoginForm.Email': {
                required: {
                    depends: function () {
                        $(this).val($.trim($(this).val()));
                        return true;
                    }
                },
                email: true,
                maxlength: 50
            },
            'LoginForm.Password': {
                required: true
            }
        },
        messages: {
            'LoginForm.Email': {
                required: requiredMessage,
                email: 'Некорректный электронный адрес',
                maxlength: 'Длина не должна превышать {0} символов'
            },
            'LoginForm.Password': requiredMessage
        },
        errorClass: 'field-validation-error',
        errorElement: 'span',
        highlight: highlightElement,
        unhighlight: unhighlightElement,
        onkeyup: false,
        onclick: false
    });

    function highlightElement(element) {
        $(element).addClass("input-validation-error");
    };

    function unhighlightElement(element) {
        $(element).removeClass("input-validation-error");
    };

    function clearInputs() {
        form.find('input[type=text], input[type=password]').val('');
    };

    this.reset = function () {
        var validator = form.validate();
        validator.resetForm();
        validator.elements().each(function (index, e) {
            unhighlightElement(e);
        });
        clearInputs(form);
        $('#LoginForm_Email').focus();
    };

    this.setReturnUrl = function (returnUrl) {
        form.find('input[name=returnUrl]').val(returnUrl || window.location.href);

        var registrationLink = $('a[data-bind="registrationLink"]');
        var registrationLinkHref = registrationLink.attr('href');
        registrationLink.attr('href', updateQueryStringParameter(registrationLinkHref, "returnUrl", encodeURIComponent(returnUrl)));

        this.setCertificateLink(returnUrl);
    };
    this.setCertificateLink = function (returnUrl) {
        var url = returnUrl ? returnUrl : window.location.href;
        url = url.slice(0, 1) == '/' ? window.location.protocol + '//' + window.location.host + url : url;
        var certLink = $('[data-cert-link]'),
            baseUrl = certLink.data('base-url');
        certLink.attr('href', baseUrl + encodeURIComponent(url));
    },
    this.getReturnUrl = function () {
        return form.find('input[name=returnUrl]').val();
    };

    $('#LoginForm_Email').focus();

    function updateQueryStringParameter(uri, key, value) {
        var re = new RegExp("([?&])" + key + "=.*?(&|$)", "i");
        var separator = uri.indexOf('?') !== -1 ? "&" : "?";
        if (uri.match(re)) {
            return uri.replace(re, '$1' + key + "=" + value + '$2');
        }
        else {
            return uri + separator + key + "=" + value;
        }
    }

}
/* LoginForm] */

/* [RegistationForm */
function RegistrationForm(options) {
    var requiredMessage = 'Заполните поле',
        maxlengthMessage = 'Длина не должна превышать {0} символов',
        nameMessages = {
            required: requiredMessage,
            maxlength: maxlengthMessage
        },
        form = $(options.selector),
        rules = {
            'RegistrationForm.LastName': {
                required: true,
                maxlength: 50
            },
            'RegistrationForm.FirstName': {
                required: true,
                maxlength: 50
            },
            'RegistrationForm.Patronymic': {
                maxlength: 50
            },
            'RegistrationForm.Liame': {
                required: {
                    depends: function () {
                        $(this).val($.trim($(this).val()));
                        return true;
                    }
                },
                email: true,
                maxlength: 50
            },
            'RegistrationForm.Password': {
                required: true,
                minlength: options.passwordMinlength,
                maxlength: options.passwordMaxlength,
                passwordCorrect: true
            }
        },
        messages = {
            'RegistrationForm.LastName': nameMessages,
            'RegistrationForm.FirstName': nameMessages,
            'RegistrationForm.Patronymic': {
                maxlength: maxlengthMessage

            },
            'RegistrationForm.Liame': {
                required: requiredMessage,
                email: 'Некорректный электронный адрес',
                maxlength: maxlengthMessage

            },
            'RegistrationForm.Password': {
                required: requiredMessage,
                minlength: 'Необходимо указать пароль не менее {0} символов.',
                maxlength: 'Необходимо указать пароль не более {0} символов.'
            }
        };
    if (true === options.showExtraWithEmail) {
        rules['RegistrationEmailForm.Liame'] = {
            required: {
                depends: function () {
                    $(this).val($.trim($(this).val()));
                    return true;
                }
            },
            email: true,
            maxlength: 50
        };
        messages['RegistrationEmailForm.Liame'] = {
            required: requiredMessage,
            email: 'Некорректный электронный адрес',
            maxlength: maxlengthMessage
        };
    }
    if (true === options.showExtraform) {
        rules['RegistrationExtraForm.Phone'] = { required: true };
        //rules['RegistrationExtraForm.City'] = { required: true };
        //rules['RegistrationExtraForm.Organization'] = { required: true };
        rules['RegistrationExtraForm.Position'] = { required: true };
        rules['RegistrationExtraForm.Inn'] = { required: true, inn: true };
        rules['RegistrationExtraForm.Kpp'] = { kpp: { innFieldName: 'RegistrationExtraForm.Inn' } };
        //rules['RegistrationExtraForm.Phone'] = { required: true };
        messages['RegistrationExtraForm.Phone'] = { required: requiredMessage };
        //messages['RegistrationExtraForm.City'] = { required: requiredMessage };
        //messages['RegistrationExtraForm.Organization'] = { required: requiredMessage };
        messages['RegistrationExtraForm.Position'] = { required: requiredMessage };
        messages['RegistrationExtraForm.Inn'] = { required: requiredMessage };

        this.innKppControl = new InnKppControl({
            innSelector: form.find('[name="RegistrationExtraForm.Inn"]').selector,
            kppSelector: form.find('[name="RegistrationExtraForm.Kpp"]').selector
        });
    }

    form.validate({
        rules: rules,
        messages: messages,
        errorClass: 'field-validation-error',
        errorElement: 'span',
        highlight: highlightElement,
        unhighlight: unhighlightElement,
        onkeyup: false,
        onclick: false
    });

    function highlightElement(element) {
        $(element).addClass("input-validation-error");
    };

    function unhighlightElement(element) {
        $(element).removeClass("input-validation-error");
    };

    function clearInputs() {
        form.find('input[type=text], input[type=password]').val('');
    };

    this.reset = function () {
        var validator = form.validate();
        validator.resetForm();
        validator.elements().each(function (index, e) {
            unhighlightElement(e);
        });
        clearInputs(form);

        $('#RegistrationForm_LastName').focus();
    };

    this.setReturnUrl = function (returnUrl) {
        form.find('input[name=returnUrl]').val(returnUrl || window.location.href);
        this.setCertificateLink(returnUrl);
    };
    this.setCertificateLink = function (returnUrl) {
        var url = returnUrl ? returnUrl : window.location.href;
        url = url.slice(0, 1) == '/' ? window.location.protocol + '//' + window.location.host + url : url;
        var certLink = $('[data-cert-link]'),
            baseUrl = certLink.data('base-url');
        certLink.attr('href', baseUrl + encodeURIComponent(url));
    },
    this.getReturnUrl = function () {
        return form.find('input[name=returnUrl]').val();
    };

    $('#RegistrationForm_LastName').focus();
}
/* RegistationForm] */

/* [LoginRegistrationLightbox */
function LoginRegistrationLightbox(options) {
    var self = this,
        loginForm = options.loginForm,
        registrationForm = options.registratonForm,
        returnUrlBase = options.returnUrlBase,
        element = $(options.selector);

    if ($.browser.msie) {
        $('.certificateLoginLink').attr('target', '');
    }
    element.on('click', '.loginRegistrationBlock-tabs-registation', function (e) {
        e.preventDefault();
        if (!isRegistrationFormActive()) {
            self.showRegistrationLightbox(loginForm.getReturnUrl(), getWelcomeText());
        }
    });

    element.on('click', '.loginRegistrationBlock-tabs-login', function (e) {
        e.preventDefault();
        if (!isLoginFormActive()) {
            self.showLoginLightbox(registrationForm.getReturnUrl(), getWelcomeText());
        }
    });

    element.on('click', '.js-registrationSuccessButton', function (e) {
        e.preventDefault();
        hideLightbox();

        $(this).attr('disabled', true);
    });

    element.on('click', 'a[target="_blank"]', function () {
        hideLightbox();
    });

    function isLoginFormActive() {
        return $('.loginRegistrationBlock-tabs-content-login').is(':visible');
    }

    function isRegistrationFormActive() {
        return $('.loginRegistrationBlock-tabs-content-registration').is(':visible');
    }

    function transformReturnUrl(url) {
        if (!url) {
            url = location.pathname + location.search + location.hash;
        }
        if (url.indexOf('/') === 0) {
            return returnUrlBase + url;
        }
        return url;
    }

    this.showLoginLightbox = function (returnUrl, welcomeText) {
        $(".loginRegistrationBlock-tabs-item").removeClass("loginRegistrationBlock-tabs-item_active").find('span').addClass('link link_dotted');
        $(".loginRegistrationBlock-tabs-login").addClass("loginRegistrationBlock-tabs-item_active").find('span').removeClass('link link_dotted');
        $(".loginRegistrationBlock-tabs-content-registration").hide();
        $(".loginRegistrationBlock-tabs-content-login").show();

        setWelcomeText(welcomeText);
        showLightbox();
        if (loginForm) {
            loginForm.reset();
            loginForm.setReturnUrl(transformReturnUrl(returnUrl));
        }
    };

    this.showRegistrationLightbox = function (returnUrl, welcomeText) {
        $(".loginRegistrationBlock-tabs-item").removeClass("loginRegistrationBlock-tabs-item_active").find('span').addClass('link link_dotted');
        $(".loginRegistrationBlock-tabs-registation").addClass("loginRegistrationBlock-tabs-item_active").find('span').removeClass('link link_dotted');
        $(".loginRegistrationBlock-tabs-content-registration").show();
        $(".loginRegistrationBlock-tabs-content-login").hide();

        setWelcomeText(welcomeText);
        showLightbox();
        if (registrationForm) {
            registrationForm.reset();
            registrationForm.setReturnUrl(transformReturnUrl(returnUrl));
        }
    };

    function setWelcomeText(text) {
        $(".loginRegistrationBlock-welcomeText", $(options.selector)).html(text || '');
        $(".loginRegistrationBlock-welcomeText-wrap")[text ? 'show' : 'hide']();
        if (text) {
            $(".loginRegistrationBlock-welcomeText-wrap").parents('.loginRegistrationBlock-list-item').next().addClass('loginRegistrationBlock-list-item_pb0-js');
        }
    }

    function getWelcomeText() {
        return $(".loginRegistrationBlock-welcomeText", $(options.selector)).html();
    }

    function showLightbox() {
        var selector = $(options.selector);
        if (!selector.lightbox("isOpen")) {
            selector.lightbox({ bottomPanelVisibility: false, lightboxClass: 'loginFormLightbox' });
        }
    };

    function hideLightbox() {
        var selector = $(options.selector);
        selector.lightbox("close");
    }
};
/* LoginRegistratiobLightbox*/

Kontur.Widget = Kontur.Widget || {};
Kontur.Widget.QuickSearchBlock = (function ($) {
    var insertWidgets,
        module = function () { };

    insertWidgets = function () {
        $('[data-quick-search]').each(function (index, widgetContainer) {
            var widget = $(widgetContainer);
            $.ajax({
                url: '/ajax/products/' + widget.data('quickSearch') + '/quicksearch',
                cache: false,
                success: function (data) {
                    widget.html(data);
                }
            });
        });
    };

    module.init = function () {
        insertWidgets();
    };

    return module;
}(jQuery));
Kontur.Module('Kontur.RegistrationForm', function() {
    this.init = function(options) {
        var requiredMessage = 'Заполните поле',
            maxlengthMessage = 'Длина не должна превышать {0} символов',
            nameMessages = {
                required: requiredMessage,
                maxlength: maxlengthMessage
            },
            form = $(options.selector),
            rules = {
                'RegistrationForm.LastName': {
                    required: true,
                    maxlength: 50
                },
                'RegistrationForm.FirstName': {
                    required: true,
                    maxlength: 50
                },
                'RegistrationForm.Patronymic': {
                    maxlength: 50
                },
                'RegistrationForm.Liame': {
                    required: {
                        depends: function() {
                            $(this).val($.trim($(this).val()));
                            return true;
                        }
                    },
                    email: true,
                    maxlength: 50
                },
                'RegistrationForm.Password': {
                    required: true,
                    minlength: options.passwordMinlength,
                    maxlength: options.passwordMaxlength,
                    passwordCorrect: true
                }
            },
            messages = {
                'RegistrationForm.LastName': nameMessages,
                'RegistrationForm.FirstName': nameMessages,
                'RegistrationForm.Patronymic': {
                    maxlength: maxlengthMessage
                },
                'RegistrationForm.Liame': {
                    required: requiredMessage,
                    email: 'Некорректный электронный адрес',
                    maxlength: maxlengthMessage
                },
                'RegistrationForm.Password': {
                    required: requiredMessage,
                    minlength: 'Необходимо указать пароль не менее {0} символов.',
                    maxlength: 'Необходимо указать пароль не более {0} символов.'
                }
            };
        if (true === options.showExtraWithEmail) {
            rules['RegistrationForm.Liame'] = {
                required: {
                    depends: function() {
                        $(this).val($.trim($(this).val()));
                        return true;
                    }
                },
                email: true,
                maxlength: 50
            };
            messages['RegistrationForm.Liame'] = {
                required: requiredMessage,
                email: 'Некорректный электронный адрес',
                maxlength: maxlengthMessage
            };
        }
        if (true === options.showExtraform) {
            rules['RegistrationForm.Phone'] = { required: true };
            rules['RegistrationForm.Position'] = { required: true };
            rules['RegistrationForm.Inn'] = { required: true, inn: true };
            rules['RegistrationForm.Kpp'] = { kpp: { innFieldName: 'RegistrationForm.Inn' } };
            messages['RegistrationForm.Phone'] = { required: requiredMessage };
            messages['RegistrationForm.Position'] = { required: requiredMessage };
            messages['RegistrationForm.Inn'] = { required: requiredMessage };

            this.innKppControl = new InnKppControl({
                innSelector: form.find('[name="RegistrationForm.Inn"]').selector,
                kppSelector: form.find('[name="RegistrationForm.Kpp"]').selector
            });
        }

        form.validate({
            rules: rules,
            messages: messages,
            errorClass: 'field-validation-error',
            errorElement: 'span',
            errorPlacement: errorPlacement,
            highlight: highlightElement,
            unhighlight: unhighlightElement,
            onkeyup: false,
            onclick: false
        });

        function errorPlacement(error, element) {
            error.appendTo(element.parent());
        }

        function highlightElement(element) {
            $(element).addClass("input-validation-error");
        };

        function unhighlightElement(element) {
            $(element).removeClass("input-validation-error");
        };

        function clearInputs() {
            form.find('input[type=text], input[type=password]').val('');
        };

        this.reset = function() {
            var validator = form.validate();
            validator.resetForm();
            validator.elements().each(function(index, e) {
                unhighlightElement(e);
            });
            clearInputs(form);

            $('#RegistrationForm_LastName').focus();
        };

        this.setReturnUrl = function(returnUrl) {
            form.find('input[name=returnUrl]').val(returnUrl || window.location.href);
            this.setCertificateLink(returnUrl);
        };
        this.setCertificateLink = function(returnUrl) {
                var url = returnUrl ? returnUrl : window.location.href;
                url = url.slice(0, 1) == '/' ? window.location.protocol + '//' + window.location.host + url : url;
                var certLink = $('[data-cert-link]'),
                    baseUrl = certLink.data('base-url');
                certLink.attr('href', baseUrl + encodeURIComponent(url));
            },
            this.getReturnUrl = function() {
                return form.find('input[name=returnUrl]').val();
            };

        $('#RegistrationForm_LastName').focus();
    }
});
;(function ($) {
    var defaults = {
        cssClass: 'selectWrap'
    };
    var options;
    var frame;

    function Label(parameters) {
        var element = $('<a href="" class="'+options.cssClass+'Label"></a>');
        var labelText = $('<span class="' + options.cssClass + 'Label-text"></span>');

        element.append(labelText);
        element.click(function() { return false; });

        element.setTitle = function(text) {
            labelText.html(text);
        };

        return element;
    }

    function Filter(headerText) {
        var filter = $('<div class="'+options.cssClass+'Filter">').css({position:'absolute'});
        var header = $('<div class="'+options.cssClass+'Filter-header">'+headerText+'</div>');
        var scroller = $('<div class="' + options.cssClass + 'Filter-scroll"></div>');
        var list = $('<div class="' + options.cssClass + 'Filter-list"></div>');
        filter.append(header);
        filter.append(scroller);
        scroller.append(list);

        filter.getList = function getList() {
            return list;
        };

        filter.getTitle = function() {
            return header;
        };

        filter.getScroller = function getScroller() {
            return scroller;
        };

        filter.moveTitleDown = function moveTitleDown() {
            filter.append(header.remove()).addClass(options.cssClass+'Filter_reversed');
        };
        
        filter.moveTitleUp = function moveTitleUp() {
            filter.append(scroller.remove()).removeClass(options.cssClass+'Filter_reversed');
        };

        filter.setTitle = setTitle;
        function setTitle(value) {
            header.html(value);
        }
        
        $(document.body).append(filter);
        return filter;
    }
    
    $.fn.extend({
            selectWrap: function(parameters) {
                options = $.extend({}, defaults, parameters);
                var select = this;
                
                if(select.attr('disabled')) return;

                var form = select.get(0).form;
                var label = Label();
                var labelText = getActiveOptionText();
                form = form ? $(form) : null;
                form ? form.hide() : select.hide();
                label.insertBefore(form ? form : select);
                label.setTitle(labelText);
                label.bind('click', showFilter);
                
                function getActiveOptionText() {
                    return select.find('option:selected').html();
                }

                function showFilter(parameters) {
                    if(!frame) {
                        frame = new Filter(labelText);
                    }
                    fillFilterList();
                    frame.getTitle().css({ fontSize: label.css('fontSize') });
                    frame.setTitle(getActiveOptionText());
                    placeFilterOverLabel();
                    addClickEvents();
                    $(document.body).bind('click.selectwrap', hideFilter);
                    return false;
                }

                function hideFilter(parameters) {
                    frame.hide();
                    $(document.body).unbind('click.selectwrap');
                }

                function setItem() {
                    var optionList = arguments[0];
                    var option = optionList.eq($(this).data('index'));
                    option.prop({ selected: true });
                    label.setTitle(option.html());
                    select.change();
                }

                function fillFilterList(parameters) {
                    var list = frame.getList();
                    list.empty();
                    var optionList = select.find('option').not(':selected');
                    var item;
                    var group = list;
                    for(var i = 0; i < optionList.length; i++) {
                        var option = optionList.eq(i);
                        if(option.data('level') == -1) {
                            group = $('<div class="' + options.cssClass + 'Filter-group"><div class="'+options.cssClass+'Filter-groupHeader">'+option.html()+'</div></div>');
                            list.append(group);
                        } else if(option.data('level') == 1) {
                            group = $('<div class="' + options.cssClass + 'Filter-group"><div class="'+options.cssClass+'Filter-groupHeader">\
                                <span class="'+options.cssClass+'Filter-link" data-index="'+i+'">'+option.html()+'</span></div></div>');
                            list.append(group);
                        } else {
                            item = $('<div class="' + options.cssClass + 'Filter-item"><span class="'+options.cssClass+'Filter-link" data-index="'+i+'">'+option.html()+'</span></div>');
                            group.append(item);
                        }
                    }

                }

                function addClickEvents() {
                    var list = frame.getList();
                    var optionList = select.find('option').not(':selected');
                    list.on('click', '.'+options.cssClass + 'Filter-link', function() {
                        setItem.apply(this,[optionList]);
                        hideFilter();
                    });
                    frame.getTitle().click(hideFilter);
                    frame.click(function() { return false; });
                }
                function placeFilterOverLabel() {
                    var position = label.offset();
                    frame.css({
                            left: position.left,
                            top: position.top
                        });
                    frame.show();
                    var scroller = frame.getScroller();
                    frame.moveTitleUp();
                    if(position.top + frame.height() > $(document.documentElement).height() + $(document).scrollTop()) {
                        if(position.top - scroller.height() > $(document).scrollTop()) {
                            frame.moveTitleDown();
                            frame.css({
                                    top: position.top-scroller.height()
                                });                        
                        }
                    }
                }
                return this;
            }
        });

})(jQuery);

;
function archiveMenu() {
    var archiveMenuBlock = $('.archiveMenu');
    var archiveMenuItems = archiveMenuBlock.find('.archiveMenu-item');
    var archiveMenuYears = archiveMenuBlock.find('.archiveMenu-year');

    archiveMenuYears.click(function () {
        archiveMenuItems.filter('.archiveMenu-item_open').removeClass('archiveMenu-item_open');
        $(this).parents('.archiveMenu-item').addClass('archiveMenu-item_open');
        return false;
    });
};
var Kontur = Kontur || {};
Kontur.About = Kontur.About || {};
Kontur.About.Messages = Kontur.About.Messages || {};

Kontur.About.PartnershipController = Class.extend({
    init: function(params) {
        var autocompleteControl = new Kontur.About.AutoCompleteControl(params);
    }
});

Kontur.About.Messages.NO_RESULT_MESSAGE = 'По вашему запросу ничего не найдено';
Kontur.About.AutoCompleteControl = Class.extend({
    options: {
        autoCompleteSelector: '',
        autocompleteUrl: ''
    },
    init: function(params) {
        var options = this.options = $.extend({}, this.options, params);
        
        $(options.autoCompleteSelector).autocomplete({
            source: function (request, response) {
                $.ajax({
                    url: options.autocompleteUrl + '/' + request.term,
                    dataType: 'json',
                    scriptCharset: 'utf-8',
                    success: function (data) {
                        if (data.length === 0) {
                            response([Kontur.About.Messages.NO_RESULT_MESSAGE]);
                        } else {
                            response($.map(data, function (item) {
                                return {
                                    label: item.value,
                                    value: item.value
                                };
                            }));
                        }
                    }
                });
            },
            minLength: 2,
            autoFocus: true,
            select: function (event, ui) {
                if (ui.item.label === Kontur.About.Messages.NO_RESULT_MESSAGE) {
                    event.preventDefault();
                    return;
                }
            },
            focus: function (event, ui) {
                if (ui.item.label === Kontur.About.Messages.NO_RESULT_MESSAGE) {
                    event.preventDefault();
                }
            }
        });

        if (!options.form.isValid) {
            window.location.hash = options.form.id;
        }
    }
});
var Kontur = Kontur || {};
Kontur.About = Kontur.About || {};

Kontur.About.ManagementIndexController = Class.extend({
    init: function (params) {
        var hash = location.hash,
            handleHash,
            itemsPreview = new Kontur.ItemsPreviewControl(params);

        this.formControl = new Kontur.About.ManagementFormControl(params);

        handleHash = function (locationHash) {
            var managerId = locationHash.replace('#', '');
            if (!isNaN(parseFloat(managerId)) && isFinite(managerId) && false === itemsPreview.isOpened(managerId)) {
                itemsPreview.openItem(managerId);
            }
        };

        if (hash != '') {
            handleHash(hash);
        }

        $(window).on('hashchange', function () {
            handleHash(location.hash);
        });
    }
});

Kontur.About.ManagementFormControl = Class.extend({
    defaultOptions: {
        contextId: '',
        formContainerId: ''
    },
    init: function (params) {
        var options = this.options = $.extend({}, this.defaultOptions, params);
        this.context = $('#' + options.contextId);
        this.formContainer = $('#' + options.formContainerId);
        this.form = $('form', this.formContainer);

        this.__bindEvents();
    },
    __bindEvents: function () {
        this.context.on('click', '[data-bind="ask"]', $.proxy(this.__onAskButtonClicking, this));
        this.context.on('click', '.managementItem', $.proxy(this.__onItemClicking, this));
    },
    __onAskButtonClicking: function (e) {
        var target = $(e.currentTarget),
            url = target.data('url');
        this.form.attr('action', url);
        this.formContainer.lightbox({
            buttons: [{
                text: 'Отправить',
                click: $.proxy(function () {
                    this.form.submit();
                }, this),
                id: 'AskSubmitButton'
            }],
            create: function () {
                InitPostSimpleFormAsync($('form', this), {
                    useDefaultSuccessMessageShowing: false,
                    clearTextInputsOnSuccess: true,
                    successCallback: function (data) {
                        var messageBox = $('#SuccessMessage');
                        $('[data-bind="message"]', messageBox).html(data.Message);
                        messageBox.lightbox();
                    }
                });
            },
            open: function() {
                PostSimpleFormRemoveErrors($('form', this));
            },
            closeText: 'Закрыть'
        });
    },
    __onItemClicking: function (e) {
        var managerId = $(e.currentTarget).data('itemId');

        location.hash = managerId;
    }
});
var Consultant = (function (window, document, $) {
    'use strict';
    var defaultOptions = {
        chatOpen: null,
        widgetLocation: 'https://api.kontur.ru/chat-widget',
        widgetApi: 'https://api.kontur.ru/livechat/v1.1',
        chatWelcomeOpen: null,
        chatWelcomeAction: null,
        offlineAction: null
    },
        defaultDomainsTopics = {
            'diadoc.kontur.ru': 'Диадок',
            'diadoc-widget.kontur.ru': 'Диадок',
            'elba.kontur.ru': 'Эльба',
            'evrika.kontur.ru': 'Контур.Бухгалтерия',
            'o.kontur.ru': 'Экстерн',
            'buhta.kontur.ru ': 'Контур.Бухгалтерия'
        },
        options,
        init,
        chat,
        showWindow,
        module = function () {
            init.apply(this, arguments);
        };

    init = function (params) {
        options = $.extend({}, defaultOptions, params);

        $.getScript(options.widgetLocation + '/widget.min.js', function () { initWidget(); })
    };

    showWindow = function () {
        if (!chat) {
            console.log('Онлайн консультант. Чат не инициализирован.');
            return;
        }
        runSafely(options.chatWelcomeOpen);
        chat.open();
    };

    module.prototype.showWindow = function () {
        showWindow.call(this);
    };

    function registerHandlers() {
        try {
            chat.subscribe('chatStarted', function () {
                runSafely(options.chatWelcomeAction);
            });

            chat.subscribe('mailSent', function () {
                runSafely(options.offlineAction);
            });
        } catch (e) {
            console.error('Онлайн консультант. Не удалось подписаться на события отправки сообщений: ' + e);
        }

    }

    function initWidget() {
        createChat();
        registerHandlers();
        triggerChatIsAvailableNow();
    }

    function createChat() {
        chat = new LiveChat({
            location: options.widgetLocation,
            params: {
                type: getChatType(),
                topic: getTopic(),
                hideMinimizedVersion: true
            }
        });
    }

    function getChatType() {
        return isIe() && isTrustedSite()
            ? 'widget'
            : 'window';
    }

    function getTopic() {
        if (options.topic) {
            return options.topic;
        }
        return defaultDomainsTopics[window.location.hostname];
    }

    function triggerChatIsAvailableNow() {
        $.ajax
            ({
                type: "POST",
                url: options.widgetApi + '/topics/availability',
                dataType: 'json',
                crossDomain: true,
                data: JSON.stringify({ sourceURL: window.location.href }),
                success: function (data) {
                    if (true === data.isChatAvailableNow) {
                        $(window).trigger('OnlineConsultantCount', [1]);
                    } else {
                        $(window).trigger('OnlineConsultantCount', [0]);
                    }
                }
            });
    }

    function isIe(userAgent) {
        userAgent = userAgent || navigator.userAgent;
        return userAgent.indexOf('MSIE ') > -1 || userAgent.indexOf('Trident/') > -1 || userAgent.indexOf('Edge/') > -1;
    }

    function isTrustedSite() {
        var trustedZone = 'kontur.ru';
        var hostName = window.location.hostname;
        return hostName === trustedZone || endsWith(hostName, '.' + trustedZone);

        function endsWith(str, suffix) {
            return str.indexOf(suffix, str.length - suffix.length) !== -1;
        }
    }

    function runSafely(v) {
        if (v && isFunction(v)) v();

        function isFunction(functionToCheck) {
            var getType = {};
            return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
        }
    }

    return module;
}(window, document, jQuery));
function InitCallbackForm(options) {
    var link = $('.js-callbackForm-link'),
        form = $('.js-callbackForm'),
        callbackLightbox = $('#callbackLightboxContent'),
        successLightbox = $('#callbackSuccessLightbox'),
        successLightboxBottomPanel = $('#callbackSuccessLightboxBottomPanel');

    $('[data-bind="close"]', successLightboxBottomPanel).click(function(e) {
        e.preventDefault();
        successLightbox.lightbox('close');
    });

    $('[data-bind="change"]', successLightboxBottomPanel).click(function (e) {
        e.preventDefault();
        callbackLightbox.lightbox('open');
    });

    link.click(function () {

        PostSimpleFormClearTextInputs(form);

        var buttons = [{
            text: 'Отправить',
            click: function () {
                if (form.valid())
                    form.submit();
            },
            id: 'callbackLightboxSubmit'
        }];

        callbackLightbox.lightbox({
            buttons: buttons,
            preventDefaultEvents: true,
            create: function () {
                $(this).find('.js-phone-number').mask('+7 999 999-99-99')
                initValidators();
                $(this).find('textarea').elastic();
                InitPostSimpleFormAsync(form, {
                    beforeSendCallback: function () {
                            $('#callbackLightboxSubmit').attr("disabled", true);
                    },
                    completeCallback: function () {
                        $('#callbackLightboxSubmit').attr("disabled", false);
                    },
                    successCallback: function (data) {
                        var successLightbox = $('#callbackSuccessLightbox');
                        $('[data-bind="phoneNumber"]', successLightbox).html(data.Message);
                        $('#callbackSuccessLightbox').lightbox({
                            panelHtml: '#callbackSuccessLightboxBottomPanel'
                        });
                    },
                    useDefaultSuccessMessageShowing: false,
                    clearTextInputsOnSuccess: false
                });
            },
            beforeOpen: function () {
                PostSimpleFormShowFormChildren(form, { useDefaultSuccessMessageShowing: false });
                form.validate().resetForm();
                PostSimpleFormRemoveErrors(form);
            },
            buttonTemplate: '<span class="btn btn-primary" />',
            open: function () {
                $('#userName').select();
                RegisterPageEvent('/event/callback/show');
            }
        });

        return false;
    });

    function initValidators() {
        jQuery.validator.addMethod("phone", function (value) {
            var valid = /^(7|8)?\d{10}$/g.test(value.replace(/[()+\-]|\s+/g, ''));
            return valid;
        }, "Телефон должен состоять из 10 цифр");

        var requiredMessage = 'Заполните поле';
        var maxlengthMessage = 'Длина не должна превышать 255 символов';
        var nameMessages = {
            required: requiredMessage,
            maxlength: maxlengthMessage
        };

        form.validate({
            rules: {
                'UserName': {
                    required: true,
                    maxlength: 255
                },
                'Phone': {
                    required: true,
                    phone: true
                },
                'Liame': {
                    email: true,
                    maxlength: 255
                },
                'Text': {
                    maxlength: 4000
                }
            },
            messages: {
                'UserName': nameMessages,
                'Phone': {
                    required: requiredMessage
                },
                'Liame': {
                    required: requiredMessage,
                    email: 'Некорректный электронный адрес',
                    maxlength: maxlengthMessage

                },
                'Text': {
                    maxlength: 'Длина не должна превышать 4000 символов'
                }
            },
            errorClass: 'field-validation-error',
            errorElement: 'span',
            highlight: highlightElement,
            unhighlight: unhighlightElement,
            onkeyup: false,
            onclick: false
        });

        function highlightElement(element) {
            $(element).addClass("input-validation-error");
        };

        function unhighlightElement(element) {
            $(element).removeClass("input-validation-error");
        };
    }
    if (window.location.hash === '#callback') {
        link.click();
    }
};
Kontur.Module('Kontur.OnlineConsultant.Initializer', function ($) {
    var me = this,
        options,
        consultant;

    var defaultOptions = {
        showStatus: false
    }

    me.initialize = function (params) {
        if (!params.widgetLocation) {
            console.error('Онлайн консультант: не задан параметр widgetLocation');
            return;
        }
        if (!params.widgetApi) {
            console.error('Онлайн консультант: не задан параметр widgetApi');
            return;
        }
        if (!params.topic) {
            console.error('Онлайн консультант: не задан параметр topic');
            return;
        }

        consultant = new Consultant(params);

        options = $.extend({}, defaultOptions, params);

        bindEvents();
    };

    function bindEvents() {
        if (true === options.showStatus) {
            $(window).on('OnlineConsultantCount', onOnlineConsultantCount);
        }

        $('.js-onlineConsultant-link').on('click', $.proxy(onOnlineConsultantClick, this));
    }

    function onOnlineConsultantCount (e, count) {
        $('.js-onlineConsultant-link').addClass(
            count > 0
            ? 'link-consultant_online'
            : 'link-consultant_offline');

        var onlineStatusBlock = $('.js-onlineConsultant-online'),
            offlineStatusBlock = $('.js-onlineConsultant-offline');

        if (onlineStatusBlock && offlineStatusBlock) {
            offlineStatusBlock.hide();
            onlineStatusBlock.show();
        }
    }

    function onOnlineConsultantClick (e) {
        e.preventDefault();
        consultant.showWindow();
    }

}, [jQuery]);
var UrlParameterAppenderControl = Class.extend({
    __options: {},

    init: function (options) {
        if (!$.isArray(options.parameters)) {
            var parameter = options.parameters;
            options.parameters = [];
            options.parameters.push(parameter);
        }
        this.__options = options;
        this.update($(document));
    },

    update: function (context) {
        var i, url,
            clearUrl,
            me = this,
            options = this.__options;

        if (options.urls) {
            for (i = 0; i < options.urls.length; i++) {
                url = options.urls[i];
                if (url) {
                    clearUrl = this.__clearUrlFromParams(url, options.parameters);
                    context.find('a[href^="' + clearUrl + '"]').each(function () {
                        me.__processAnchor($(this), options.parameters, options.isBlank);
                    });
                }
            }
        }

        if (options.anchors) {
            for (i = 0; i < options.anchors.length; i++) {
                var anchor = options.anchors[i];
                me.__processAnchor($(anchor), options.parameters, options.isBlank);
            }
        }
    },

    __processAnchor: function (anchor, parameters, isblank) {
        var href = $.trim(anchor.attr('href')), clearHref;

        if (href.indexOf('/') == 0) {
            return;
        }

        if (isblank) {
            anchor.attr('target', '_blank');
        }

        clearHref = this.__clearUrlFromParams(href, parameters);
        var newUrl = this.__addParamsToUrl(clearHref, parameters);

        var anchorText = anchor[0].innerHTML;
        anchor[0].href = newUrl;
        //note: http://bugs.jquery.com/ticket/8805
        if (anchor[0].innerHTML !== anchorText) {
            anchor[0].innerHTML = anchorText;
        }

        if (this.__options.onProcessItemCallback) {
            this.__options.onProcessItemCallback(anchor);
        }
    },

    __clearUrlFromParams: function (href, parameters) {
        return this.__processUrlIgnoringHash(href, function (url) {
            var clearUrl = url, i, parameterName;

            for (i in parameters) {
                for (parameterName in parameters[i]) {
                    //вырезаем переданные параметры из URL'a
                    clearUrl = clearUrl.replace(new RegExp("(\\?.*)" + parameterName + "=[^&=]*&?", 'i'), "$1");
                    clearUrl = clearUrl.replace(new RegExp(/[&?]$/), '');
                }
            }
            return clearUrl;
        });
    },

    __addParamsToUrl: function (url, parameters) {
        return this.__processUrlIgnoringHash(url, function (href) {
            var newUrl = href, parameterName, keyname, i;
            for (i in parameters) {
                for (keyname in parameters[i]) {
                    parameterName = keyname;
                    break;
                }

                var parameterValue = parameters[i][parameterName];
                var parameterNameAndValue = parameterName + '=' + parameterValue;

                if (!parameterValue) {
                    continue;
                }

                var matcher = new RegExp(parameterName + '=([^&$]*)', 'i');
                if (!newUrl.match(matcher)) {
                    newUrl += (newUrl.indexOf('?') >= 0 ? '&' : '?') + parameterNameAndValue;
                } else {
                    newUrl = newUrl.replace(new RegExp('([?|&]' + parameterName + '=)[^\&]+'), '$1' + parameterValue);
                }
            }

            return newUrl;
        });
    },

    __processUrlIgnoringHash: function (url, processFunc) {
        var hash = '',
            hashIndex = url.indexOf('#');

        if (hashIndex !== -1) {
            hash = url.substring(hashIndex);
            url = url.substring(0, hashIndex);
        }

        return processFunc(url) + hash;
    }
});
;
Kontur.Module('Kontur.Form.ParametersAppender', function ($) {
    
    this.initialize = function (options) {
        var i, url;

        if (!$.isArray(options.parameters)) {
            var parameter = options.parameters;
            options.parameters = [parameter];
        }

        for (i = 0; i < options.urls.length; i++) {
            url = options.urls[i];
            if (!url) continue;
            addParamsToFormByUrl(url, options.parameters);
        }
    };
    
    function addParamsToFormByUrl (url, params) {
        $('form[action^="' + url + '"]').each(function () {
            var form = $(this),
                input, paramName, paramValue, i, param;
            for (i = 0; i < params.length; i++) {
                param = params[i];
                for (paramName in param) {
                    paramValue = param[paramName];
                    input = generateInput(paramName, paramValue);
                    form.append(input);
                }
            }
        });
    };
    
    function generateInput(paramName, paramValue) {
        return $('<input>').attr({
            'name': paramName,
            'value': paramValue,
            'type': 'hidden'
        });
    };
},[jQuery]);
(function(window, Kontur, $) {
    Kontur.Module('Kontur.LightBox', function () { });

    Kontur.LightBox.showVideoOnLoad = function () {
        var hash = document.location.hash,
            hasVideoCode = hash.indexOf('videoid') != -1,
            videoCode = hasVideoCode ? hash.split('-')[1] : '';

        if ($('[data-videoid=' + videoCode + ']').length) {
            $(window).trigger('openVideoLightbox', [videoCode]);
        }
        
    };
}(window, Kontur, jQuery));
Kontur.Module("Kontur.Menu.Collapse", function () {
    var self = this,
        menuTop,
        menuBtn,
        collapedElem,
        body,
        pageWrapper,
        menuItems,
        input;


    function animateIn() {
        body.css({ overflow: 'hidden', marginBottom: '0' });
        pageWrapper.css({ height: $(window).height() + 'px'});
        //menuItems
        //    .stop().delay(0).animate({ marginTop: 90, opacity: 1 }, { duration: 300, easing: "easeInOutQuart" });
        //input
        //    .stop().delay(0).animate({ top: 0 }, { duration: 100, easing: "easeInOutQuart" });
        //collapedElem.show()
        //    .stop().delay(0).animate({ top: 100, opacity: 1, height: $(window).height() + 'px' }, { duration: 100, easing: "easeInOutQuart" });
        menuItems.css({ marginTop: 90, opacity: 1 });
        input.css({ top: 0 });
        collapedElem.css({ height: $(window).height() - 90 + 'px' }).stop().fadeIn(200);
    }

    function animateOut() {
        //menuItems.each(function (i) {
        //    var mSeconds = 200 + (i * 50);
        //    $(this).stop().delay(mSeconds).animate({ marginTop: 0, opacity: 1 }, { duration: 300, easing: "easeOutQuad" });
        //});
        //input
        //    .stop().delay(200).animate({ top: -90 }, { duration: 300, easing: "easeOutQuad" });
        //collapedElem
        //    .stop().delay(200).animate({ top: 0, opacity: 0 }, {duration: 100, easing: "easeOutQuad", complete: function () {
        //            $(this).hide();
        //            body.removeAttr('style');
        //            pageWrapper.removeAttr('style');
        //        }
        //    });
        menuItems.css({ marginTop: 0, opacity: 1 });
        input.css({ top: -90 });
        body.removeAttr('style');
        pageWrapper.removeAttr('style');
        collapedElem.stop().fadeOut(200);
    }

    function toggleHiddenMenu() {
        menuBtn.toggleClass('active');
        menuTop.toggleClass('active');
        collapedElem.toggleClass('active');

        if (collapedElem.hasClass('active')) {
            animateIn();
        } else {
            animateOut();
        }
    }

    function bindEvents() {
        menuBtn.click(function() {
            toggleHiddenMenu();
        });

        $('a[href*=#]', collapedElem).click(function () {
            if ("onhashchange" in window) {
                toggleHiddenMenu();
            }
        });
    }

    self.init = function () {
        menuTop = $('[data-toggle-menu="menu-dropdown"]');
        menuBtn = $('[data-toggle=menu-dropdown]'),
        collapedElem = $('[data-target=menu-dropdown]'),
        body = $('body'),
        pageWrapper = $('#pageWrapper'),
        menuItems = $('[data-toggle-menu-menu-item]'),
        input = $('[data-toggle-menu-search]');

        bindEvents();
    }

}, [jQuery]);
/* =========================================================
 * bootstrap-datepicker.js 
 * http://www.eyecon.ro/bootstrap-datepicker
 * =========================================================
 * Copyright 2012 Stefan Petre
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */

!function ($) {

    // Picker object

    var Datepicker = function (element, options) {
        this.element = $(element);
        this.format = DPGlobal.parseFormat(options.format || this.element.data('date-format') || 'mm/dd/yyyy');
        this.picker = $(DPGlobal.template)
                            .appendTo('body')
                            .on({
                                click: $.proxy(this.click, this)//,
                                //mousedown: $.proxy(this.mousedown, this)
                            });
        this.isInput = this.element.is('input');
        this.component = this.element.is('.date') ? this.element.find('.add-on') : false;

        if (this.isInput) {
            this.element.on({
                focus: $.proxy(this.show, this),
                //blur: $.proxy(this.hide, this),
                keyup: $.proxy(this.update, this)
            });
        } else {
            if (this.component) {
                this.component.on('click', $.proxy(this.show, this));
            } else {
                this.element.on('click', $.proxy(this.show, this));
            }
        }

        this.minViewMode = options.minViewMode || this.element.data('date-minviewmode') || 0;
        if (typeof this.minViewMode === 'string') {
            switch (this.minViewMode) {
                case 'months':
                    this.minViewMode = 1;
                    break;
                case 'years':
                    this.minViewMode = 2;
                    break;
                default:
                    this.minViewMode = 0;
                    break;
            }
        }
        this.viewMode = options.viewMode || this.element.data('date-viewmode') || 0;
        if (typeof this.viewMode === 'string') {
            switch (this.viewMode) {
                case 'months':
                    this.viewMode = 1;
                    break;
                case 'years':
                    this.viewMode = 2;
                    break;
                default:
                    this.viewMode = 0;
                    break;
            }
        }
        this.startViewMode = this.viewMode;
        this.weekStart = options.weekStart || this.element.data('date-weekstart') || 0;
        this.weekEnd = this.weekStart === 0 ? 6 : this.weekStart - 1;
        this.onRender = options.onRender;
        this.fillDow();
        this.fillMonths();
        this.update();
        this.showMode();
    };

    Datepicker.prototype = {
        constructor: Datepicker,

        show: function (e) {
            this.picker.show().addClass('open');
            this.height = this.component ? this.component.outerHeight() : this.element.outerHeight();
            this.place();
            $(window).on('resize', $.proxy(this.place, this));
            if (e) {
                e.stopPropagation();
                e.preventDefault();
            }
            if (!this.isInput) {
            }
            var that = this;
            $(document).on('mousedown', function (ev) {
                if ($(ev.target).closest('.datepicker').length == 0) {
                    that.hide();
                }
            });
            this.element.trigger({
                type: 'show',
                date: this.date
            });
        },

        hide: function () {
            this.picker.hide().removeClass('open');
            $(window).off('resize', this.place);
            this.viewMode = this.startViewMode;
            this.showMode();
            if (!this.isInput) {
                $(document).off('mousedown', this.hide);
            }
            //this.set();
            this.element.trigger({
                type: 'hide',
                date: this.date
            });
        },

        set: function () {
            var formated = DPGlobal.formatDate(this.date, this.format);
            if (!this.isInput) {
                if (this.component) {
                    this.element.find('input').prop('value', formated);
                }
                this.element.data('date', formated);
            } else {
                this.element.prop('value', formated);
            }
        },

        setValue: function (newDate) {
            if (typeof newDate === 'string') {
                this.date = DPGlobal.parseDate(newDate, this.format);
            } else {
                this.date = new Date(newDate);
            }
            this.set();
            this.viewDate = new Date(this.date.getFullYear(), this.date.getMonth(), 1, 0, 0, 0, 0);
            this.fill();
        },

        place: function () {
            var offset = this.component ? this.component.offset() : this.element.offset();
            this.picker.css({
                top: offset.top + this.height,
                left: offset.left
            });
        },

        update: function (newDate) {
            this.date = DPGlobal.parseDate(
                typeof newDate === 'string' ? newDate : (this.isInput ? this.element.prop('value') : this.element.data('date')),
                this.format
            );
            this.viewDate = new Date(this.date.getFullYear(), this.date.getMonth(), 1, 0, 0, 0, 0);
            this.fill();
        },

        fillDow: function () {
            var dowCnt = this.weekStart;
            var html = '<tr>';
            while (dowCnt < this.weekStart + 7) {
                html += '<th class="dow">' + DPGlobal.dates.daysMin[(dowCnt++) % 7] + '</th>';
            }
            html += '</tr>';
            this.picker.find('.datepicker-days thead').append(html);
        },

        fillMonths: function () {
            var html = '';
            var i = 0
            while (i < 12) {
                html += '<span class="month">' + DPGlobal.dates.monthsShort[i++] + '</span>';
            }
            this.picker.find('.datepicker-months td').append(html);
        },

        fill: function () {
            var d = new Date(this.viewDate),
                year = d.getFullYear(),
                month = d.getMonth(),
                currentDate = this.date.valueOf();
            this.picker.find('.datepicker-days th:eq(1)')
                        .text(DPGlobal.dates.months[month] + ' ' + year);
            var prevMonth = new Date(year, month - 1, 28, 0, 0, 0, 0),
                day = DPGlobal.getDaysInMonth(prevMonth.getFullYear(), prevMonth.getMonth());
            prevMonth.setDate(day);
            prevMonth.setDate(day - (prevMonth.getDay() - this.weekStart + 7) % 7);
            var nextMonth = new Date(prevMonth);
            nextMonth.setDate(nextMonth.getDate() + 42);
            nextMonth = nextMonth.valueOf();
            var html = [];
            var clsName,
                prevY,
                prevM;
            while (prevMonth.valueOf() < nextMonth) {
                if (prevMonth.getDay() === this.weekStart) {
                    html.push('<tr>');
                }
                clsName = this.onRender(prevMonth);
                prevY = prevMonth.getFullYear();
                prevM = prevMonth.getMonth();
                if ((prevM < month && prevY === year) || prevY < year) {
                    clsName += ' old';
                } else if ((prevM > month && prevY === year) || prevY > year) {
                    clsName += ' new';
                }
                if (prevMonth.valueOf() === currentDate) {
                    clsName += ' active';
                }
                html.push('<td class="day ' + clsName + '">' + prevMonth.getDate() + '</td>');
                if (prevMonth.getDay() === this.weekEnd) {
                    html.push('</tr>');
                }
                prevMonth.setDate(prevMonth.getDate() + 1);
            }
            this.picker.find('.datepicker-days tbody').empty().append(html.join(''));
            var currentYear = this.date.getFullYear();

            var months = this.picker.find('.datepicker-months')
                        .find('th:eq(1)')
                            .text(year)
                            .end()
                        .find('span').removeClass('active');
            if (currentYear === year) {
                months.eq(this.date.getMonth()).addClass('active');
            }

            html = '';
            year = parseInt(year / 10, 10) * 10;
            var yearCont = this.picker.find('.datepicker-years')
                                .find('th:eq(1)')
                                    .text(year + '-' + (year + 9))
                                    .end()
                                .find('td');
            year -= 1;
            for (var i = -1; i < 11; i++) {
                html += '<span class="year' + (i === -1 || i === 10 ? ' old' : '') + (currentYear === year ? ' active' : '') + '">' + year + '</span>';
                year += 1;
            }
            yearCont.html(html);
        },

        click: function (e) {
            e.stopPropagation();
            e.preventDefault();
            var target = $(e.target).closest('span, td, th');
            if (target.length === 1) {
                switch (target[0].nodeName.toLowerCase()) {
                    case 'th':
                        switch (target[0].className) {
                            case 'switch':
                                this.showMode(1);
                                break;
                            case 'prev':
                            case 'next':
                                this.viewDate['set' + DPGlobal.modes[this.viewMode].navFnc].call(
                                    this.viewDate,
                                    this.viewDate['get' + DPGlobal.modes[this.viewMode].navFnc].call(this.viewDate) +
                                    DPGlobal.modes[this.viewMode].navStep * (target[0].className === 'prev' ? -1 : 1)
                                );
                                this.fill();
                                this.set();
                                break;
                        }
                        break;
                    case 'span':
                        if (target.is('.month')) {
                            var month = target.parent().find('span').index(target);
                            this.viewDate.setMonth(month);
                        } else {
                            var year = parseInt(target.text(), 10) || 0;
                            this.viewDate.setFullYear(year);
                        }
                        if (this.viewMode !== 0) {
                            this.date = new Date(this.viewDate);
                            this.element.trigger({
                                type: 'changeDate',
                                date: this.date,
                                viewMode: DPGlobal.modes[this.viewMode].clsName
                            });
                        }
                        this.showMode(-1);
                        this.fill();
                        this.set();
                        break;
                    case 'td':
                        if (target.is('.day') && !target.is('.disabled')) {
                            var day = parseInt(target.text(), 10) || 1;
                            var month = this.viewDate.getMonth();
                            if (target.is('.old')) {
                                month -= 1;
                            } else if (target.is('.new')) {
                                month += 1;
                            }
                            var year = this.viewDate.getFullYear();
                            this.date = new Date(year, month, day, 0, 0, 0, 0);
                            this.viewDate = new Date(year, month, Math.min(28, day), 0, 0, 0, 0);
                            this.fill();
                            this.set();
                            this.element.trigger({
                                type: 'changeDate',
                                date: this.date,
                                viewMode: DPGlobal.modes[this.viewMode].clsName
                            });
                        }
                        break;
                }
            }
        },

        mousedown: function (e) {
            e.stopPropagation();
            e.preventDefault();
        },

        showMode: function (dir) {
            if (dir) {
                this.viewMode = Math.max(this.minViewMode, Math.min(2, this.viewMode + dir));
            }
            this.picker.find('>div').hide().filter('.datepicker-' + DPGlobal.modes[this.viewMode].clsName).show();
        }
    };

    $.fn.datepicker = function (option, val) {
        return this.each(function () {
            var $this = $(this),
                data = $this.data('datepicker'),
                options = typeof option === 'object' && option;
            if (!data) {
                $this.data('datepicker', (data = new Datepicker(this, $.extend({}, $.fn.datepicker.defaults, options))));
            }
            if (typeof option === 'string') data[option](val);
        });
    };

    $.fn.datepicker.defaults = {
        onRender: function (date) {
            return '';
        }
    };
    $.fn.datepicker.Constructor = Datepicker;

    var DPGlobal = {
        modes: [
            {
                clsName: 'days',
                navFnc: 'Month',
                navStep: 1
            },
            {
                clsName: 'months',
                navFnc: 'FullYear',
                navStep: 1
            },
            {
                clsName: 'years',
                navFnc: 'FullYear',
                navStep: 10
            }],
        dates: {
            days: ["Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота", "Воскресенье"],
            daysShort: ["Вск", "Пнд", "Втр", "Срд", "Чтв", "Птн", "Суб", "Вск"],
            daysMin: ["Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс"],
            months: ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"],
            monthsShort: ["Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек"],
            today: "Сегодня",
            weekStart: 1
        },
        isLeapYear: function (year) {
            return (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0))
        },
        getDaysInMonth: function (year, month) {
            return [31, (DPGlobal.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month]
        },
        parseFormat: function (format) {
            var separator = format.match(/[.\/\-\s].*?/),
                parts = format.split(/\W+/);
            if (!separator || !parts || parts.length === 0) {
                throw new Error("Invalid date format.");
            }
            return { separator: separator, parts: parts };
        },
        parseDate: function (date, format) {
            var parts = date.split(format.separator),
                date = new Date(),
                val;
            date.setHours(0);
            date.setMinutes(0);
            date.setSeconds(0);
            date.setMilliseconds(0);
            if (parts.length === format.parts.length) {
                var year = date.getFullYear(), day = date.getDate(), month = date.getMonth();
                for (var i = 0, cnt = format.parts.length; i < cnt; i++) {
                    val = parseInt(parts[i], 10) || 1;
                    switch (format.parts[i]) {
                        case 'dd':
                        case 'd':
                            day = val;
                            date.setDate(val);
                            break;
                        case 'mm':
                        case 'm':
                            month = val - 1;
                            date.setMonth(val - 1);
                            break;
                        case 'yy':
                            year = 2000 + val;
                            date.setFullYear(2000 + val);
                            break;
                        case 'yyyy':
                            year = val;
                            date.setFullYear(val);
                            break;
                    }
                }
                date = new Date(year, month, day, 0, 0, 0);
            }
            return date;
        },
        formatDate: function (date, format) {
            var val = {
                d: date.getDate(),
                m: date.getMonth() + 1,
                yy: date.getFullYear().toString().substring(2),
                yyyy: date.getFullYear()
            };
            val.dd = (val.d < 10 ? '0' : '') + val.d;
            val.mm = (val.m < 10 ? '0' : '') + val.m;
            var date = [];
            for (var i = 0, cnt = format.parts.length; i < cnt; i++) {
                date.push(val[format.parts[i]]);
            }
            return date.join(format.separator);
        },
        headTemplate: '<thead>' +
                            '<tr>' +
                                '<th class="prev">&lsaquo;</th>' +
                                '<th colspan="5" class="switch"></th>' +
                                '<th class="next">&rsaquo;</th>' +
                            '</tr>' +
                        '</thead>',
        contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>'
    };
    DPGlobal.template = '<div class="datepicker dropdown-drop">' +
                            '<div class="datepicker-days">' +
                                '<table class=" table-condensed">' +
                                    DPGlobal.headTemplate +
                                    '<tbody></tbody>' +
                                '</table>' +
                            '</div>' +
                            '<div class="datepicker-months">' +
                                '<table class="table-condensed">' +
                                    DPGlobal.headTemplate +
                                    DPGlobal.contTemplate +
                                '</table>' +
                            '</div>' +
                            '<div class="datepicker-years">' +
                                '<table class="table-condensed">' +
                                    DPGlobal.headTemplate +
                                    DPGlobal.contTemplate +
                                '</table>' +
                            '</div>' +
                        '</div>';

}(window.jQuery);

/*
    Masked Input plugin for jQuery
    Copyright (c) 2007-2011 Josh Bush (digitalbush.com)
    Licensed under the MIT license (http://digitalbush.com/projects/masked-input-plugin/#license) 
    Version: 1.3
*/
(function($) {
    var pasteEventName = ($.browser.msie ? 'paste' : 'input') + ".mask";
    var iPhone = (window.orientation != undefined);

    $.mask = {
        //Predefined character definitions
        definitions: {
            '9': "[0-9]",
            'a': "[A-Za-z]",
            '*': "[A-Za-z0-9]"
        },
        dataName:"rawMaskFn"
    };

    $.fn.extend({
        //Helper Function for Caret positioning
        caret: function(begin, end) {
            if (this.length == 0) return;
            if (typeof begin == 'number') {
                end = (typeof end == 'number') ? end : begin;
                return this.each(function() {
                    if (this.setSelectionRange) {
                        this.setSelectionRange(begin, end);
                    } else if (this.createTextRange) {
                        var range = this.createTextRange();
                        range.collapse(true);
                        range.moveEnd('character', end);
                        range.moveStart('character', begin);
                        range.select();
                    }
                });
            } else {
                if (this[0].setSelectionRange) {
                    begin = this[0].selectionStart;
                    end = this[0].selectionEnd;
                } else if (document.selection && document.selection.createRange) {
                    var range = document.selection.createRange();
                    begin = 0 - range.duplicate().moveStart('character', -100000);
                    end = begin + range.text.length;
                }
                return { begin: begin, end: end };
            }
        },
        unmask: function() { return this.trigger("unmask"); },
        mask: function(mask, settings) {
            if (!mask && this.length > 0) {
                var input = $(this[0]);
                return input.data($.mask.dataName)();
            }
            settings = $.extend({
                placeholder: "_",
                completed: null
            }, settings);

            var defs = $.mask.definitions;
            var tests = [];
            var partialPosition = mask.length;
            var firstNonMaskPos = null;
            var len = mask.length;

            $.each(mask.split(""), function(i, c) {
                if (c == '?') {
                    len--;
                    partialPosition = i;
                } else if (defs[c]) {
                    tests.push(new RegExp(defs[c]));
                    if(firstNonMaskPos==null)
                        firstNonMaskPos =  tests.length - 1;
                } else {
                    tests.push(null);
                }
            });

            return this.trigger("unmask").each(function() {
                var input = $(this);
                var buffer = $.map(mask.split(""), function(c, i) { if (c != '?') return defs[c] ? settings.placeholder : c });
                var focusText = input.val();

                function seekNext(pos) {
                    while (++pos <= len && !tests[pos]);
                    return pos;
                };
                function seekPrev(pos) {
                    while (--pos >= 0 && !tests[pos]);
                    return pos;
                };

                function shiftL(begin,end) {
                    if(begin<0)
                       return;
                    for (var i = begin,j = seekNext(end); i < len; i++) {
                        if (tests[i]) {
                            if (j < len && tests[i].test(buffer[j])) {
                                buffer[i] = buffer[j];
                                buffer[j] = settings.placeholder;
                            } else
                                break;
                            j = seekNext(j);
                        }
                    }
                    writeBuffer();
                    input.caret(Math.max(firstNonMaskPos, begin));
                };

                function shiftR(pos) {
                    for (var i = pos, c = settings.placeholder; i < len; i++) {
                        if (tests[i]) {
                            var j = seekNext(i);
                            var t = buffer[i];
                            buffer[i] = c;
                            if (j < len && tests[j].test(t))
                                c = t;
                            else
                                break;
                        }
                    }
                };

                function keydownEvent(e) {
                    var k=e.which;

                    //backspace, delete, and escape get special treatment
                    if(k == 8 || k == 46 || (iPhone && k == 127)){
                        var pos = input.caret(),
                            begin = pos.begin,
                            end = pos.end;
                        
                        if(end-begin==0){
                            begin=k!=46?seekPrev(begin):(end=seekNext(begin-1));
                            end=k==46?seekNext(end):end;
                        }
                        clearBuffer(begin, end);
                        shiftL(begin,end-1);

                        return false;
                    } else if (k == 27) {//escape
                        input.val(focusText);
                        input.caret(0, checkVal());
                        return false;
                    }
                };

                function keypressEvent(e) {
                    var k = e.which,
                        pos = input.caret();
                    if (e.ctrlKey || e.altKey || e.metaKey || k<32) {//Ignore
                        return true;
                    } else if (k) {
                        if(pos.end-pos.begin!=0){
                            clearBuffer(pos.begin, pos.end);
                            shiftL(pos.begin, pos.end-1);
                        }

                        var p = seekNext(pos.begin - 1);
                        if (p < len) {
                            var c = String.fromCharCode(k);
                            if (tests[p].test(c)) {
                                shiftR(p);
                                buffer[p] = c;
                                writeBuffer();
                                var next = seekNext(p);
                                input.caret(next);
                                if (settings.completed && next >= len)
                                    settings.completed.call(input);
                            }
                        }
                        return false;
                    }
                };

                function clearBuffer(start, end) {
                    for (var i = start; i < end && i < len; i++) {
                        if (tests[i])
                            buffer[i] = settings.placeholder;
                    }
                };

                function writeBuffer() { return input.val(buffer.join('')).val(); };

                function checkVal(allow) {
                    //try to place characters where they belong
                    var test = input.val();
                    var lastMatch = -1;
                    for (var i = 0, pos = 0; i < len; i++) {
                        if (tests[i]) {
                            buffer[i] = settings.placeholder;
                            while (pos++ < test.length) {
                                var c = test.charAt(pos - 1);
                                if (tests[i].test(c)) {
                                    buffer[i] = c;
                                    lastMatch = i;
                                    break;
                                }
                            }
                            if (pos > test.length)
                                break;
                        } else if (buffer[i] == test.charAt(pos) && i!=partialPosition) {
                            pos++;
                            lastMatch = i;
                        }
                    }
                    if (!allow && lastMatch + 1 < partialPosition) {
                        input.val("");
                        clearBuffer(0, len);
                    } else if (allow || lastMatch + 1 >= partialPosition) {
                        writeBuffer();
                        if (!allow) input.val(input.val().substring(0, lastMatch + 1));
                    }
                    return (partialPosition ? i : firstNonMaskPos);
                };

                input.data($.mask.dataName,function(){
                    return $.map(buffer, function(c, i) {
                        return tests[i]&&c!=settings.placeholder ? c : null;
                    }).join('');
                })

                if (!input.attr("readonly"))
                    input
                    .one("unmask", function() {
                        input
                            .unbind(".mask")
                            .removeData($.mask.dataName);
                    })
                    .bind("focus.mask", function() {
                        focusText = input.val();
                        var pos = checkVal();
                        writeBuffer();
                        var moveCaret=function(){
                            if (pos == mask.length)
                                input.caret(0, pos);
                            else
                                input.caret(pos);
                        };
                        ($.browser.msie ? moveCaret:function(){setTimeout(moveCaret,0)})();
                    })
                    .bind("blur.mask", function() {
                        checkVal();
                        if (input.val() != focusText)
                            input.change();
                    })
                    .bind("keydown.mask", keydownEvent)
                    .bind("keypress.mask", keypressEvent)
                    .bind(pasteEventName, function() {
                        setTimeout(function() { input.caret(checkVal(true)); }, 0);
                    });

                checkVal(); //Perform initial check for existing values
            });
        }
    });
})(jQuery);
Kontur.Module('Kontur.isMobile', function () {
    var self = this;

    this.Android = function () { return navigator.userAgent.match(/Android/i); },
    this.BlackBerry = function () { return navigator.userAgent.match(/BlackBerry/i); },
    this.iOS = function () { return navigator.userAgent.match(/iPhone|iPad|iPod/i); },
    this.Opera = function () { return navigator.userAgent.match(/Opera Mini/i); },
    this.Windows = function () { return navigator.userAgent.match(/IEMobile/i); },
    this.any = function () { return (self.Android() || self.BlackBerry() || self.iOS() || self.Opera() || self.Windows()); }
    this.touchdevice = function () { return ("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch); }
});
Kontur.Module("Kontur.Menu.Flexmenu", function () {
    var self = this,
        defaultOptions = {
            flexMenuSelector: '[data-flex-menu]',
            flexMenuItemsSelector: '[data-flex-menu-item]',
            flexMenuExcludeElSelector: '[data-flex-menu-item-exclude]',
            flexMenuPopupSelector: 'data-flex-menu-popup',
            flexMenuLinkSelector: 'data-flex-menu-morelink',
            flexMenuDropdownSelector: 'data-flex-menu-dropdown',
            flexMenuPopupTemplate: '<ul class="dropdown-drop js-flexMenu-popup flexMenu-popup"></ul>',
            flexMenuLinkTemplate: '<a href="#" class="js-menu-2-item-link menu-2-item-link">Еще <span class="konturIconic konturIconic-arrow-chevron-down"></span></a>',
            flexMenuDropdownTemplate: '<li class="js-menu-2-item menu-2-item flexMenu-viewMore"></li>',
            breackpoint: 768
        },
        $flexMenu,
        $items,
        $excludeEl,
        $popup,
        $moreLink,
        $dropdown,
        breackpoint,
        popupSelector,
        linkSelector,
        dropdownSelector,
        $clone,
        resizeTimeout,
        firstTopPos,
        body,
        windowWidth;

    //проверялка перескакивания 
    function isMenuNeed(el) {
        var isNewLine = function(elem) {
                return Math.ceil(elem.offset().top) > firstTopPos;
            },
            isMenuFitChild = isNewLine(el) || isNewLine($dropdown),
            isMenuFitExtraChild = $excludeEl.length && isNewLine( $excludeEl.last() );
        return isMenuFitChild || isMenuFitExtraChild;
    }

    //делаем клон меню и вставляем в выпадашку
    function createPopup() {
        $dropdown.insertAfter($items.last());
        $moreLink.appendTo($dropdown);
        $clone.appendTo($popup);
        $popup.appendTo($dropdown);

        $dropdown.attr(dropdownSelector, 'yes');
        $moreLink.attr(linkSelector, 'yes');
        $popup.attr(popupSelector, 'yes');
    }

    function showMoreLink() {
        $dropdown.removeClass('hide');
    }

    function hideMoreLink() {
        $dropdown.addClass('hide');
    }

    function fitFlexMenu() {
        $flexMenu.removeClass('nowrap');
        showMoreLink();

        $items.show();
        if ($(window).width() < breackpoint) {
            return;
        } else {
            firstTopPos = Math.floor($items.first().offset().top);

            $items.show();
            $clone.hide();

            //бежим по списку в обратном порядке
            $($items.get().reverse()).each(function (index) {
                var $self = $(this);

                if (isMenuNeed($self)) {
                    $self.hide();
                    $($clone.get().reverse()).eq(index).show();
                } else if (index === 0) {
                    $items.show();
                    hideMoreLink();
                    return;
                }
            });
        }
        $flexMenu.addClass('nowrap');
    }

    function detectOutsideClick(e, elem) {
        return !elem.is(e.target) && elem.has(e.target).length === 0;
    }

    function closePopup(elemDropdown, elemPopup) {
        elemDropdown.removeClass('active');
        elemPopup.removeClass('active').removeClass('open');
    }

    function bindEvents(opt) {
        windowWidth = $(window).width();

        if (!$flexMenu.attr('data-flex-menu-init=true')) {
            $flexMenu.attr('data-flex-menu-init', 'true');
            createPopup();
            fitFlexMenu();
        }

        $(document).ready(function () {
            var $dropdownEl = $('[' + dropdownSelector + ']'),
                $popupEl = $('[' + popupSelector + ']');

            $('[' + linkSelector + ']').click(function (e) {
                var $self = $(this),
                    $dropdown = $self.closest($dropdownEl),
                    $popup = $self.siblings($popupEl);
                e.preventDefault();
                $dropdown.toggleClass('active');
                $popup.toggleClass('open');

                if ($popup.is(':visible')) {
                    //скрываем по клику вне попапчика
                    body.on("click.flexmenuevent", function (e) {
                        if (detectOutsideClick(e, $dropdown)) {
                            closePopup($dropdown, $popup);
                        }
                    });

                    $(window).on('scroll.flexmenuevent', function () {
                        closePopup($dropdown, $popup);
                    });
                } else {
                    body.off("click.flexmenuevent scroll.flexmenuevent");
                }
            });

        });

        $(window).load(function () {
            $(window).resize(function () {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(function () {
                    var currentWidth = $(window).width();
                    if (currentWidth !== windowWidth) {
                        fitFlexMenu();
                    }
                    windowWidth = currentWidth;
                }, 50);

            });
        });
    }

    self.init = function (options) {
        if (typeof $clone != 'undefined') {
            return;
        }

        options = $.extend({}, defaultOptions, options);

        $flexMenu = $(options.flexMenuSelector);
        $items = $(options.flexMenuItemsSelector);
        $excludeEl = $(options.flexMenuExcludeElSelector);
        $popup = $(options.flexMenuPopupTemplate);
        $moreLink = $(options.flexMenuLinkTemplate);
        $dropdown = $(options.flexMenuDropdownTemplate);
        breackpoint = $(options.breackpoint);

        popupSelector = options.flexMenuPopupSelector;
        linkSelector = options.flexMenuLinkSelector;
        dropdownSelector = options.flexMenuDropdownSelector;

        if (!$items.length) {
            return;
        }

        $clone = $items.clone(true);

        body = $("body");

        bindEvents(options);
    }

}, [jQuery]);
Kontur.Module("Kontur.TouchBlock", function ($, isMobile) {
    var self = this,
        defaultOptions = {
            touchMenuSelector: '[data-touch-block]',
            wrapperTemplate: '<div class="js-touch-block-wrapper touch-block-wrapper"></div>',
            prevBtnTemplate: '<span class="js-touch-block__btn touch-block__btn touch-block__btn_prev"></span>',
            nextBtnTemplate: '<span class="js-touch-block__btn touch-block__btn touch-block__btn_next"></span>',
            btnModifier: ''
        },
        $touchMenu,
        $wrapper,
        $prevBtn,
        $nextBtn,
        btnModifier,
        resizeTimeout,
        menuWidth,
        menuScrollWidth,
        scrollPos;


    function insertControls() {
        $prevBtn.addClass(btnModifier);
        $nextBtn.addClass(btnModifier);
        $touchMenu
            .wrap($wrapper)
            .before($prevBtn)
            .after($nextBtn);
    }

    function hasScroll(blockWidth, scrollWidth) {
        return blockWidth === scrollWidth;
    }

    function showPrevNextBtn(opt) {
        if (opt.prev === true) {
            $prevBtn.show();
        } else {
            $prevBtn.hide();
        }
        if (opt.next === true) {
            $nextBtn.show();
        } else {
            $nextBtn.hide();
        }
    }

    function checkScrollPos() {
        scrollPos = $touchMenu.scrollLeft();
        menuWidth = $touchMenu.outerWidth();
        menuScrollWidth = $touchMenu[0].scrollWidth;

        if (hasScroll(menuWidth, menuScrollWidth)) {
            //скролл не нужен
            $touchMenu.css({
                'overflow': 'initial',
                '-webkit-overflow-scrolling': 'initial',
                '-ms-overflow-style': 'auto',
                'min-width': 'initial'
            });
            showPrevNextBtn({ prev: false, next: false });    //оба btn скрыты
        } else {
            //скролл нужен
            $touchMenu.css({
                'overflow': (isMobile.touchdevice() ? 'auto' : 'hidden'),
                '-webkit-overflow-scrolling': 'touch',
                '-ms-overflow-style': '-ms-autohiding-scrollbar',
                'min-width': '100%'
            });
            //Note 5px - компенсация перекрытия overflow отрицательных марджинов
            if (scrollPos <= 5) {
                showPrevNextBtn({ prev: false, next: true });    //правый btn виден
            } else if (menuScrollWidth - (scrollPos + menuWidth) <= 5 ) {
                showPrevNextBtn({ prev: true, next: false });    //левый btn виден
            } else {
                showPrevNextBtn({ prev: true, next: true });    //оба btn видны
            }
        }
    }

    function checkScrollPosOnTimeout() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function () {
            checkScrollPos();
        }, 50);
    }

    function bindEvents() {
        if (!$touchMenu.length) {
            return;
        }
        
        $touchMenu.scrollLeft(0);
        insertControls();
        checkScrollPos();

        $(window).resize(function () {
            checkScrollPosOnTimeout();
        });

        $($touchMenu).scroll(function () {
            checkScrollPosOnTimeout();
        });

        $prevBtn.click(function () {
            $touchMenu.stop().animate({ scrollLeft: '-=150' }, '300', function () {
                checkScrollPos();
            });
        });

        $nextBtn.click(function () {
            $touchMenu.stop().animate({ scrollLeft: '+=150' }, '300', function () {
                checkScrollPos();
            });
        });
    }

    self.init = function (options) {
        options = $.extend({}, defaultOptions, options);
        $touchMenu = $(options.touchMenuSelector);
        $wrapper = $(options.wrapperTemplate);
        $prevBtn = $(options.prevBtnTemplate);
        $nextBtn = $(options.nextBtnTemplate);
        btnModifier = options.btnModifier;

        bindEvents();
    };

}, [jQuery, Kontur.isMobile]);
Kontur.Module("Kontur.TableResponsive", function ($) {
    var self = this,
        defaultOptions = {
            touchBlockSelector: '.table-responsive',
            wrapperTemplate: '<div class="js-touch-block-wrapper touch-block-wrapper"></div>',
            nextBtnTemplate: '<span class="js-touch-block__btn touch-block__btn touch-block__btn_next"></span>',
            btnModifier: '',
            btnModifierAnimation : ''
        },
        $touchBlock,
        $wrapper,
        nextBtnTemplate,
        $nextBtn,
        btnModifier,
        btnModifierAnimation,
        $win,
        blockWidth,
        blockScrollWidth,
        scrollPos;


    function insertControls(target) {
        var $tempNextBtn = $(nextBtnTemplate);
        $tempNextBtn.addClass(btnModifier);
        target
            .wrap($wrapper)
            .after($tempNextBtn);
    }

    function hasScroll(blockWidth, scrollWidth) {
        return blockWidth === scrollWidth;
    }

    function showNextBtn(opt) {
        if (opt.show === true) {
            opt.el.siblings($nextBtn).addClass(btnModifierAnimation).fadeIn();
        } else {
            opt.el.siblings($nextBtn).fadeOut(function() {
                if (opt.remove === true) {
                    $(this).remove();
                }
            });
        }
    }

    function checkScrollPos(target) {
        scrollPos = target.scrollLeft();
        blockWidth = target.outerWidth();
        blockScrollWidth = target[0].scrollWidth;

        if (hasScroll(blockWidth, blockScrollWidth)) {
            //скролл не нужен
            target.css({
                'overflow': 'initial',
                '-webkit-overflow-scrolling': 'initial',
                '-ms-overflow-style': 'auto',
                'min-width': 'initial'
            });
            showNextBtn({ el: target, show: false });    // btn скрыт
        } else {
            //скролл нужен
            //$nextBtn.addClass(btnModifier);
            target.css({
                'overflow': 'auto',
                '-webkit-overflow-scrolling': 'touch',
                '-ms-overflow-style': '-ms-autohiding-scrollbar',
                'min-width': '100%'
            });

            if (scrollPos <= 5) {
                showNextBtn({ el: target, show: true });    // btn виден
            } else if (blockScrollWidth - (scrollPos + blockWidth) <= 5) {
                showNextBtn({ el: target, show: false });    // btn скрыт
            } else {
                showNextBtn({ el: target, show: false }); // btn скрыт
            }
        }
    }
    
    function checkStickySupport(elem) {
        var prefixes = ['', '-webkit-', '-moz-', '-ms-', '-o-'],
            prefix;
        while (prefix = prefixes.pop()) {
            elem.css({ position: +prefix + 'sticky' });
            if (elem[0].style.position !== '') {
                return true;
            }
        }
        return false;
    }

    function checkSmallWindow() {
        return $win.width() <= 1024;
    }

    function getIframeWidth(el) {
        return el[0].hasAttribute('data-iframe-sidebar') ? '655px' : '960px';
    }

    function resizeIframe() {
        var $iframe = $('iframe', $touchBlock);
        if ($iframe.length) {
            $iframe.attr({ width: checkSmallWindow ? getIframeWidth($iframe) : '100%' });
        }
    }

    function fixArrow(elem) {
        var winScrollPos,
            topPos = elem.css('top') || 0,
            offsetLeftPos = elem.offset().left,
            parentLeftPos = elem.position().left,
            elemSize = elem.outerHeight(),
            $parent = elem.parent(),
            parentPos = $parent.offset().top,
            parentSize = $parent.outerHeight();

        if (checkStickySupport(elem)) {
            elem.css({ top: topPos });
            return;
        }

        $win.on('scroll resize', function () {
            parentSize = parentSize === $parent.outerHeight() ? parentSize : $parent.outerHeight();
            winScrollPos = $win.scrollTop();

            if (winScrollPos >= parentPos
                && (parentSize + parentPos - elemSize) >= (winScrollPos + elemSize * 3)) {
                elem.css({
                    position: 'fixed',
                    top: topPos,
                    left: offsetLeftPos
                });
            } else if (winScrollPos < parentPos) {
                elem.css({
                    position: 'absolute',
                    top: topPos,
                    left: parentLeftPos
                });
            } else {
                elem.css({
                    position: 'absolute',
                    top: parentSize - elemSize * 2,
                    left: parentLeftPos
                });
            }
        });
    }

    function bindEvents() {
        if (!$touchBlock.length) {
            return;
        }

        $touchBlock.each(function () {
            var target = $(this);

            target.scrollLeft(0);
            insertControls(target);
            checkScrollPos(target);
            fixArrow(target.siblings($nextBtn));
        });
        
        $touchBlock.scroll(function () {
            var target = $(this);
            //checkScrollPosOnTimeout();
            showNextBtn({ el: target, show: false, remove: true });
        });

        if ($('iframe', $touchBlock).length) {
            var $iframe = $('iframe', $touchBlock),
                target = $iframe.closest($touchBlock);
            $iframe.load(function () {
                resizeIframe();
                if (checkSmallWindow) {
                    checkScrollPos(target);
                }
            });
        }
        $($touchBlock).siblings($nextBtn).click(function () {
            var self = $(this),
                target = self.siblings($touchBlock);

            console.log(1, self, target)

            showNextBtn({ el: target, show: false, remove: true });
            target.stop().animate({ scrollLeft: target[0].scrollWidth }, '300', function () {
                checkScrollPos(target);
            });
        });
    }

    self.init = function (options) {
        options = $.extend({}, defaultOptions, options);

        $touchBlock = $(options.touchBlockSelector);
        $wrapper = $(options.wrapperTemplate);
        nextBtnTemplate = options.nextBtnTemplate;
        $nextBtn = $(nextBtnTemplate);
        btnModifier = options.btnModifier;
        btnModifierAnimation = options.btnModifierAnimation;

        $win = $(window);

        bindEvents();
    };

}, [jQuery]);
Kontur.Module("Kontur.Menu.MobileBuyButton", function ($) {
    var self = this,
        breackpoint,
        isMobilePage;

    function changeBuyButtonText(fromShortToLong) {
        $('.separate-menu-btn').find('[data-buy-product-button]').each(function () {
            var $this = $(this);
            $this.empty();
            var newText = fromShortToLong
                ? $this.attr('data-long-text')
                : $this.attr('data-short-text');
            $this.text(newText);
        });
    }
    
    function bindEvents() {
        if ($(window).width() < breackpoint && isMobilePage) {
            changeBuyButtonText(false);
        }

        $(window).resize(function () {
            if ($(window).width() < breackpoint && isMobilePage) {
                changeBuyButtonText(false);
            } else {
                changeBuyButtonText(true);
            }
        });
    }

    self.init = function () {
        breackpoint = 768;
        isMobilePage = $('html').hasClass("mobile-friendly");
        bindEvents();
    };

}, [jQuery]);
//NOTE: был кастомизирован под наши нужды. Аккуратнее при обновлении!

/*
//////////////////////////////
// cssToggle - a jQuery plugin for toggling elements via CSS
// by Marius Hauken, Netlife Research
// https://github.com/mhauken/cssToggle
//////////////////////////////
*/

(function ($) { // Protecting the $ Alias and Adding Scope
    $.fn.cssToggle = function (option) {
        var options = typeof option == 'object' && option, close;
        if (!options && option === 'close') {
            close = true;
        }
        /*
          [1] The default settings.
          [2] These are by default to get a nice slideToggle solution.
        */


        var settings = $.extend({ //[1]
            duration: "300",
            easing: "ease",
            position: {
                ignore: false,
                showing: "static", //[2]
                hiding: "absolute"
            },
            display: "block",
            showComplete: function () { },
            hideComplete: function () { }
        }, options);


        return this.each(function (event) {


            /*
            [1] For reaching $(this) inside functions.
            [2] To convert ms to s for the animation-speed.
            [3] A variable we apply to the transition-css.
            [4] Store which element that triggered the slideToggle
            */

            var $this = $(this); //[1]
            var s = settings.duration / 1000; //[2]
            var transition = "opacity " + s + "s " + settings.easing; //[3]
            var clicked = event.target; //[4]

            /*
            [1] Pass after position:absolute.
            [2] When done fading call the remove function.
            */
            function visible() { //[1]
                $this.css("opacity", "1");
                setTimeout(remove, settings.duration); //[2]
            }

            /*
            [1] Remove all the attributes we've added. Force display: block.
            [2] Callback so we can apply functions when showing is complete.
            [3] Remove all the attributes we've added. Force display: none.
            [4] Callback so we can apply functions when hiding is complete.
            [5] Apply css-animations on target.
            [6] Make it possible to trigger the toggle again by removing the disabled class from the trigger
            */
            function remove() { //[1]
                $this.removeAttr('style').css('display', settings.display);
                settings.showComplete();//[2]
                $(clicked).removeClass('Disabled');//[6]
            }

            function hide() { //[3]
                $this.removeAttr('style').css('display', 'none');
                settings.hideComplete();//[4]
                $(clicked).removeClass('Disabled');//[6]
            }

            $this.css({   //[5]
                "-webkit-transition": transition,
                "-moz-transition": transition,
                "-ms-transition": transition,
                "-o-transition": transition,
                "transition": transition,
                "z-index": "1000"
            });

            //[1] Check if the disabled class is applied to the clicked object. If it is do nothing
            //[2] If disabled isn't applied we run the cssToggle

            if ($(clicked).hasClass('Disabled')) {//[1]
            } else {//[2]

                /*
                [1] If target is display: none do this.
                [2] Cancel element that triggered cssToggle by giving it a disabled-class
                [3] If position is ignore we don't change the position
                [4] Set opacity to 0.
                [5] Set display according to options.
                [6] Set the position according to options.
                [7] A little delay before we fade in the opacity via the visible-function.
                */

                if ($(this).css('display') === 'none' && !close) { //[1]
                    $(clicked).addClass('Disabled');//[2]
                    if (settings.position.ignore === true) {//[3]
                        $this.css({
                            "opacity": "0", //[4]
                            "display": settings.display  //[5]
                        });
                    } else {
                        $this.css({
                            "position": settings.position.showing, //[6]
                            "opacity": "0", //[4]
                            "display": settings.display  //[5]
                        });
                    }
                    setTimeout(visible, 1);  //[7]


                    /*
                    [1] If target is displayed do this.
                    [2] Cancel element that triggered cssToggle by giving it a disabled-class
                    [3] If position is set to ignore don't change the position-css
                    [4] Set opacity to 0.
                    [5] Run this if ignore position is false
                    [6] Get the width of the element (needed if we're setting the element to absolute).
                    [7] Apply the width of the element so it doesn't rescale if absolute.
                    [8] Set the postioning of the element.
                    [9] Set opacity to 0.
                    [10] Hide element from DOM when finished by calling the hide-function.
                    [11] Making our plugin method chainable takes this line of code.
                    [12] End of return this each.
                    */

                } else { //[1]
                    $(clicked).addClass('Disabled');
                    if (settings.position.ignore === true) {//[3]
                        $this.css({
                            "opacity": "0" //[4]
                        });
                    } else {//[5]
                        var size = $this.outerWidth(); //[6]
                        $this.css({
                            "width": size + "px", //[7]
                            "position": settings.position.hiding,//[8]
                            "opacity": "0" //[9]
                        });
                    }
                    setTimeout(hide, settings.duration); //[10]

                }
            }

            return this; //[11]
        }); //[12]
    };

}(jQuery));
Kontur.Module("Kontur.Mobile", function ($, isMobile) {
    var self = this,
        collapseLinkSelector,
        collapseLink,
        collapsedEl,
        breackpoint,
        isMobilePage,
        html,
        isCollapseOnMobileBinded;

    //CollapseArrows
    function bindCollapseOnMobile() {
        if (isCollapseOnMobileBinded) {
            return;
        }
        isCollapseOnMobileBinded = true;
        
        function detectOutsideClick(e, elem) {
            return !elem.is(e.target) && elem.has(e.target).length === 0;
        }

        function toggleContent(opt) {
            var defaultOptions = {
                    el: $(this),
                    siblingsTarget: false,
                    close: false
                },
                options = $.extend({}, defaultOptions, opt),
                el = options.el,
                targetSelector = '[data-collapse-target="' + el.data("collapse-arrow") + '"]',
                targetEl = options.siblingsTarget ? el.siblings(targetSelector) : $(targetSelector);

            if (el.hasClass("animated")) {
                return;
            }

            function close() {
                targetEl.cssToggle({
                    easing: "ease-in-out",
                    showComplete: function() {
                        el.removeClass("active animated");
                    },
                    hideComplete: function() {
                        el.removeClass("active animated");
                    }
                });
            }

            el.toggleClass("active animated");

            if (options.siblingsTarget) {
                if (el.hasClass("active")) {
                    if (options.close) {
                        //close();
                        el.removeClass("active animated");
                        return;
                    }
                    $('body').on("click.closeMenuInFixed", function(e) {
                        if (detectOutsideClick(e, targetEl) && detectOutsideClick(e, el)) {
                            close();
                            return;
                        }
                    });
                } else {
                    $('body').off("click.closeMenuInFixed");
                }
                targetEl.cssToggle({
                    easing: "ease-in-out",
                    position: {
                        showing: 'absolute'
                    },
                    showComplete: function () {
                        el.removeClass("animated");
                    },
                    hideComplete: function () {
                        el.removeClass("animated");
                    }
                });
                return;
            }

            targetEl.cssToggle({
                easing: "ease-in-out",
                position: {
                    showing: 'static',
                    hiding: 'relative'
                },
                showComplete: function() {
                    el.removeClass("animated");
                },
                hideComplete: function() {
                    el.removeClass("animated");
                }
            });
        }

        collapsedEl.hide().removeClass("hidden-xs");

        collapseLink.on('click', function () {
            toggleContent({
                 el: $(this)
            });
        });

        $('[data-menu-fixed]').on('click', collapseLinkSelector, function () {
            toggleContent({
                el: $(this),
                siblingsTarget: true
            });
        });

        $(window).on('scroll.closeMenuInFixed', function () {
            toggleContent({
                el: $('[data-menu-fixed]').find(collapseLinkSelector),
                siblingsTarget: true,
                close: true
            });
        });

    }

    function unBindCollapseOnMobile() {
        isCollapseOnMobileBinded = false;

        collapsedEl.show();
        collapseLink.unbind("click").removeClass("active");
    }

    //createPhoneLink
    function createPhoneLink() {
        //<a href="tel:#######"> on mobile
        if (isMobile.any()) {
            $("[data-tel]").each(function () {
                var elem = $(this),
                    tel = elem.data("tel").replace("&bsp;", ""),
                    color = elem.css("color"),
                    iOsAutoGeneratedLink = elem.find("a[href^=tel]");
                if (iOsAutoGeneratedLink.length) {
                    //note iphone сам генерит кликабельные ссылки
                    //это можно отменить через <meta name="format-detection" content="telephone=no">
                    iOsAutoGeneratedLink.css({ color: color });
                    return;
                }
                elem.wrap("<a href='tel:" + tel + "' style='color: " + color + " !important;'></a>");
            });
        }
    }

    //createPhoneLink
    function iOsSimulatorMouseScroll() {
        //если это айфон и хост web-sites
        if (isMobile.iOS() && /web-site/i.test(document.location.hostname)) {
            var $scrllUpBtn = $("<span class='scrllBtn scrllUpBtn' data-direction='-=200'>^</span>"),
                $scrllDownBtn = $("<span class='scrllBtn scrllDownBtn' data-direction='+=200'>v</span>"),
                $body = $('body'),
                speed = 400,
                timer,
                self,
                btns;

            $body.append($scrllUpBtn).append($scrllDownBtn);
            btns = $('.scrllBtn');

            btns.css({
                position: 'fixed',
                zIndex: '9999',
                right: '0px',
                width: '15px',
                height: '30px',
                lineHeight: '30px',
                background: 'rgba(0,0,0,.7)',
                color: '#ffffff',
                textAlign: 'center',
                '-webkit-touch-callout': 'none',
                '-webkit-user-select': 'none',
                '-webkit-tap-highlight-color': 'rgba(0,0,0,0)'
            });
            $scrllUpBtn.css({ bottom: '50px' });
            $scrllDownBtn.css({ bottom: '10px' });

            function pageScroll(el) {
                $('html, body').animate({ scrollTop: el.data('direction') }, speed, 'linear');
            }

            btns.on('click touchstart', function () {
                self = $(this);
                pageScroll(self);
                timer = setInterval(function () {
                    pageScroll(self);
                }, speed);
            }).on('touchend', function () {
                clearTimeout(timer);
            });

        }
    }

    function bindEvents() {
        //Note нужно для нормальной навигации внутри iOs симулятора, ибо эмулировать тач мышкой - АД!
        //iOsSimulatorMouseScroll();

        //convert tel 2 link on mobile
        createPhoneLink();

        if ($(window).width() < breackpoint && isMobilePage) {
            bindCollapseOnMobile();
        }

        $(window).resize(function () {
            if ($(window).width() < breackpoint && isMobilePage) {
                bindCollapseOnMobile();
            } else {
                unBindCollapseOnMobile();
            }
        });
        $(window).load(function () {
            if ($(window).width() < breackpoint && isMobilePage) {
                if ($.fn.cycle) {
                    $('.cycle-slideshow').cycle('destroy');
                }
            }
        });

        if (Kontur.TableResponsive) {
            Kontur.TableResponsive.init({
                touchBlockSelector: '.table-responsive',
                btnModifier: 'touch-block__btn_table',
                btnModifierAnimation: 'wow bounceInRight'
            });
        }

    }

    self.init = function () {
        breackpoint = 768;
        html = $("html");

        collapseLinkSelector = "[data-collapse-arrow]";
        collapseLink = $(collapseLinkSelector);
        collapsedEl = $("[data-collapse-target]");

        isMobilePage = html.hasClass("mobile-friendly");

        bindEvents();
    };

}, [jQuery, Kontur.isMobile, Kontur.TableResponsive]);
Kontur.Module("Kontur.Menu.Burger", function () {
    var self = this,
        burgerBtn,
        burgerOveray,
        burgerMenu,
        pageWrapper,
        html;

    function burgerMenuToggle() {
        var isActive = burgerBtn.hasClass("active");
        if (!isActive) {
            html.addClass("menu-burger__html-overlay");
            burgerOveray.addClass("active_visible");
            if (pageWrapper.length) {
                pageWrapper.scrollTop(0);
            }
        }
        burgerOveray.toggleClass("active");
        burgerOveray.on('webkitTransitionEnd otransitionend oTransitionEnd msTransitionEnd transitionend', function (e) {
            if (isActive) {
                html.removeClass("menu-burger__html-overlay");
                burgerOveray.removeClass("active_visible");
            }
            $(this).off('webkitTransitionEnd otransitionend oTransitionEnd msTransitionEnd transitionend');
        });
        burgerMenu.toggleClass("active");
        burgerBtn.toggleClass("active");
    }

    function bindEvents() {
        burgerBtn.click(function () {
            burgerMenuToggle();
        });
        burgerOveray.click(function (e) {
            if (!$(e.target).closest(burgerMenu).length && !$(e.target).is(burgerMenu)) {
                burgerMenuToggle();
            }
        });
    }

    self.init = function () {
        burgerBtn = $("[data-burgermenu-burger]");
        burgerOveray = $("[data-burgermenu-overlay]");
        burgerMenu = $("[data-burgermenu-menu]");
        pageWrapper = $('#pageWrapper');
        html = $("html");

        bindEvents();
    }

}, [jQuery]);
// Do not edit. Was generated by build.ps1. Edit .src.js files then run build.ps1.
var KonturRu = KonturRu || {};

KonturRu.Cookie = (function () {
    var me = {};

    me.get = function (name) {
        var matches = document.cookie.match(new RegExp(
            "(?:^|; )" + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + "=([^;]*)"
        ));
        return matches ? decodeURIComponent(matches[1]) : undefined;
    }

    me.set = function (name, value, expires, path, domain, secure) {
        document.cookie =
            name + "=" + escape(value) +
            ((expires) ? "; expires=" + expires.toGMTString() : "") +
            ((path) ? "; path=" + path : "") +
            ((domain) ? "; domain=" + domain : "") +
            ((secure) ? "; secure" : "");
    }

    return me;
})();
var KonturRu = KonturRu || {};

KonturRu.RequestSender = (function () {
    var me = {};

    me.doGetRequest = function (url) {
        var img = new Image(1, 1);
        img.src = url;
    }

    return me;
})();
var KonturRu = KonturRu || {};

KonturRu.GaEventSender = (function (cookie, requestSender) {
    var me = {};
    var gaClientIdCookieName = '_ga';

    me.registerEvent = function (category, action, url, host, path) {
        var clientId = getGaClientId();
        var randomInt = getRandomInt();
        var eventUrl = getEventUrl(clientId, category, action, url, host, path, randomInt);

        requestSender.doGetRequest(eventUrl);
    }

    function getGaClientId() {
        var gaClientIdCookie = cookie.get(gaClientIdCookieName);
        //GA1.2.1585930166.1444374039 -> 1585930166.1444374039
        return gaClientIdCookie.replace(/^\w+\.\w+\./, '');
    }

    function getEventUrl(clientId, category, action, url, host, path, randomInt) {

        var eventUrlBuilder = [
            'https://www.google-analytics.com/collect?v=1&tid=UA-1690345-1',
            'cid=' + clientId,
            't=event',
            'ec=' + category,
            'ea=' + action
        ];

        if (url) {
            eventUrlBuilder.push('dl=' + encodeURIComponent(url));
        } else if (host || path) {
            eventUrlBuilder.push('dh=' + encodeURIComponent(host));
            eventUrlBuilder.push('dp=' + encodeURIComponent(path));
        }

        eventUrlBuilder.push('z=' + randomInt);

        return eventUrlBuilder.join('&');
    }

    function getRandomInt() {
        return Math.floor(Math.random() * (999999999));
    }

    return me;
})(KonturRu.Cookie, KonturRu.RequestSender);

var KonturRu = KonturRu || {};

KonturRu.Counter = (function (gaEventSender, cookie) {
    var me = {},
        cookieDomain = '.kontur.ru',
        cookiePath = '/',
        cookiePrefix = 'kontur.ru-go-product-',
        cookieValue = '1',
        cookieExpiresInDay = 1;

    me.RegisterProductConversion = function (productName) {
        var cookieName = getProductCookieName(productName);
        var cookieExpires = getCookieExpires();
        cookie.set(cookieName, cookieValue, cookieExpires, cookiePath, cookieDomain);
    }

    me.ProductRegistrationEvent = function (productName) {
        var productCookieName = getProductCookieName(productName);
        if (cookie.get(productCookieName) == cookieValue) {
            registerProductRegistrationEvent(productName);
        }
    }

    me.SetDomain = function (_cookieDomain) {
        cookieDomain = _cookieDomain;
    }

    function registerProductRegistrationEvent(productName) {
        gaEventSender.registerEvent(productName, 'register-inside', null, 'kontur.ru', '/' + productName);
    }

    function getProductCookieName(productName) {
        return cookiePrefix + productName;
    }

    function getCookieExpires() {
        var date = new Date;
        return new Date(date.setDate(date.getDate() + cookieExpiresInDay));
    }

    return me;
})(KonturRu.GaEventSender, KonturRu.Cookie);
Kontur.Module('Kontur.Product.Cnversion.Counter', function($, global, counter) {
    $(function () {
        var window = global.get();
        $(window.document).on('click', '[data-product-conversion]', function () {
            var productName = $(this).data('product-conversion');
            counter.RegisterProductConversion(productName);
        });
    });
}, [jQuery, Kontur.Global, KonturRu.Counter]);
/**
 * 
 * Magnific Popup Core JS file
 * 
 */


/**
 * Private static constants
 */
var CLOSE_EVENT = 'Close',
    BEFORE_CLOSE_EVENT = 'BeforeClose',
    AFTER_CLOSE_EVENT = 'AfterClose',
    BEFORE_APPEND_EVENT = 'BeforeAppend',
    MARKUP_PARSE_EVENT = 'MarkupParse',
    OPEN_EVENT = 'Open',
    CHANGE_EVENT = 'Change',
    NS = 'mfp',
    EVENT_NS = '.' + NS,
    READY_CLASS = 'mfp-ready',
    REMOVING_CLASS = 'mfp-removing',
    PREVENT_CLOSE_CLASS = 'mfp-prevent-close';


/**
 * Private vars 
 */
/*jshint -W079 */
var mfp, // As we have only one instance of MagnificPopup object, we define it locally to not to use 'this'
    MagnificPopup = function () { },
    _isJQ = !!(window.jQuery),
    _prevStatus,
    _window = $(window),
    _document,
    _prevContentType,
    _wrapClasses,
    _currPopupType;


/**
 * Private functions
 */
var _mfpOn = function (name, f) {
    mfp.ev.on(NS + name + EVENT_NS, f);
},
    _getEl = function (className, appendTo, html, raw) {
        var el = document.createElement('div');
        el.className = 'mfp-' + className;
        if (html) {
            el.innerHTML = html;
        }
        if (!raw) {
            el = $(el);
            if (appendTo) {
                el.appendTo(appendTo);
            }
        } else if (appendTo) {
            appendTo.appendChild(el);
        }
        return el;
    },
    _mfpTrigger = function (e, data) {
        mfp.ev.triggerHandler(NS + e, data);

        if (mfp.st.callbacks) {
            // converts "mfpEventName" to "eventName" callback and triggers it if it's present
            e = e.charAt(0).toLowerCase() + e.slice(1);
            if (mfp.st.callbacks[e]) {
                mfp.st.callbacks[e].apply(mfp, $.isArray(data) ? data : [data]);
            }
        }
    },
    _getCloseBtn = function (type) {
        if (type !== _currPopupType || !mfp.currTemplate.closeBtn) {
            mfp.currTemplate.closeBtn = $(mfp.st.closeMarkup.replace('%title%', mfp.st.tClose));
            _currPopupType = type;
        }
        return mfp.currTemplate.closeBtn;
    },
    // Initialize Magnific Popup only when called at least once
    _checkInstance = function () {
        if (!$.magnificPopup.instance) {
            /*jshint -W020 */
            mfp = new MagnificPopup();
            mfp.init();
            $.magnificPopup.instance = mfp;
        }
    },
    // CSS transition detection, http://stackoverflow.com/questions/7264899/detect-css-transitions-using-javascript-and-without-modernizr
    supportsTransitions = function () {
        var s = document.createElement('p').style, // 's' for style. better to create an element if body yet to exist
            v = ['ms', 'O', 'Moz', 'Webkit']; // 'v' for vendor

        if (s['transition'] !== undefined) {
            return true;
        }

        while (v.length) {
            if (v.pop() + 'Transition' in s) {
                return true;
            }
        }

        return false;
    };


/**
 * Public functions
 */
MagnificPopup.prototype = {
    constructor: MagnificPopup,

    /**
     * Initializes Magnific Popup plugin. 
     * This function is triggered only once when $.fn.magnificPopup or $.magnificPopup is executed
     */
    init: function () {
        var appVersion = navigator.appVersion;
        mfp.isIE7 = appVersion.indexOf("MSIE 7.") !== -1;
        mfp.isIE8 = appVersion.indexOf("MSIE 8.") !== -1;
        mfp.isLowIE = mfp.isIE7 || mfp.isIE8;
        mfp.isAndroid = (/android/gi).test(appVersion);
        mfp.isIOS = (/iphone|ipad|ipod/gi).test(appVersion);
        mfp.supportsTransition = supportsTransitions();

        // We disable fixed positioned lightbox on devices that don't handle it nicely.
        // If you know a better way of detecting this - let me know.
        mfp.probablyMobile = (mfp.isAndroid || mfp.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent));
        _document = $(document);

        mfp.popupsCache = {};
    },

    /**
     * Opens popup
     * @param  data [description]
     */
    open: function (data) {

        var i;

        if (data.isObj === false) {
            // convert jQuery collection to array to avoid conflicts later
            mfp.items = data.items.toArray();

            mfp.index = 0;
            var items = data.items,
                item;
            for (i = 0; i < items.length; i++) {
                item = items[i];
                if (item.parsed) {
                    item = item.el[0];
                }
                if (item === data.el[0]) {
                    mfp.index = i;
                    break;
                }
            }
        } else {
            mfp.items = $.isArray(data.items) ? data.items : [data.items];
            mfp.index = data.index || 0;
        }

        // if popup is already opened - we just update the content
        if (mfp.isOpen) {
            mfp.updateItemHTML();
            return;
        }

        mfp.types = [];
        _wrapClasses = '';
        if (data.mainEl && data.mainEl.length) {
            mfp.ev = data.mainEl.eq(0);
        } else {
            mfp.ev = _document;
        }

        if (data.key) {
            if (!mfp.popupsCache[data.key]) {
                mfp.popupsCache[data.key] = {};
            }
            mfp.currTemplate = mfp.popupsCache[data.key];
        } else {
            mfp.currTemplate = {};
        }


        mfp.st = $.extend(true, {}, $.magnificPopup.defaults, data);
        mfp.fixedContentPos = mfp.st.fixedContentPos === 'auto' ? !mfp.probablyMobile : mfp.st.fixedContentPos;

        if (mfp.st.modal) {
            mfp.st.closeOnContentClick = false;
            mfp.st.closeOnBgClick = false;
            mfp.st.showCloseBtn = false;
            mfp.st.enableEscapeKey = false;
        }


        // Building markup
        // main containers are created only once
        if (!mfp.bgOverlay) {

            // Dark overlay
            mfp.bgOverlay = _getEl('bg').on('click' + EVENT_NS, function () {
                mfp.close();
            });

            mfp.wrap = _getEl('wrap').attr('tabindex', -1).on('click' + EVENT_NS, function (e) {
                if (mfp._checkIfClose(e.target)) {
                    mfp.close();
                }
            });

            mfp.container = _getEl('container', mfp.wrap);
        }

        mfp.contentContainer = _getEl('content');
        if (mfp.st.preloader) {
            mfp.preloader = _getEl('preloader', mfp.container, mfp.st.tLoading);
        }


        // Initializing modules
        var modules = $.magnificPopup.modules;
        for (i = 0; i < modules.length; i++) {
            var n = modules[i];
            n = n.charAt(0).toUpperCase() + n.slice(1);
            mfp['init' + n].call(mfp);
        }
        _mfpTrigger('BeforeOpen');


        if (mfp.st.showCloseBtn) {
            // Close button
            if (!mfp.st.closeBtnInside) {
                mfp.wrap.append(_getCloseBtn());
            } else {
                _mfpOn(MARKUP_PARSE_EVENT, function (e, template, values, item) {
                    values.close_replaceWith = _getCloseBtn(item.type);
                });
                _wrapClasses += ' mfp-close-btn-in';
            }
        }

        if (mfp.st.alignTop) {
            _wrapClasses += ' mfp-align-top';
        }


        if (mfp.fixedContentPos) {
            mfp.wrap.css({
                overflow: mfp.st.overflowY,
                overflowX: 'hidden',
                overflowY: mfp.st.overflowY
            });
        } else {
            mfp.wrap.css({
                top: _window.scrollTop(),
                position: 'absolute'
            });
        }
        if (mfp.st.fixedBgPos === false || (mfp.st.fixedBgPos === 'auto' && !mfp.fixedContentPos)) {
            mfp.bgOverlay.css({
                height: _document.height(),
                position: 'absolute'
            });
        }


        if (mfp.st.enableEscapeKey) {
            // Close on ESC key
            _document.on('keyup' + EVENT_NS, function (e) {
                if (e.keyCode === 27) {
                    mfp.close();
                }
            });
        }

        _window.on('resize' + EVENT_NS, function () {
            mfp.updateSize();
        });


        if (!mfp.st.closeOnContentClick) {
            _wrapClasses += ' mfp-auto-cursor';
        }

        if (_wrapClasses)
            mfp.wrap.addClass(_wrapClasses);


        // this triggers recalculation of layout, so we get it once to not to trigger twice
        var windowHeight = mfp.wH = _window.height();


        var windowStyles = {};

        if (mfp.fixedContentPos) {
            if (mfp._hasScrollBar(windowHeight)) {
                var s = mfp._getScrollbarSize();
                if (s) {
                    windowStyles.marginRight = s;
                }
            }
        }

        if (mfp.fixedContentPos) {
            if (!mfp.isIE7) {
                windowStyles.overflow = 'hidden';
            } else {
                // ie7 double-scroll bug
                $('body, html').css('overflow', 'hidden');
            }
        }


        var classesToadd = mfp.st.mainClass;
        if (mfp.isIE7) {
            classesToadd += ' mfp-ie7';
        }
        if (classesToadd) {
            mfp._addClassToMFP(classesToadd);
        }

        // add content
        mfp.updateItemHTML();

        _mfpTrigger('BuildControls');

        // remove scrollbar, add margin e.t.c
        $('html').css(windowStyles);

        // add everything to DOM
        mfp.bgOverlay.add(mfp.wrap).prependTo(mfp.st.prependTo || $(document.body));

        // Save last focused element
        mfp._lastFocusedEl = document.activeElement;

        // Wait for next cycle to allow CSS transition
        setTimeout(function () {

            if (mfp.content) {
                mfp._addClassToMFP(READY_CLASS);
                mfp._setFocus();
            } else {
                // if content is not defined (not loaded e.t.c) we add class only for BG
                mfp.bgOverlay.addClass(READY_CLASS);
            }

            // Trap the focus in popup
            _document.on('focusin' + EVENT_NS, mfp._onFocusIn);

        }, 16);

        mfp.isOpen = true;
        mfp.updateSize(windowHeight);
        _mfpTrigger(OPEN_EVENT);

        return data;
    },

    /**
     * Closes the popup
     */
    close: function () {
        if (!mfp.isOpen) return;
        _mfpTrigger(BEFORE_CLOSE_EVENT);

        mfp.isOpen = false;
        // for CSS3 animation
        if (mfp.st.removalDelay && !mfp.isLowIE && mfp.supportsTransition) {
            mfp._addClassToMFP(REMOVING_CLASS);
            setTimeout(function () {
                mfp._close();
            }, mfp.st.removalDelay);
        } else {
            mfp._close();
        }
    },

    /**
     * Helper for close() function
     */
    _close: function () {
        _mfpTrigger(CLOSE_EVENT);

        var classesToRemove = REMOVING_CLASS + ' ' + READY_CLASS + ' ';

        mfp.bgOverlay.detach();
        mfp.wrap.detach();
        mfp.container.empty();

        if (mfp.st.mainClass) {
            classesToRemove += mfp.st.mainClass + ' ';
        }

        mfp._removeClassFromMFP(classesToRemove);

        if (mfp.fixedContentPos) {
            var windowStyles = { marginRight: '' };
            if (mfp.isIE7) {
                $('body, html').css('overflow', '');
            } else {
                windowStyles.overflow = '';
            }
            $('html').css(windowStyles);
        }

        _document.off('keyup' + EVENT_NS + ' focusin' + EVENT_NS);
        mfp.ev.off(EVENT_NS);

        // clean up DOM elements that aren't removed
        mfp.wrap.attr('class', 'mfp-wrap').removeAttr('style');
        mfp.bgOverlay.attr('class', 'mfp-bg');
        mfp.container.attr('class', 'mfp-container');

        // remove close button from target element
        if (mfp.st.showCloseBtn &&
        (!mfp.st.closeBtnInside || mfp.currTemplate[mfp.currItem.type] === true)) {
            if (mfp.currTemplate.closeBtn)
                mfp.currTemplate.closeBtn.detach();
        }


        if (mfp._lastFocusedEl) {
            $(mfp._lastFocusedEl).focus(); // put tab focus back
        }
        mfp.currItem = null;
        mfp.content = null;
        mfp.currTemplate = null;
        mfp.prevHeight = 0;

        _mfpTrigger(AFTER_CLOSE_EVENT);
    },

    updateSize: function (winHeight) {

        if (mfp.isIOS) {
            // fixes iOS nav bars https://github.com/dimsemenov/Magnific-Popup/issues/2
            var zoomLevel = document.documentElement.clientWidth / window.innerWidth;
            var height = window.innerHeight * zoomLevel;
            mfp.wrap.css('height', height);
            mfp.wH = height;
        } else {
            mfp.wH = winHeight || _window.height();
        }
        // Fixes #84: popup incorrectly positioned with position:relative on body
        if (!mfp.fixedContentPos) {
            mfp.wrap.css('height', mfp.wH);
        }

        _mfpTrigger('Resize');

    },

    /**
     * Set content of popup based on current index
     */
    updateItemHTML: function () {
        var item = mfp.items[mfp.index];

        // Detach and perform modifications
        mfp.contentContainer.detach();

        if (mfp.content)
            mfp.content.detach();

        if (!item.parsed) {
            item = mfp.parseEl(mfp.index);
        }

        var type = item.type;

        _mfpTrigger('BeforeChange', [mfp.currItem ? mfp.currItem.type : '', type]);
        // BeforeChange event works like so:
        // _mfpOn('BeforeChange', function(e, prevType, newType) { });

        mfp.currItem = item;


        if (!mfp.currTemplate[type]) {
            var markup = mfp.st[type] ? mfp.st[type].markup : false;

            // allows to modify markup
            _mfpTrigger('FirstMarkupParse', markup);

            if (markup) {
                mfp.currTemplate[type] = $(markup);
            } else {
                // if there is no markup found we just define that template is parsed
                mfp.currTemplate[type] = true;
            }
        }

        if (_prevContentType && _prevContentType !== item.type) {
            mfp.container.removeClass('mfp-' + _prevContentType + '-holder');
        }

        var newContent = mfp['get' + type.charAt(0).toUpperCase() + type.slice(1)](item, mfp.currTemplate[type]);
        mfp.appendContent(newContent, type);

        item.preloaded = true;

        _mfpTrigger(CHANGE_EVENT, item);
        _prevContentType = item.type;

        // Append container back after its content changed
        mfp.container.prepend(mfp.contentContainer);

        _mfpTrigger('AfterChange');
    },


    /**
     * Set HTML content of popup
     */
    appendContent: function (newContent, type) {
        mfp.content = newContent;

        if (newContent) {
            if (mfp.st.showCloseBtn && mfp.st.closeBtnInside &&
                mfp.currTemplate[type] === true) {
                // if there is no markup, we just append close button element inside
                if (!mfp.content.find('.mfp-close').length) {
                    mfp.content.append(_getCloseBtn());
                }
            } else {
                mfp.content = newContent;
            }
        } else {
            mfp.content = '';
        }

        _mfpTrigger(BEFORE_APPEND_EVENT);
        mfp.container.addClass('mfp-' + type + '-holder');

        mfp.contentContainer.append(mfp.content);
    },


    /**
         * Creates Magnific Popup data object based on given data
         * @param  {int} index Index of item to parse
         */
    parseEl: function (index) {
        var item = mfp.items[index],
            type;

        if (item.tagName) {
            item = { el: $(item) };
        } else {
            type = item.type;
            item = { data: item, src: item.src };
        }

        if (item.el) {
            var types = mfp.types;

            // check for 'mfp-TYPE' class
            for (var i = 0; i < types.length; i++) {
                if (item.el.hasClass('mfp-' + types[i])) {
                    type = types[i];
                    break;
                }
            }

            item.src = item.el.attr('data-mfp-src');
            if (!item.src) {
                item.src = item.el.attr('href');
            }
        }

        item.type = type || mfp.st.type || 'inline';
        item.index = index;
        item.parsed = true;
        mfp.items[index] = item;
        _mfpTrigger('ElementParse', item);

        return mfp.items[index];
    },


    /**
     * Initializes single popup or a group of popups
     */
    addGroup: function (el, options) {
        var eHandler = function (e) {
            e.mfpEl = this;
            mfp._openClick(e, el, options);
        };

        if (!options) {
            options = {};
        }

        var eName = 'click.magnificPopup';
        options.mainEl = el;

        if (options.items) {
            options.isObj = true;
            el.off(eName).on(eName, eHandler);
        } else {
            options.isObj = false;
            if (options.delegate) {
                el.off(eName).on(eName, options.delegate, eHandler);
            } else {
                options.items = el;
                el.off(eName).on(eName, eHandler);
            }
        }
    },
    _openClick: function (e, el, options) {
        var midClick = options.midClick !== undefined ? options.midClick : $.magnificPopup.defaults.midClick;


        if (!midClick && (e.which === 2 || e.ctrlKey || e.metaKey)) {
            return;
        }

        var disableOn = options.disableOn !== undefined ? options.disableOn : $.magnificPopup.defaults.disableOn;

        if (disableOn) {
            if ($.isFunction(disableOn)) {
                if (!disableOn.call(mfp)) {
                    return true;
                }
            } else { // else it's number
                if (_window.width() < disableOn) {
                    return true;
                }
            }
        }

        if (e.type) {
            e.preventDefault();

            // This will prevent popup from closing if element is inside and popup is already opened
            if (mfp.isOpen) {
                e.stopPropagation();
            }
        }


        options.el = $(e.mfpEl);
        if (options.delegate) {
            options.items = el.find(options.delegate);
        }
        mfp.open(options);
    },


    /**
     * Updates text on preloader
     */
    updateStatus: function (status, text) {

        if (mfp.preloader) {
            if (_prevStatus !== status) {
                mfp.container.removeClass('mfp-s-' + _prevStatus);
            }

            if (!text && status === 'loading') {
                text = mfp.st.tLoading;
            }

            var data = {
                status: status,
                text: text
            };
            // allows to modify status
            _mfpTrigger('UpdateStatus', data);

            status = data.status;
            text = data.text;

            mfp.preloader.html(text);

            mfp.preloader.find('a').on('click', function (e) {
                e.stopImmediatePropagation();
            });

            mfp.container.addClass('mfp-s-' + status);
            _prevStatus = status;
        }
    },


    /*
        "Private" helpers that aren't private at all
     */
    // Check to close popup or not
    // "target" is an element that was clicked
    _checkIfClose: function (target) {

        if ($(target).hasClass(PREVENT_CLOSE_CLASS)) {
            return;
        }

        var closeOnContent = mfp.st.closeOnContentClick;
        var closeOnBg = mfp.st.closeOnBgClick;

        if (closeOnContent && closeOnBg) {
            return true;
        } else {

            // We close the popup if click is on close button or on preloader. Or if there is no content.
            if (!mfp.content || $(target).hasClass('mfp-close') || (mfp.preloader && target === mfp.preloader[0])) {
                return true;
            }

            // if click is outside the content
            if ((target !== mfp.content[0] && !$.contains(mfp.content[0], target))) {
                if (closeOnBg) {
                    // last check, if the clicked element is in DOM, (in case it's removed onclick)
                    if ($.contains(document, target)) {
                        return true;
                    }
                }
            } else if (closeOnContent) {
                return true;
            }

        }
        return false;
    },
    _addClassToMFP: function (cName) {
        mfp.bgOverlay.addClass(cName);
        mfp.wrap.addClass(cName);
    },
    _removeClassFromMFP: function (cName) {
        this.bgOverlay.removeClass(cName);
        mfp.wrap.removeClass(cName);
    },
    _hasScrollBar: function (winHeight) {
        return ((mfp.isIE7 ? _document.height() : document.body.scrollHeight) > (winHeight || _window.height()));
    },
    _setFocus: function () {
        (mfp.st.focus ? mfp.content.find(mfp.st.focus).eq(0) : mfp.wrap).focus();
    },
    _onFocusIn: function (e) {
        if (e.target !== mfp.wrap[0] && !$.contains(mfp.wrap[0], e.target)) {
            mfp._setFocus();
            return false;
        }
    },
    _parseMarkup: function (template, values, item) {
        var arr;
        if (item.data) {
            values = $.extend(item.data, values);
        }
        _mfpTrigger(MARKUP_PARSE_EVENT, [template, values, item]);

        $.each(values, function (key, value) {
            if (value === undefined || value === false) {
                return true;
            }
            arr = key.split('_');
            if (arr.length > 1) {
                var el = template.find(EVENT_NS + '-' + arr[0]);

                if (el.length > 0) {
                    var attr = arr[1];
                    if (attr === 'replaceWith') {
                        if (el[0] !== value[0]) {
                            el.replaceWith(value);
                        }
                    } else if (attr === 'img') {
                        if (el.is('img')) {
                            el.attr('src', value);
                        } else {
                            el.replaceWith('<img src="' + value + '" class="' + el.attr('class') + '" />');
                        }
                    } else {
                        el.attr(arr[1], value);
                    }
                }

            } else {
                template.find(EVENT_NS + '-' + key).html(value);
            }
        });
    },

    _getScrollbarSize: function () {
        // thx David
        if (mfp.scrollbarSize === undefined) {
            var scrollDiv = document.createElement("div");
            scrollDiv.style.cssText = 'width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;';
            document.body.appendChild(scrollDiv);
            mfp.scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
            document.body.removeChild(scrollDiv);
        }
        return mfp.scrollbarSize;
    }

}; /* MagnificPopup core prototype end */


/**
 * Public static functions
 */
$.magnificPopup = {
    instance: null,
    proto: MagnificPopup.prototype,
    modules: [],

    open: function (options, index) {
        _checkInstance();

        if (!options) {
            options = {};
        } else {
            options = $.extend(true, {}, options);
        }


        options.isObj = true;
        options.index = index || 0;
        return this.instance.open(options);
    },

    close: function () {
        return $.magnificPopup.instance && $.magnificPopup.instance.close();
    },

    registerModule: function (name, module) {
        if (module.options) {
            $.magnificPopup.defaults[name] = module.options;
        }
        $.extend(this.proto, module.proto);
        this.modules.push(name);
    },

    defaults: {

        // Info about options is in docs:
        // http://dimsemenov.com/plugins/magnific-popup/documentation.html#options
        disableOn: 0,

        key: null,

        midClick: false,

        mainClass: '',

        preloader: true,

        focus: '', // CSS selector of input to focus after popup is opened

        closeOnContentClick: false,

        closeOnBgClick: true,

        closeBtnInside: true,

        showCloseBtn: true,

        enableEscapeKey: true,

        modal: false,

        alignTop: false,

        removalDelay: 0,

        prependTo: null,

        fixedContentPos: 'auto',

        fixedBgPos: 'auto',

        overflowY: 'auto',

        closeMarkup: '<button title="%title%" type="button" class="mfp-close">&times;</button>',

        tClose: 'Close (Esc)',

        tLoading: 'Loading...'

    }
};


//Quick benchmark
/*
var start = performance.now(),
    i,
    rounds = 1000;

for(i = 0; i < rounds; i++) {

}
console.log('Test #1:', performance.now() - start);

start = performance.now();
for(i = 0; i < rounds; i++) {

}
console.log('Test #2:', performance.now() - start);
*/

// https://github.com/oklai/koala - Koala is a GUI application for less, sass and coffeescript compilation

// @koala-prepend "src/core.js"
// @koala-append "src/image.js"
// @koala-append "src/gallery.js"
// @koala-append "src/iframe.js"
// @koala-append "src/fastclick.js"
// @koala-append "src/defaultoptions.js"
// @koala-append "src/kontur.gallery.module.js"

var _imgInterval,
   _getTitle = function (item) {
       //TITLE - <a title=""> || <a data-title="">
       if (!item.el) {
           return '';
       }
       if (item.el && item.el.context.title !== undefined && item.el.context.title.length > 1 ||
           item.el.data('title') !== undefined && item.el.data('title').length) {
           return item.el.context.title || item.el.data('title');
       }
       return '';
   },
   _getDesc = function (item) {
       //DESCRIPTION - <img alt=""> || <a data-desc=""> || <img title="">
       if (!item.el) {
           return '';
       }
       var childEl = item.el.find('img');
       if (childEl.attr('alt') !== undefined && childEl.attr('alt').length > 1) {
           return wrapTitle(childEl.attr('alt'));
       } else if (item.el.data('desc') !== undefined && item.el.data('desc').length > 1) {
           return wrapTitle(item.el.data('desc'));
       } else if (childEl.attr('title') !== undefined && childEl.attr('title').length > 1) {
           return wrapTitle(childEl.attr('title'));
       }
       function wrapTitle(title) {
           return '<div class="mfp-desc-inner">' + title + '</div>';
       }
       return '';
   },
   _getButtons = function (item) {
       //BUTTONS <a data-bottom-panel=".selector"></a> && <div class="none"><div class="selector">КНОПКИ</div></div>
       if (!item.el) {
           return '';
       }
       var childEl = item.el;
       if (childEl.attr('data-bottom-panel-html') !== undefined && childEl.attr('data-bottom-panel-html').length > 1) {
           return '<div class="mfp-desc-inner">' + childEl.attr('data-bottom-panel-html') + '</div>';
       } else if (childEl.attr('data-bottom-panel') !== undefined && childEl.attr('data-bottom-panel').length > 1 && $(childEl.attr('data-bottom-panel')).length) {
           var inner = $('<div class="mfp-desc-inner"></div>');
           return inner.append($(childEl.attr('data-bottom-panel')).clone(true, true));
       }
       return '';
   };

$.magnificPopup.registerModule('image', {
    options: {
        //ToDO Отказатьтся от figcaption
        markup: '<div class="mfp-figure-wrap">' +
                    '<div class="mfp-title" data-mfp-title></div>' +
                    '<figure class="mfp-figure" data-mfp-wrapper>' +
                        '<div class="mfp-img"></div>' +
                        '<div class="mfp-zoom" style="display: none"></div>' +
                        '<figcaption class="mfp-figcaption" data-mfp-bottom>' +
                            '<div class="mfp-bottom-bar">' +
                                '<div class="mfp-desc"></div>' +
                            '<div class="mfp-buttons"></div>' +
                            '</div>' +
                        '</figcaption>' +
                    '</figure>' +
                '</div>' +
                '<div class="mfp-counter"></div>',
        cursor: 'mfp-zoom-out-cur',
        verticalFit: true
    },

    proto: {
        initImage: function () {
            var imgSt = mfp.st.image,
                ns = '.image';

            mfp.types.push('image');

            _mfpOn(OPEN_EVENT + ns, function () {
                if (mfp.currItem.type === 'image') {
                    if (imgSt.cursor) {
                        $(document.body).addClass(imgSt.cursor);
                    }
                    mfp.container.addClass('mfp-s-ready-animate');
                }
            });

            _mfpOn(CLOSE_EVENT + ns, function () {
                if (imgSt.cursor) {
                    $(document.body).removeClass(imgSt.cursor);
                }
                _window.off('resize' + EVENT_NS);
            });

            _mfpOn('Resize' + ns, mfp.resizeImage);
            if (mfp.isLowIE) {
                _mfpOn('AfterChange', mfp.resizeImage);
            }
        },
        resizeImage: function () {
            var item = mfp.currItem;
            if (!item || !item.img) return;

            var isScreenType = $(item.el.context).is("[data-screen]");
            var itemWrapper = mfp.contentContainer.find('[data-mfp-wrapper]');

            if (mfp.st.image.verticalFit) {
                var decr = 70; //ToDo figcaption .height()
                // fix box-sizing in ie7/8

                if (mfp.isLowIE) {
                    decr = parseInt(item.img.css('padding-top'), 10) + parseInt(item.img.css('padding-bottom'), 10);
                }

                var itemTitle = mfp.contentContainer.find('[data-mfp-title]');
                var itemBottomBlock = mfp.contentContainer.find('[data-mfp-bottom]');
                var itemImgHeight = item.img.height();

                if (itemTitle.outerHeight() > 0) {
                    decr = decr + itemTitle.outerHeight(true);
                }

                if (itemBottomBlock.outerHeight() > 0) {
                    decr = decr + itemBottomBlock.outerHeight();
                }

                if (!isScreenType) {
                    item.img.css('max-height', mfp.wH - decr);
                    if (itemImgHeight != item.img.height()) {
                        mfp.resizeImage();
                    }
                }
            }
        },
        showZoomBtn: function (item) {
            /*ToDo - переделать, обобщить*/
            var zoomBtn = $('.mfp-zoom'),
                $img = item.img;

            var isScreenType = $(item.el.context).is("[data-screen]");

            /*ToDo ie8 support*/
            if (($img.prop('naturalHeight') > mfp.wH && !isScreenType) || $img.prop('naturalWidth') > $(window).width()) {
                zoomBtn.fadeIn();

                zoomBtn.unbind("click").click(function () {
                    mfp.wrap.toggleClass('mfp-force-scrollbars');

                    $(document).mousemove(function (e) {
                        mfp.scrollBigImg(e);
                    });
                    $img.one('click', function () {
                        mfp.wrap.toggleClass('mfp-force-scrollbars');
                        mfp.resizeImage();
                        return false;
                    });
                    _mfpOn(CLOSE_EVENT + '.' + IFRAME_NS, function () {
                        $(document).unbind('mousemove');
                    });

                    mfp.contentContainer.find('[data-mfp-wrapper]').css("width", item.img.width());

                    return false;
                });
            } else {
                zoomBtn.hide();

                if (mfp.wrap.hasClass('mfp-force-scrollbars')) {
                    mfp.wrap.removeClass('mfp-force-scrollbars');
                }
            }

        },
        scrollBigImg: function (e) {
            e = e || window.event;
            //ToDo сделать отступ вокруг, которай не будет участвовать в просчетах
            var windowW = $(window).width(),
                windowH = $(window).height(),
                containerW = mfp.content.outerWidth(true),
                containerH = mfp.content.outerHeight(true),
                leftPos = Math.round((containerW - windowW) / windowW * e.clientX),
                topPos = Math.round((containerH - windowH) / windowH * e.clientY);

            var isScroll = mfp.wrap.hasClass('mfp-force-scrollbars');

            //ToDo избавиться от animate
            if (containerW > windowW) {
                //mfp.wrap.scrollLeft = leftPos;
                mfp.wrap.animate({ scrollLeft: leftPos }, 0);
            }
            if (containerH > windowH && isScroll) {
                //mfp.wrap.scrollTop = topPos;;
                mfp.wrap.animate({ scrollTop: topPos }, 0);
            }

        },
        _onImageHasSize: function (item) {
            if (item.img) {

                item.hasSize = true;

                if (_imgInterval) {
                    clearInterval(_imgInterval);
                }

                item.isCheckingImgSize = false;

                _mfpTrigger('ImageHasSize', item);

                if (item.imgHidden) {
                    if (mfp.content) {
                        mfp.content.removeClass('mfp-loading');
                    }

                    item.imgHidden = false;
                }

            }
        },

        /**
         * Function that loops until the image has size to display elements that rely on it asap
         */
        findImageSize: function (item) {

            var counter = 0,
                img = item.img[0],
                mfpSetInterval = function (delay) {

                    if (_imgInterval) {
                        clearInterval(_imgInterval);
                    }
                    // decelerating interval that checks for size of an image
                    _imgInterval = setInterval(function () {
                        if (img.naturalWidth > 0) {
                            mfp._onImageHasSize(item);
                            return;
                        }

                        if (counter > 200) {
                            clearInterval(_imgInterval);
                        }

                        counter++;
                        if (counter === 3) {
                            mfpSetInterval(10);
                        } else if (counter === 40) {
                            mfpSetInterval(50);
                        } else if (counter === 100) {
                            mfpSetInterval(500);
                        }
                    }, delay);
                };

            mfpSetInterval(1);
        },

        getImage: function (item, template) {

            var guard = 0,

                // image load complete handler
                onLoadComplete = function () {
                    if (item) {
                        if (item.img[0].complete) {
                            item.img.off('.mfploader');

                            if (item === mfp.currItem) {
                                mfp._onImageHasSize(item);

                                mfp.updateStatus('ready');
                            }

                            item.hasSize = true;
                            item.loaded = true;

                            _mfpTrigger('ImageLoadComplete');

                            mfp.showZoomBtn(mfp.currItem);

                            mfp.contentContainer.find('[data-mfp-wrapper]').css("width", "auto");

                            mfp.resizeImage();
                        } else {
                            // if image complete check fails 200 times (20 sec), we assume that there was an error.
                            guard++;
                            if (guard < 200) {
                                setTimeout(onLoadComplete, 100);
                            } else {
                                onLoadError();
                            }
                        }
                    }
                },

                // image error handler
                onLoadError = function () {
                    if (item) {
                        item.img.off('.mfploader');
                        if (item === mfp.currItem) {
                            mfp._onImageHasSize(item);
                            mfp.updateStatus('error', imgSt.tError.replace('%url%', item.src));
                        }

                        item.hasSize = true;
                        item.loaded = true;
                        item.loadError = true;
                    }
                },
                imgSt = mfp.st.image;


            var el = template.find('.mfp-img');
            if (el.length) {
                var img = document.createElement('img');
                img.className = 'mfp-img';
                if (item.el && item.el.find('img').length) {
                    img.alt = item.el.find('img').attr('alt');
                }
                item.img = $(img).on('load.mfploader', onLoadComplete).on('error.mfploader', onLoadError);
                img.src = item.src;

                // without clone() "error" event is not firing when IMG is replaced by new IMG
                // TODO: find a way to avoid such cloning
                if (el.is('img')) {
                    item.img = item.img.clone();
                }

                img = item.img[0];
                if (img.naturalWidth > 0) {
                    item.hasSize = true;
                } else if (!img.width) {
                    item.hasSize = false;
                }
            }

            mfp._parseMarkup(template, {
                title: _getTitle(item),
                img_replaceWith: item.img,
                desc: _getDesc(item),
                buttons: _getButtons(item)
            }, item);

            mfp.resizeImage();

            if (item.hasSize) {
                if (_imgInterval) clearInterval(_imgInterval);

                if (item.loadError) {
                    template.addClass('mfp-loading');
                    mfp.updateStatus('error', imgSt.tError.replace('%url%', item.src));
                } else {
                    template.removeClass('mfp-loading');
                    mfp.updateStatus('ready');
                }
                return template;
            }

            mfp.updateStatus('loading');
            item.loading = true;

            if (!item.hasSize) {
                item.imgHidden = true;
                template.addClass('mfp-loading');
                mfp.findImageSize(item);
            }

            return template;
        }
    }
});

/**
* Get looped index depending on number of slides
*/
var _getLoopedId = function (index) {
    var numSlides = mfp.items.length;
    if (index > numSlides - 1) {
        return index - numSlides;
    } else if (index < 0) {
        return numSlides + index;
    }
    return index;
},
    _replaceCurrTotal = function (text, curr, total) {
        return text.replace(/%curr%/gi, curr + 1).replace(/%total%/gi, total);
    },
    _getSibligsNumber = function (currNumber, total) {
        if (currNumber > total) {
            return 1;
        } else if (currNumber < 1) {
            return total;
        }
        return currNumber;
    },
    _updateCurrTotal = function (curr, total) {
        var currNumber = curr + 1;
        $('.mfp-counter-btn').each(function () {
            if ($(this).parent().hasClass('mfp-arrow-left')) {
                $(this).text(_getSibligsNumber(currNumber - 1, total) + '/' + total);
            } else {
                $(this).text(_getSibligsNumber(currNumber + 1, total) + '/' + total);
            }
        });
    },
    _breakGalleryCyclical = function (curr, total, direction) {
        var currNumber = curr + 1,
            elem = $('.mfp-content');

        if (direction == true && currNumber == total && _getSibligsNumber(currNumber + 1, total) == 1) {
            addDirectionClass('last');
        } else if (direction == false && currNumber == 1 && _getSibligsNumber(currNumber - 1, total) == total) {
            addDirectionClass('first');
        } else {
            elem.removeClass('mfp-stop mfp-stop-last mfp-stop-first');
            return true;
        }
        function addDirectionClass(cssClass) {
            elem.addClass('mfp-stop mfp-stop-' + cssClass);
            setTimeout(function () {
                elem.removeClass('mfp-stop');
            }, 400);
            return false;
        }
    };

$.magnificPopup.registerModule('gallery', {
    options: {
        enabled: false,
        arrowMarkup: '<button title="%title%" type="button" class="mfp-arrow mfp-arrow-%dir%"><span class="mfp-counter-btn"></span></button>',
        preload: [0, 2],
        navigateByImgClick: true,
        arrows: true,
        tPrev: 'Previous (Left arrow key)',
        tNext: 'Next (Right arrow key)',
        tCounter: '%curr% / %total%'
    },

    proto: {
        initGallery: function () {

            var gSt = mfp.st.gallery,
                ns = '.mfp-gallery',
                supportsFastClick = Boolean($.fn.mfpFastClick);

            mfp.direction = true; // true - next, false - prev

            if (!gSt || !gSt.enabled) return false;

            _wrapClasses += ' mfp-gallery';

            _mfpOn(OPEN_EVENT + ns, function () {

                if (gSt.navigateByImgClick) {
                    mfp.wrap.on('click' + ns, '.mfp-img', function () {
                        if (mfp.items.length > 1) {
                            mfp.next();
                            return false;
                        }
                    });
                }

                _document.on('keydown' + ns, function (e) {
                    if (e.keyCode === 37) {
                        mfp.prev();
                    } else if (e.keyCode === 39) {
                        mfp.next();
                    }
                });

                _updateCurrTotal(mfp.currItem.index, mfp.items.length);

                mfp.container.addClass('mfp-s-ready-animate');
            });

            _mfpOn('UpdateStatus' + ns, function (e, data) {
                if (data.text) {
                    data.text = _replaceCurrTotal(data.text, mfp.currItem.index, mfp.items.length);
                }
                _updateCurrTotal(mfp.currItem.index, mfp.items.length);
            });

            _mfpOn(MARKUP_PARSE_EVENT + ns, function (e, element, values, item) {
                var l = mfp.items.length;
                values.counter = l > 1 ? _replaceCurrTotal(gSt.tCounter, item.index, l) : '';
            });

            _mfpOn('BuildControls' + ns, function () {
                if (mfp.items.length > 1 && gSt.arrows && !mfp.arrowLeft) {
                    var markup = gSt.arrowMarkup,
                        arrowLeft = mfp.arrowLeft =
                            $(markup.replace(/%title%/gi, gSt.tPrev).replace(/%dir%/gi, 'left')).addClass(PREVENT_CLOSE_CLASS),
                        arrowRight = mfp.arrowRight = $(markup.replace(/%title%/gi, gSt.tNext).replace(/%dir%/gi, 'right')).addClass(PREVENT_CLOSE_CLASS);

                    var eName = supportsFastClick ? 'mfpFastClick' : 'click';
                    arrowLeft[eName](function () {
                        mfp.prev();
                    });
                    arrowRight[eName](function () {
                        mfp.next();
                    });

                    // Polyfill for :before and :after (adds elements with classes mfp-a and mfp-b)
                    if (mfp.isIE7) {
                        _getEl('b', arrowLeft[0], false, true);
                        _getEl('a', arrowLeft[0], false, true);
                        _getEl('b', arrowRight[0], false, true);
                        _getEl('a', arrowRight[0], false, true);
                    }

                    mfp.container.append(arrowLeft.add(arrowRight));
                }
            });

            _mfpOn(CHANGE_EVENT + ns, function () {
                if (mfp._preloadTimeout) clearTimeout(mfp._preloadTimeout);

                mfp._preloadTimeout = setTimeout(function () {
                    mfp.preloadNearbyImages();
                    mfp._preloadTimeout = null;
                }, 16);
            });


            _mfpOn(CLOSE_EVENT + ns, function () {
                _document.off(ns);
                mfp.wrap.off('click' + ns);

                if (mfp.arrowLeft && supportsFastClick) {
                    mfp.arrowLeft.add(mfp.arrowRight).destroyMfpFastClick();
                }
                mfp.arrowRight = mfp.arrowLeft = null;
            });

        },
        next: function () {
            mfp.direction = true;
            if (_breakGalleryCyclical(mfp.index, mfp.items.length, mfp.direction)) {
                mfp.index = _getLoopedId(mfp.index + 1);
                //NOTE slide change animation
                /*mfp.content.fadeOut(0, function () {
                    mfp.updateItemHTML();
                    mfp.content.fadeIn(150);
                });*/
                mfp.updateItemHTML();
            }
        },
        prev: function () {
            mfp.direction = false;
            if (_breakGalleryCyclical(mfp.index, mfp.items.length, mfp.direction)) {
                mfp.index = _getLoopedId(mfp.index - 1);
                //NOTE slide change animation
                /*mfp.content.fadeOut(0, function () {
                    mfp.updateItemHTML();
                    mfp.content.fadeIn(150);
                });*/
                mfp.updateItemHTML();
            }
        },
        goTo: function (newIndex) {
            mfp.direction = (newIndex >= mfp.index);
            mfp.index = newIndex;
            mfp.updateItemHTML();
        },
        preloadNearbyImages: function () {
            var p = mfp.st.gallery.preload,
                preloadBefore = Math.min(p[0], mfp.items.length),
                preloadAfter = Math.min(p[1], mfp.items.length),
                i;

            for (i = 1; i <= (mfp.direction ? preloadAfter : preloadBefore) ; i++) {
                mfp._preloadItem(mfp.index + i);
            }
            for (i = 1; i <= (mfp.direction ? preloadBefore : preloadAfter) ; i++) {
                mfp._preloadItem(mfp.index - i);
            }
        },
        _preloadItem: function (index) {
            index = _getLoopedId(index);

            if (mfp.items[index].preloaded) {
                return;
            }

            var item = mfp.items[index];
            if (!item.parsed) {
                item = mfp.parseEl(index);
            }

            _mfpTrigger('LazyLoad', item);

            if (item.type === 'image') {
                item.img = $('<img class="mfp-img" />').on('load.mfploader', function () {
                    item.hasSize = true;
                }).on('error.mfploader', function () {
                    item.hasSize = true;
                    item.loadError = true;
                    _mfpTrigger('LazyLoadError', item);
                }).attr('src', item.src);
            }


            item.preloaded = true;
        }
    }
});

/*
Touch Support that might be implemented some day

addSwipeGesture: function() {
    var startX,
        moved,
        multipleTouches;

        return;

    var namespace = '.mfp',
        addEventNames = function(pref, down, move, up, cancel) {
            mfp._tStart = pref + down + namespace;
            mfp._tMove = pref + move + namespace;
            mfp._tEnd = pref + up + namespace;
            mfp._tCancel = pref + cancel + namespace;
        };

    if(window.navigator.msPointerEnabled) {
        addEventNames('MSPointer', 'Down', 'Move', 'Up', 'Cancel');
    } else if('ontouchstart' in window) {
        addEventNames('touch', 'start', 'move', 'end', 'cancel');
    } else {
        return;
    }
    _window.on(mfp._tStart, function(e) {
        var oE = e.originalEvent;
        multipleTouches = moved = false;
        startX = oE.pageX || oE.changedTouches[0].pageX;
    }).on(mfp._tMove, function(e) {
        if(e.originalEvent.touches.length > 1) {
            multipleTouches = e.originalEvent.touches.length;
        } else {
            //e.preventDefault();
            moved = true;
        }
    }).on(mfp._tEnd + ' ' + mfp._tCancel, function(e) {
        if(moved && !multipleTouches) {
            var oE = e.originalEvent,
                diff = startX - (oE.pageX || oE.changedTouches[0].pageX);

            if(diff > 20) {
                mfp.next();
            } else if(diff < -20) {
                mfp.prev();
            }
        }
    });
},
*/


var IFRAME_NS = 'iframe',
    _emptyPage = '//about:blank',

    _fixIframeBugs = function (isShowing) {
        if (mfp.currTemplate[IFRAME_NS]) {
            var el = mfp.currTemplate[IFRAME_NS].find('iframe');
            if (el.length) {
                // reset src after the popup is closed to avoid "video keeps playing after popup is closed" bug
                if (!isShowing) {
                    el[0].src = _emptyPage;
                }

                // IE8 black screen bug fix
                if (mfp.isIE8) {
                    el.css('display', isShowing ? 'block' : 'none');
                }
            }
        }
    },
    _getVideoId = function () {
        var embedSrc = mfp.currItem.src,
            iframeSt = mfp.st.iframe,
            tempVideoId,
            videoId;

        $.each(iframeSt.patterns, function () {
            if (embedSrc.indexOf(this.index) > -1) {
                if (this.id) {
                    if (typeof this.id === 'string') {
                        tempVideoId = embedSrc.substr(embedSrc.lastIndexOf(this.id) + this.id.length, embedSrc.length);
                    } else {
                        tempVideoId = this.id.call(this, embedSrc);
                    }
                }
                if (tempVideoId != 'undefined') {
                    videoId = tempVideoId;
                } else {
                    videoId = videoId;
                }
            }
        });
        return videoId;
    };

$.magnificPopup.registerModule(IFRAME_NS, {
    options: {
        markup: '<div class="mfp-iframe-scaler mfp-figure">' +
                    '<div class="mfp-title" data-mfp-title></div>' +
                    '<div class="mfp-figure" data-mfp-wrapper>' +
                        '<iframe class="mfp-iframe" src="//about:blank" frameborder="0" allowfullscreen></iframe>' +
                        '<div class="mfp-figcaption" data-mfp-bottom>' +
                            '<div class="mfp-bottom-bar">' +
                                '<div class="mfp-desc"></div>' +
                                '<div class="mfp-buttons"></div>' +
                            '</div>' +
                        '</div>' +
                    '</div>' +
                '</div>',

        srcAction: 'iframe_src',

        // we don't care and support only one default type of URL by default
        patterns: {
            youtube: {
                index: 'youtube.com',
                id: 'v=',
                src: '//www.youtube.com/embed/%id%?autoplay=1&enablejsapi=1&fs=0&rel=0'
            },
            vimeo: {
                index: 'vimeo.com/',
                id: '/',
                src: '//player.vimeo.com/video/%id%?api=1&fullscreen=0&autoplay=1'
            },
            gmaps: {
                index: '//maps.google.',
                src: '%id%&output=embed'
            }
        }
    },

    proto: {
        initIframe: function () {
            mfp.types.push(IFRAME_NS);

            _mfpOn('BeforeChange', function (e, prevType, newType) {
                if (prevType !== newType) {
                    if (prevType === IFRAME_NS) {
                        _fixIframeBugs(); // iframe if removed
                    } else if (newType === IFRAME_NS) {
                        _fixIframeBugs(true); // iframe is showing
                    }
                } // else {
                // iframe source is switched, don't do anything
                //}
            });

            _mfpOn(OPEN_EVENT + '.' + IFRAME_NS, function () {
                //_saveYoutubeLastState($('.mfp-iframe'));
                if (mfp.currItem.type == 'iframe') {
                    mfp.container.addClass('mfp-s-ready-animate');
                }
                $(window.document).trigger('videoLightboxOpened');
            });

            _mfpOn(CLOSE_EVENT + '.' + IFRAME_NS, function () {
                _fixIframeBugs();
                if (mfp.currItem.type == 'iframe') {
                    if (typeof RegisterPageEvent !== 'undefined' && $.isFunction(RegisterPageEvent)) {
                        RegisterPageEvent('event_watch_video-' + _getVideoId() + window.location.pathname);
                    }
                }
            });

        },

        getIframe: function (item, template) {
            //ToDo опционально перeдать только videoid, и не делать все ....
            var embedSrc = item.src;    // == mfp.currItem.src
            var iframeSt = mfp.st.iframe;

            //ToDO обобщить с _getVideoId(mfp)
            $.each(iframeSt.patterns, function () {
                if (embedSrc.indexOf(this.index) > -1) {
                    if (this.id) {
                        if (typeof this.id === 'string') {
                            embedSrc = embedSrc.substr(embedSrc.lastIndexOf(this.id) + this.id.length, embedSrc.length);
                        } else {
                            embedSrc = this.id.call(this, embedSrc);
                        }
                    }
                    embedSrc = this.src.replace('%id%', embedSrc);
                    return false; // break;
                }
            });

            var dataObj = {
                title: _getTitle(item),
                desc: _getDesc(item),
                buttons: _getButtons(item)
            };
            if (iframeSt.srcAction) {
                dataObj[iframeSt.srcAction] = embedSrc;
            }

            mfp._parseMarkup(template, dataObj, item);

            mfp.updateStatus('ready');

            return template;
        }
    }
});

/**
* FastClick event implementation. (removes 300ms delay on touch devices)
* Based on https://developers.google.com/mobile/articles/fast_buttons
*
* You may use it outside the Magnific Popup by calling just:
*
* $('.your-el').mfpFastClick(function() {
*     console.log('Clicked!');
* });
*
* To unbind:
* $('.your-el').destroyMfpFastClick();
* 
* 
* Note that it's a very basic and simple implementation, it blocks ghost click on the same element where it was bound.
* If you need something more advanced, use plugin by FT Labs https://github.com/ftlabs/fastclick
* 
*/

(function () {
    var ghostClickDelay = 1000,
        supportsTouch = 'ontouchstart' in window,
        unbindTouchMove = function () {
            _window.off('touchmove' + ns + ' touchend' + ns);
        },
        eName = 'mfpFastClick',
        ns = '.' + eName;


    // As Zepto.js doesn't have an easy way to add custom events (like jQuery), so we implement it in this way
    $.fn.mfpFastClick = function (callback) {

        return $(this).each(function () {

            var elem = $(this),
                lock;

            if (supportsTouch) {

                var timeout,
                    startX,
                    startY,
                    pointerMoved,
                    point,
                    numPointers;

                elem.on('touchstart' + ns, function (e) {
                    pointerMoved = false;
                    numPointers = 1;

                    point = e.originalEvent ? e.originalEvent.touches[0] : e.touches[0];
                    startX = point.clientX;
                    startY = point.clientY;

                    _window.on('touchmove' + ns, function (e) {
                        point = e.originalEvent ? e.originalEvent.touches : e.touches;
                        numPointers = point.length;
                        point = point[0];
                        if (Math.abs(point.clientX - startX) > 10 ||
                            Math.abs(point.clientY - startY) > 10) {
                            pointerMoved = true;
                            unbindTouchMove();
                        }
                    }).on('touchend' + ns, function (e) {
                        unbindTouchMove();
                        if (pointerMoved || numPointers > 1) {
                            return;
                        }
                        lock = true;
                        e.preventDefault();
                        clearTimeout(timeout);
                        timeout = setTimeout(function () {
                            lock = false;
                        }, ghostClickDelay);
                        callback();
                    });
                });

            }

            elem.on('click' + ns, function () {
                if (!lock) {
                    callback();
                }
            });
        });
    };

    $.fn.destroyMfpFastClick = function () {
        $(this).off('touchstart' + ns + ' click' + ns);
        if (supportsTouch) _window.off('touchmove' + ns + ' touchend' + ns);
    };
})();

// Add it after jquery.magnific-popup.js and before first initialization code
$.extend(true, $.magnificPopup.defaults, {
    tClose: 'Закрыть [Esc]', // Alt text on close button
    tLoading: '', // 'Загрузка...' Text that is displayed during loading. Can contain %curr% and %total% keys
    gallery: {
        tPrev: window.attachEvent && !window.addEventListener ? 'Предыдущий' : '[&larr;] Предыдущий', // Alt text on left arrow
        tNext: window.attachEvent && !window.addEventListener ? 'Следующий' : 'Следующий [&rarr;]', // Alt text on right arrow
        tCounter: '%curr% из %total%' // Markup for "1 of 7" counter
    },
    image: {
        tError: 'Изображение не загрузилось.' // <a href="%url%">Изображение</a> не загрузилось.    //Запрашиваемое изображение недоступно. Попробуйте позже.
    },
    ajax: {
        tError: 'Контент не загрузился.' // <a href="%url%">Контент</a> не загрузился.
    },
    removalDelay: 800,
    closeMarkup: '<span title="%title%" class="mfp-close"></span>'
});

var Kontur = Kontur || {};

// for backward compatibility [
$.fn.gallery = function (options) {
    var ops = Kontur.Gallery.defaultOptions;

    if (options && options.index) {
        ops.index = options.index;
    }

    ops.gallery.enabled = $(this).length > 1 ? true : false;

    this.magnificPopup(ops);
};

$.gallery = {
    open: function (obj, options) {

        var ops = Kontur.Gallery.defaultOptions;

        if (options && options.index) {
            ops.index = options.index;
        }

        var itemsObj;

        itemsObj = { 'items': obj.get() };

        ops.gallery.enabled = obj.length > 1 ? true : false;

        ops = $.extend(true, {}, ops, itemsObj);
        $.magnificPopup.open(ops);
    }
};

$(document).on('click', '[data-videoid]', function () {
    var self = $(this),
        videoId = self.data('videoid');

    if (videoId && videoId.length) {
        self.attr('href', '//www.youtube.com/watch?v=' + videoId);
    }

    if (self.attr('data-lightboxparams') && $.type(window[self.attr('data-lightboxparams')]) == 'object') {
        var params = window[self.attr('data-lightboxparams')];
        if (params.panelHtml) {
            self.attr('data-bottom-panel', params.panelHtml);
        }
    }

    $.magnificPopup.open({
        items: self.get(),
        disableOn: 700,
        type: 'iframe',
        preloader: false,
        closeBtnInside: false
    });
    return false;
});

$(window).on('openVideoLightbox', function (e, videoId) {
    if (!videoId) {
        return;
    }
    $.magnificPopup.open({
        items: {
            src: '//www.youtube.com/watch?v=' + videoId
        },
        disableOn: 700,
        type: 'iframe',
        preloader: false,
        closeBtnInside: false
    });
});

// ] for backward compatibility




;
/* ========================================================================
 * Bootstrap: dropdown.js v3.2.0
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

    var backdrop = '.dropdown-backdrop',
        toggle = '[data-toggle="dropdown"]',
        Dropdown = function (element) {
            $(element).on('click.bs.dropdown', this.toggle);
        };

    Dropdown.VERSION = '3.2.0';

    Dropdown.prototype.toggle = function(e) {
        var $this = $(this);
        if ($this.is('.disabled, :disabled')) return;

        var $parent = getParent($this),
            isActive = $parent.hasClass('open');
        clearMenus();

        if (!isActive) {
            if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
                // if mobile we use a backdrop because click events don't delegate
                $('<div class="dropdown-backdrop"/>').insertAfter($(this)).on('click', clearMenus);
            }

            var relatedTarget = { relatedTarget: this };
            $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget));

            if (e.isDefaultPrevented()) return;

            $this.trigger('focus');

            $parent
                .toggleClass('open')
                .trigger('shown.bs.dropdown', relatedTarget);
        }

        return false;
    };

    Dropdown.prototype.keydown = function(e) {
        if (!/(38|40|27)/.test(e.keyCode)) return;

        var $this = $(this);

        e.preventDefault();
        e.stopPropagation();

        if ($this.is('.disabled, :disabled')) return;

        var $parent = getParent($this),
            isActive = $parent.hasClass('open');

        if (!isActive || (isActive && e.keyCode == 27)) {
            if (e.which == 27) $parent.find(toggle).trigger('focus');
            return $this.trigger('click');
        }

        var desc = ' li:not(.divider):visible a',
            $items = $parent.find('[role="menu"]' + desc + ', [role="listbox"]' + desc);

        if (!$items.length) return;

        var index = $items.index($items.filter(':focus'));

        if (e.keyCode == 38 && index > 0) index--; // up
        if (e.keyCode == 40 && index < $items.length - 1) index++; // down
        if (!~index) index = 0;

        $items.eq(index).trigger('focus');
    };

  function clearMenus(e) {
      if (e && e.which === 3) return;
      $(backdrop).remove();
      $(toggle).each(function() {
          var $parent = getParent($(this)),
              relatedTarget = { relatedTarget: this };
          if (!$parent.hasClass('open')) return;
          $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget));
          if (e.isDefaultPrevented()) return;
          $parent.removeClass('open').trigger('hidden.bs.dropdown', relatedTarget);
      });
  }

  function getParent($this) {
      var selector = $this.attr('data-target');

    if (!selector) {
        selector = $this.attr('href');
        selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, ''); // strip for ie7
    }

      var $parent = selector && $(selector);

      return $parent && $parent.length ? $parent : $this.parent();
  }


  // DROPDOWN PLUGIN DEFINITION
  // ==========================

    function Plugin(option) {
        return this.each(function() {
            var $this = $(this),
                data = $this.data('bs.dropdown');

            if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)));
            if (typeof option == 'string') data[option].call($this);
        });
    }

    var old = $.fn.dropdown;
    $.fn.dropdown = Plugin;
    $.fn.dropdown.Constructor = Dropdown;

  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
      $.fn.dropdown = old;
      return this;
  }


  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

    $(document)
        .on('click.bs.dropdown.data-api', clearMenus)
        .on('click.bs.dropdown.data-api', '.dropdown form', function(e) { e.stopPropagation(); })
        .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
        .on('keydown.bs.dropdown.data-api', toggle + ', [role="menu"], [role="listbox"]', Dropdown.prototype.keydown);

}(jQuery);
Kontur.Module("Kontur.Dropdown", function ($) {
    var dropdown = [];

    $(function() {
        $('[data-toggle="dropdown"]').each(function () {
            dropdown.push(new Dropdown(this));
        });

        buindEvents();
    });

    function Dropdown(dropdown) {
        var $btn = $(dropdown),
            $el = $btn.closest('.dropdown'),
            $menu = getMenu($el);

        return {
            $el: $el,
            $btn: $btn,
            $menu: $menu,
            $chevron: $menu.find('.dropdown-drop__chevron'),
            y: getY($menu),
            closable: null
        }
    }

    function buindEvents() {
        $.each(dropdown, function(i, item) {
            autoclose(item);
            toggleOpen(item);
            smartPosition(item, true);
        });

        $(window).on('resize', function () {
            $.each(dropdown, function (i, item) {
                smartPosition(item);
            });
        });

        $(window).resize();
    }

    function getMenu($dropdown) {
        var $menu = $dropdown.data('target');

        return $menu ? $($menu) : $dropdown.closest('.dropdown').find('.dropdown-drop');
    }

    function getY($menu) {
        return Math.round($menu.outerWidth() + $menu.offset().left);
    }

    function detectOutsideClick(e, elem) {
        return !elem.is(e.target) && elem.has(e.target).length === 0;
    }

    function autoclose(dropdown) {
        var isAutoclose = dropdown.$btn.data('autoclose') == undefined ? true : dropdown.$btn.data('autoclose');

        if (!isAutoclose) {
            dropdown.$el.on({
                'shown.bs.dropdown': function() {
                     dropdown.closable = false;
                },
                'hide.bs.dropdown': function() {
                     return dropdown.closable;
                }
            });

            $('#pageWrapper').on('click', function (e) {
                dropdown.closable = detectOutsideClick(e, dropdown.$menu);
            });
        }
        // автоматически закрывается при клике по умолчанию
    }

    function toggleOpen(dropdown) {
        dropdown.$menu.on('show.bs.dropdown', function (e) {
            $(e.relatedTarget).addClass('open');
        });

        dropdown.$menu.on('hide.bs.dropdown', function (e) {
            $(e.relatedTarget).removeClass('open');
        });
    }

    function position($el, delta) {
        var left = Math.round(parseInt($el.css('left'), 10) + parseInt($el.css('marginLeft'), 10));

        left += delta;

        $el.css({
            marginLeft: 0,
            left: left
        });
    }

    function smartPosition(dropdown, isInit) {
        var $container = $('body'),
            y = getY(dropdown.$menu),
            maxY = $container.width();

        if (!isInit) {
            if (dropdown.y === y || dropdown.y <= maxY) {
                dropdown.$menu.removeAttr('style');
                dropdown.$chevron.removeAttr('style');
                return;
            }            
        }

        position(dropdown.$menu, maxY - y);
        position(dropdown.$chevron, y - maxY);
    }
}, [jQuery]);
Kontur.Module('Kontur.Animate', function($) {
    this.animateCss = function ($el, animationName) {
        var animationEnd = 'webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend',
            phase = getPhase(animationName);

        if (phase == 'in') {
            $el.removeClass('hide none').show();
        }

        if (!Modernizr.csstransitions) {
            animateEnd();
        }

        $el.addClass(animationName).one(animationEnd, function() {
            animateEnd();
        });

        function animateEnd() {
            $el.removeClass(animationName);
            if (phase == 'out') {
                $el.hide();
            }
        }

        function getPhase(animationName) {
            return animationName.indexOf('In') != -1 ? 'in' : animationName.indexOf('Out') != -1 ? 'out' : '';
        }
    }
}, [jQuery]);
(function ($) {

    function initialize() {
        $(document).on('click', '.js-product-enter', onLinkClick);
    }

    function onLinkClick() {
        var $link = $(this);
        $.post($link.data('visitor-event-url'), {
            productName: $link.data('product-name')
        });
    }

    $(initialize);

})(jQuery);
